<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>misc | Hexo</title><meta name="author" content="fallingleaflun"><meta name="copyright" content="fallingleaflun"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[toc]  Markdown1、Markdown 数学公式以及符号整理2、Markdown KaTex 点乘，叉乘，点除，分数3、Markdown书写数学公式4、Markdown 分段函数写法5、Markdown小技巧—添加空格6、markdown中的矩阵表示  Git参考链接 在 Git 中任何 已提交 的东西几乎总是可以恢复的 然而，任何你未提交的东西丢失后很可能再也找不到了 1234567">
<meta property="og:type" content="article">
<meta property="og:title" content="misc">
<meta property="og:url" content="http://example.com/2023/05/16/mame/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="[toc]  Markdown1、Markdown 数学公式以及符号整理2、Markdown KaTex 点乘，叉乘，点除，分数3、Markdown书写数学公式4、Markdown 分段函数写法5、Markdown小技巧—添加空格6、markdown中的矩阵表示  Git参考链接 在 Git 中任何 已提交 的东西几乎总是可以恢复的 然而，任何你未提交的东西丢失后很可能再也找不到了 1234567">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-05-16T14:52:16.784Z">
<meta property="article:modified_time" content="2023-06-01T03:05:37.654Z">
<meta property="article:author" content="fallingleaflun">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/05/16/mame/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'misc',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-01 11:05:37'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Hexo"><span class="site-name">Hexo</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">misc</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-16T14:52:16.784Z" title="发表于 2023-05-16 22:52:16">2023-05-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-01T03:05:37.654Z" title="更新于 2023-06-01 11:05:37">2023-06-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="misc"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[toc]</p>
<hr>
<h2 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h2><p>1、<a target="_blank" rel="noopener" href="https://blog.csdn.net/SunshineSki/article/details/84195807">Markdown 数学公式以及符号整理</a><br>2、<a target="_blank" rel="noopener" href="https://blog.csdn.net/COCO56/article/details/100190031">Markdown KaTex 点乘，叉乘，点除，分数</a><br>3、<a target="_blank" rel="noopener" href="https://blog.csdn.net/kingov/article/details/78444756">Markdown书写数学公式</a><br>4、<a target="_blank" rel="noopener" href="https://blog.csdn.net/Hey___Man/article/details/79272137">Markdown 分段函数写法</a><br>5、<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/61f6e84619de">Markdown小技巧—添加空格</a><br>6、<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/756bc7e0ef6d">markdown中的矩阵表示</a></p>
<hr>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p><a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%85%B3%E4%BA%8E%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6">参考链接</a></p>
<p>在 Git 中任何 <strong>已提交</strong> 的东西几乎总是可以恢复的</p>
<p><strong>然而，任何你未提交的东西丢失后很可能再也找不到了</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化仓库</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment">#本地修改相关</span></span><br><span class="line"><span class="comment">#添加所有文件到暂存区</span></span><br><span class="line">git add .</span><br><span class="line"><span class="comment">#取消某些文件的暂存</span></span><br><span class="line">git reset HEAD &lt;file&gt;..</span><br><span class="line"><span class="comment">#提交修改</span></span><br><span class="line">git commit -m <span class="string">&quot;修改&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 回退相关，慎用reset!!</span></span><br><span class="line"><span class="comment"># 查看commit历史</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"><span class="comment"># 回退，其实是移动HEAD的指向</span></span><br><span class="line">git reset [--soft|--hard]</span><br><span class="line"><span class="comment"># 查看所有分支所有操作记录</span></span><br><span class="line">git reflog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 与远程仓库交互</span></span><br><span class="line"><span class="comment"># 增加远程仓库相关</span></span><br><span class="line">git remote add origin git@github.com:fallingleaflun/mame.git</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;fallingleaflun@gmail.com&quot;</span></span><br><span class="line"><span class="comment"># 在github设置ssh</span></span><br><span class="line">git config --global user.email <span class="string">&quot;fallingleaflun@gmail.com&quot;</span></span><br><span class="line">git config --global user.name <span class="string">&quot;fallingleaflun&quot;</span></span><br><span class="line">git commit -m <span class="string">&quot;202107271303&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传</span></span><br><span class="line">git push origin master</span><br><span class="line"><span class="comment"># 强制上传(危险)</span></span><br><span class="line">git push origin master -f</span><br><span class="line"><span class="comment"># 下载</span></span><br><span class="line">git pull origin master</span><br><span class="line"><span class="comment"># 强制下载</span></span><br><span class="line">git pull origin master -f</span><br></pre></td></tr></table></figure>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left">三棵树</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">HEAD</td>
<td align="left">该分支上一次提交的快照，下一次提交的父结点。</td>
</tr>
<tr>
<td align="left">Index</td>
<td align="left">预期的下一次提交的快照</td>
</tr>
<tr>
<td align="left">Working Directory</td>
<td align="left">沙盒</td>
</tr>
</tbody></table>
<p><img src="https://git-scm.com/book/en/v2/images/reset-workflow.png" alt="reset workflow"></p>
<p>reset会移动HEAD<br>reset 命令会以特定的顺序重写这三棵树：</p>
<ul>
<li>移动 HEAD 分支的指向 （若指定了 –soft，则到此停止）</li>
<li>使index看起来像HEAD （若未指定 –hard，则到此停止）</li>
<li>使wd看起来像index</li>
</ul>
<hr>
<h2 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h2><p> Hook 技术又叫做钩子函数，在系统没有调用该函数之前，钩子程序就先捕获该消息，钩子函数先得到控制权，这时钩子函数既可以加工处理（改变）该函数的执行行为，还可以强制结束消息的传递。简单来说，就是把系统的程序拉出来变成我们自己执行代码片段。</p>
<p>作者：radish520like<br>链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3382cc765b39">https://www.jianshu.com/p/3382cc765b39</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<hr>
<h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>分为SNAT和DNAT</p>
<p>SNAT修改请求数据包中的原ip，内部主机访问外网用到</p>
<p>DNAT则相反</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/beanewself/article/details/78317626">https://blog.csdn.net/beanewself/article/details/78317626</a></p>
<hr>
<h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><p>对象关系映射——通过实例对象的语法，完成关系数据库的操作的技术</p>
<p>表-&gt;类，行-&gt;对象，字段-&gt;对象的属性</p>
<hr>
<h2 id="Pecan"><a href="#Pecan" class="headerlink" title="Pecan"></a>Pecan</h2><p>一个python的轻量级web框架</p>
<p>基于MVC模型</p>
<p>app.py决定应用如何创造，包括setup_app方法</p>
<p>controllers是控制层，底下有root.py（RootController）</p>
<p>model是模型层，在<code>__init__.py</code>里面加入与数据库交互的东西，表，ORM之类的</p>
<p>templates是模板实现</p>
<p>tests是单元测试</p>
<p><a target="_blank" rel="noopener" href="http://luckylau.tech/2017/03/01/python%E7%9A%84pecan%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/">http://luckylau.tech/2017/03/01/python%E7%9A%84pecan%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/</a></p>
<p>参照openstack watcher的结构建立了一个demo</p>
<p>api文件夹有上述的一些文件结构</p>
<p>还有一个cmd文件夹下有api.py，这个文件①调用setup_app构建WSGIapp，②用wsgiref.simple_server.make_server在指定ip与端口部署、运行这个app</p>
<p>当然watcher用的不是这个，而是用common.service自己封装的方法,其实是用到了oslo_service</p>
<hr>
<h2 id="WSME"><a href="#WSME" class="headerlink" title="WSME"></a>WSME</h2><p>专门用于实现REST服务的typing库，能检查HTTP请求和相应的数据是否符合预先设定好的要求</p>
<hr>
<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>远程过程调用，基本模型需要传递一个函数名、形参、实参</p>
<p>与基于HTTP的RESTFul模式对比</p>
<p>RPC采用CS模式，请求程序是Client，服务提供程序是Server</p>
<p>OpenStack用AMQP（RabbitMQ实现)</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qiuhan0314/article/details/42671965">https://blog.csdn.net/qiuhan0314/article/details/42671965</a></p>
<p>Nova中定义了两种RPC调用方式——<code>rpc.call</code>与<code>rpc.cast</code></p>
<p>call是请求响应模式，cast则不等待响应</p>
<p>Nova定义了Publisher、Consumer、Exchange</p>
<p>分别都有Topic 与 Direct修饰（比如Topic publisher)</p>
<p>Topic用于client向server，Direct则反过来</p>
<p>Topic Exchange可关联多个队列，而Direct Exchange只关联一个队列</p>
<hr>
<h3 id="下面简述一下oslo-messaging的结构"><a href="#下面简述一下oslo-messaging的结构" class="headerlink" title="下面简述一下oslo.messaging的结构"></a><em>下面简述一下oslo.messaging的结构</em></h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_47495420/article/details/105985806">https://blog.csdn.net/m0_47495420/article/details/105985806</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Bill_Xiang_/article/details/78500769?utm_source=blogxgwz0">https://blog.csdn.net/Bill_Xiang_/article/details/78500769?utm_source=blogxgwz0</a></p>
<p>client.py——客户端启动脚本</p>
<p>dispatcher.py——rpc或notification，负责将客户端发布的消息分发给相应的方法处理。会利用Transport类获得监听器，报告给Executor，</p>
<p>impl_***.py——核心代码，实现了消费者、生产者、建立连接等操作</p>
<p>manager.py——定义处理RPC请求的方法</p>
<p>rpc_amqp.py——发送RPC请求和发生RPC响应</p>
<p>rpc.py——为外部提供访问API</p>
<p>server.py——服务器，有transport、dispatcher、executor、生命周期函数<code>start(),stop(),wait()</code></p>
<p>service.py——创建和管理RPC服务</p>
<p>transport.py——transport是消息中间件（rabbitMQ or Qpid or ZeroMQ）的抽象，需要指定消息通信服务器的地址、用户名、密码等参数，构造一个Transport对象需要提供一条transport_url，这个是在conf中定义的</p>
<p>target.py——定义了Target()，客户端请求时需要指明target，server也需要指定target说明接收哪些RPC调用，</p>
<p>executor——从transport中获得消息并把它分配给dispatcher的策略，可以是<code>&#39;threading&#39;</code>或者是<code>&#39;eventlet&#39;</code>，eventlet是开一个线程异步</p>
<hr>
<h3 id="rpc-call执行的流程："><a href="#rpc-call执行的流程：" class="headerlink" title="rpc.call执行的流程："></a><em><code>rpc.call</code>执行的流程：</em></h3><p>1). server.py创建并启动RPC服务：<code>__init__</code>（涉及到Manager）、<code>start</code>、<code>drain_events</code></p>
<p>2). start方法内调用<code>rpc.create_connection</code>建立和RabbitMQ的连接，Connection定义在impl_***.py中</p>
<p>3). server创建和激活Topic Consumer</p>
<p>4). client向Topic Exchange发送RPC请求</p>
<p>5). server接收和处理RPC请求</p>
<p>6). client创建和激活Direct Consumer</p>
<p>7). server向Direct Exchange发送RPC响应</p>
<hr>
<h3 id="openstack服务流程简述"><a href="#openstack服务流程简述" class="headerlink" title="openstack服务流程简述"></a>openstack服务流程简述</h3><p><code>cmd/api.py</code>的main()函数是开始的地方，它主要做了下面的事</p>
<ul>
<li>读取命令行以及配置文件的参数缓存到内存中的配置对象CONF，以后需要用到配置参数时就能导入CONF对象获取配置项(这一部分主要用到oslo_config)</li>
<li>创建日志对象(这一部分主要用到oslo_log)</li>
<li>初始化RPC</li>
<li>创建一个WSGIService，创建一个Launcher，然后用Launcher启动WSGIService，之后<code>Launcher.wait()</code>等待请求</li>
</ul>
<p>创建web应用，<code>api/v1/</code>目录下面的controller负责接收http请求(RESTFul)然后进行处理。api.py做的事还有创建并启动service，Service需要一个manager，Service能①监听队列②执行manager的定期任务(PeriodicTask)，详见下面第5点</p>
<p>以karbor的restore create动作为例</p>
<ol>
<li><p>在<code>api/restores.py</code>中的<code>RestoresController.create()</code>把请求封装为一个实体对象（objects&#x2F;目录下就是各个对象的定义，创建对象时，objects会调用<code>db/</code>目录下的api.py的restore_create函数修改数据库）</p>
</li>
<li><p>接着是<code>api/restores.py</code>继续来一句<code># call restore rpc API of protection service</code>，说明api开始调用protectoin的api了（注意这里是use-a关系，api这个service使用另一个service——protection的接口<code>services/protection/api.py</code></p>
</li>
<li><p>protection这个service接受调用，api不干正事，而是调用&#96;services&#x2F;protection&#x2F;rpcapi.py&#96;&#96;</p>
<p><code>services/protection/rpcapi.py</code>用到<code>rpc.py</code>的函数<code>get_client()</code>生成一个<code>RPCClient</code></p>
<p>具体的：调用<code>get_client()</code>时需要为<code>RPCClient</code>指定<code>Target</code>，而创建<code>Target</code>需要指定<code>topic</code>，为了结构清晰，创建<code>topic</code>的配置信息用到CONF，具体是指定了在<code>common/config.py</code>中的<code>global_opts</code>中的<code>protection_topic</code></p>
</li>
<li><p><code>oslo_messaging.RPCClient</code>然后使用<code>RPCClient.call(context,方法名,参数列表)</code>，<code>call</code>把rpc参数封装成消息之后调用<code>Transport._send()</code>，这个又调用驱动_driver的send发送到消息队列</p>
</li>
<li><p>Client搞定了，接下来看Server需要配置的内容</p>
<p>一开始<code>cmd/api.py</code>就搞了一个service，这里涉及<code>service.py</code>，它的start方法调用了<code>rpc.py</code>里面的<code>get_server()</code>方法创建出一个RPCServer，这需要为RPCServer指定Target以及Dispatcher，<strong>RPCDispatcher需要endpoints</strong>，<code>services.py</code>里有一句<code>endpoints=[self.manager]</code>，endpoints所以是一个manager列表</p>
<ul>
<li><p>Manager类继承了karbor.db.base.Base类以及oslo_service的PeriodicTasks类，能够周期执行以及访问数据库</p>
<p><code>services.py</code>在<code>init</code>时就用<code>manager.periodic_tasks</code>得到periodic，之后再在<code>start()</code>方法调用<code>peropdic.start()</code>使得manager的方法周期性执行。一般是用装饰器的方式(<code>@periodic_task.periodic_task</code>)去装饰需要周期性运行的方法，但是我在karbor的源码中找不到这一类方法，在nova倒是能找到。</p>
</li>
</ul>
</li>
<li><p>关于消息传递的过程，其实是<code>RPCDispatcher.dispatch(incoming)</code>从income中得到message和上下文ctxt，从message中得到method，再结合endpoint找到对应的消息处理函数，并执行和返回结果。</p>
<p>细节：在<code>oslo.messaging/dispatcher.py</code>的<code>_do_dispatch()</code>中有一句</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func = <span class="built_in">getattr</span>(endpoint, method)</span><br><span class="line"><span class="comment">#从endpoint对象中获取名为method的方法，而这里的endpoint其实就是一个Manager类，所以要执行的函数都在Manager类中</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>ps.因此，当如果别的服务进程希望影响另一个服务进程时，那就可以通过 import 另一个服务进程的 rpcapi 实现</p>
<hr>
<h2 id="oslo库"><a href="#oslo库" class="headerlink" title="oslo库"></a>oslo库</h2><h3 id="oslo-cache"><a href="#oslo-cache" class="headerlink" title="oslo.cache"></a>oslo.cache</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Bill_Xiang_/article/details/78701612">https://blog.csdn.net/Bill_Xiang_/article/details/78701612</a></p>
<p>实现了四种后端缓存机制的支持，包括Memcache、etcd 3.x、MongoDB、dictionary，还支持dogpile.cache库本身实现的各类缓存机制，包括Redis、dbm、memory、pylibmc等</p>
<hr>
<h3 id="oslo-concurrency"><a href="#oslo-concurrency" class="headerlink" title="oslo.concurrency"></a>oslo.concurrency</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Bill_Xiang_/article/details/78624752">https://blog.csdn.net/Bill_Xiang_/article/details/78624752</a></p>
<p>为OpenStack其他项目提供用于管理线程的工具库</p>
<hr>
<h3 id="oslo-config"><a href="#oslo-config" class="headerlink" title="oslo.config"></a>oslo.config</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Bill_Xiang_/article/details/78392616">https://blog.csdn.net/Bill_Xiang_/article/details/78392616</a></p>
<p>使用简述</p>
<ul>
<li><p>注册配置项</p>
<ol>
<li><p>from oslo_config import cfg&#96;</p>
</li>
<li><p>创建表示配置组的OptGroup类，如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">api_group = cfg.OptGroup(<span class="string">&#x27;api&#x27;</span>,</span><br><span class="line">    title=<span class="string">&#x27;API options&#x27;</span>,</span><br><span class="line">    <span class="built_in">help</span>=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Options under this group are used to define Nova API.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建详细配置项，其中可能根据不同类型用到不同的类，如：用cfg.StrOpt对象表示字符串类型的配置或者cfg.BoolOpt表示布尔类型</p>
</li>
<li><p>conf.register_group注册组，conf.register_opts(配置项，组)</p>
</li>
</ol>
</li>
<li><p>读取配置文件并使用配置参数</p>
<p>项目一般有一个目录如nova.conf以及一个config.py</p>
<ul>
<li><p>这个nova.conf中会注册完所有配置项</p>
</li>
<li><p>至于config.py则需要有一个函数<code>config.parse_args(sys.argv)</code>，这个函数需要有读取sys.argv里面的配置项以及配置文件的配置项的逻辑代码，其中会用到如下代码创建一个CONF</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONF(sys.argv[<span class="number">1</span>:], project=<span class="string">&#x27;karbor&#x27;</span>, version=version.version_string())</span><br></pre></td></tr></table></figure>

<p>这里sys.argv[1:]就是命令行参数，包括conf文件的路径</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="oslo-context"><a href="#oslo-context" class="headerlink" title="oslo.context"></a>oslo.context</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Bill_Xiang_/article/details/78458677">https://blog.csdn.net/Bill_Xiang_/article/details/78458677</a></p>
<p>oslo.context为所有OpenStack组件提供了一个保存请求上下文信息的基类，该类主要用来①存储一个Web请求的安全信息②为oslo.log提供上下文详情。</p>
<p>一般地，OpenStack项目在使用oslo.context时会实现一个继承自基类RequestContext的子类</p>
<hr>
<h3 id="oslo-db"><a href="#oslo-db" class="headerlink" title="oslo.db"></a>oslo.db</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Bill_Xiang_/article/details/78592389">https://blog.csdn.net/Bill_Xiang_/article/details/78592389</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/CaesarLinsa/p/9978558.html">https://www.cnblogs.com/CaesarLinsa/p/9978558.html</a></p>
<p>包含的方面：</p>
<ul>
<li>Session Handling，使用oslo_db.sqlalchemy.enginefacade</li>
<li>ModelBase，Model基类</li>
<li>DB API支持</li>
<li>DB扩展操作如版本控制以及数据同步</li>
</ul>
<p>例子概述：</p>
<ol>
<li><p>项目的<code>db/</code>结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db</span><br><span class="line">└───api.py			</span><br><span class="line">└───__init__.py</span><br><span class="line">└───sqlalchemy</span><br><span class="line">	└───api.py		#具体实现类</span><br><span class="line">	└───__init__.py</span><br><span class="line">	└───models.py	#实体类</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="oslo-messaging"><a href="#oslo-messaging" class="headerlink" title="oslo.messaging"></a>oslo.messaging</h3><ul>
<li><p>Target</p>
<ul>
<li>消息的目标</li>
<li>主要属性如下<ul>
<li>exchange：表示一组topic的范围。如果不显示指定，则默认使用control_exchange配置项的内容。</li>
<li>topic：定义了一组Message服务端暴露的接口。多个Message服务端可监听一个topic的消息，消息将通过轮询调度算法发送到其中一个服务端进行处理。</li>
<li>namespace：定义一个特别的RPC接口。默认的消息接口没有定义namespace，即namespace为null。</li>
<li>version：每个RPC接口都有自己的版本号（major.minor，主版本号.次版本号）。</li>
<li>server：表示RPC服务端，RPC客户端请求将发送到指定的RPC服务端进行处理。</li>
<li>fanout：如果fanout设置为True，则将RPC客户端的请求发送到监听该客户端topic的所有服务端进行处理；否则，发送到其中一个服务端进行处理。</li>
<li>legacy_namespaces：服务端可以利用namespace接收消息，也可以通过legacy_namespaces接收消息。该参数在系统滚动升级时必须指定，以用来安全的选择namespace。</li>
</ul>
</li>
<li>如果是RPC服务端的Target，则必须输入topic和server两个参数，exchange参数可选。</li>
<li>如果是RPC endpoint的Target，则可输入namespace和version两个可选参数。</li>
<li>如果是RPC客户端的Target，则必须输入topic参数，其他参数都可选。</li>
<li>如果是Notification服务端或Notifier的Target，则必须输入topic参数，exchange参数可选，其他参数直接忽略。</li>
</ul>
</li>
<li><p>Transport</p>
<ul>
<li>封装了传输方式</li>
<li>主要属性<ul>
<li>conf：表示一个ConfigOpts对象，可用于配置消息队列和RPC调用。</li>
<li>_driver：表示具体实现Transport类中传输方法的驱动类。在oslo.messaging中，OpenStack为各种消息队列（目前包括RabbitMQ、kafka、zmq、pika等）都实现了具体发送和接收消息的驱动类Driver；因此，在实例化Transport时，系统将根据配置文件指定的消息队列创建一个Driver对象，用来操作具体的消息队列。</li>
</ul>
</li>
<li>主要方法<ul>
<li>_send(target, ctxt, message, wait_for_reply&#x3D;None, timeout&#x3D;None, retry&#x3D;None)：发送RPC消息。</li>
<li>_send_notification(target, ctxt, message, version, retry&#x3D;None)：发送Notification通知消息。</li>
<li>_listen(target, batch_size, batch_timeout)：令服务端监听某一类topic消息。</li>
<li>_listen_for_notifications(targets_and_priorities, pool, batch_size, batch_timeout)：为服务端监听某一类通知消息。</li>
<li>cleanup()：清空Transport对象中的所有内容。</li>
<li>_require_driver_features(requeue&#x3D;False)：设置Driver的特性。</li>
</ul>
</li>
</ul>
</li>
<li><p>MessageHandlingServer</p>
<ul>
<li>表示一个处理消息的服务端。其通过一个知道应用如何创建新任务的线程将一个Transport对象和一个Dispatcher对象联系起来处理消息。属于一种Service，有生命周期。</li>
<li>主要属性<ul>
<li>transport：Transport类的一个对象，用于定义该RPC服务端的消息传输方式。</li>
<li>dispatcher：DispatcherBase类的一个对象，为RPC服务端定义消息分发机制。</li>
<li>executor：表示RPC服务端消息的类型，包括eventlet和threading两种类型。</li>
</ul>
</li>
<li>主要方法<ul>
<li>本身是一种Service，具有生命周期方法</li>
<li><em>create_listener()方法创建RPC消息监听器</em></li>
<li>process_incoming(incoming)方法处理接收到的消息请求</li>
<li>_on_incoming(incoming)方法处理on_incoming事件</li>
</ul>
</li>
</ul>
</li>
<li><p>Client</p>
<ul>
<li>表示客户端</li>
</ul>
</li>
<li><p>支持RPC与Notification两种通信机制</p>
<ul>
<li>RPC机制<ul>
<li>RPCTransport<ul>
<li>get_rpc_transport(conf, url&#x3D;None, allowed_remote_exmods&#x3D;None)：建立RPC连接</li>
</ul>
</li>
<li>RPCDispatcher<ul>
<li>dispatch(incoming)：定义消息的分发方式</li>
<li>该类首先解析消息队列中缓存的一条消息对象incoming，获取其消息内容message和消息上下文ctxt，并根据message获取消息对应的endpoint和method；然后调用_do_dispatch(endpoint, method, ctxt, args)进行分发操作。</li>
</ul>
</li>
<li>RPCServer<ul>
<li>_create_listener()：调用RPCTransport的<code> _listen()</code>进行消息的监听</li>
<li>_process_incoming(incoming)：处理接收到的消息，交给RPCDispatcher处理</li>
<li>get_rpc_server(transport, target, endpoints, executor&#x3D;’blocking’, serializer&#x3D;None, access_policy&#x3D;None)：获取一个RPCServer对象</li>
</ul>
</li>
<li>RPCClient<ul>
<li>prepare()：准备一个可以发送消息的环境变量_CallContext对象。_CallContext类继承自_BaseCallContext类，表示一个消息的上下文信息，其中缓存了transport、target、exchange、topic、namespace、version、retry等信息。服务端可以通过这个上下文信息找到消息对应的endpoint信息，进行消息分发。</li>
<li>_cast()：该方法为发送消息的方法，且该方法不会等待处理消息返回结果，即不会阻塞。该方法调用prepare()方法返回的_CallContext对象的cast()方法发送消息，而最终则是调用Transport对象的_send()方法将消息发送到消息队列中。</li>
<li>_call()：该方法也是发送消息的方法，与_cast()方法不同的是该方法会等待处理完返回相应的结果。该方法同样会调用_CallContext对象的call()方法发送消息，但是其会等待处理返回结果，并将结果返回给上层。</li>
</ul>
</li>
</ul>
</li>
<li>Notification机制<ul>
<li>典型的订阅者&#x2F;发布者模式，实现了Notification模式的RPC调用</li>
<li>Notifier：<ul>
<li>通过一个Transport对象发送notification通知消息。</li>
<li>在实例化Notifier对象时，需要传入一个Transport对象，一个发布者的ID以及一个Notification的Driver对象。</li>
<li>Notifier类似于上一节中RPC调用的客户端调用；与普通RPC调用同理，在使用Notifier对象发送消息时，也需要调用其prepare()方法创建一个上下文环境。但其发送具体消息时，则调用了_notify(ctxt, event_type, payload, priority, publisher_id&#x3D;None, retry&#x3D;None)方法；该方法主要调用了Notification的Driver对象的notify()方法实现消息发送。在具体使用时，定义了不同的方法表示不同优先级的方法，目前oslo.messaging定义的Notification消息优先级有：audit、debug、info、warn、error、critical、sample等。另外，oslo.messaging还实现了一种在请求中发送消息的机制RequestNotifier类，该类可以将发送请求和返回响应的消息发送到对应的监听器上。</li>
</ul>
</li>
<li>Driver：<ul>
<li>通过消息将Notification通知发送到对应的监听器上</li>
<li>其主要的实现包括MessagingDriver、MessagingV2Driver类，它们分别使用v1格式、v2格式的消息发送通知。Driver对象将阻塞Notifier对象所在的线程，直到消息通过Transport对象传输完成；但其并不能保证对应的监听器会消费该通知消息。另外，需要注意的是同样的Notification通知消息只能发送一次。</li>
<li>主要实现了notify()方法实现具体的消息传输，即调用Transport对象的_send_notification()方法发送通知。Notification中的Driver除了上述两种实现外，还包括：通过Python日志框架发送通知的LogDriver，空操作（即notify()方法为空，即不传输该通知）的NoopDriver，用于缓存测试数据通知的TestDriver以及使用路由方式实现的RoutingDriver等。</li>
</ul>
</li>
<li>Dispatcher类：同样的，Notification机制的RPC调用也定义了其自身的分发机制NotificationDispatcher和BatchNotificationDispatcher类，将通知分发到对应的endpoint方法中。其实现与RPC调用的Dispatcher实现类似，在此不再赘述。其中BatchNotificationDispatcher用于批量消息的分发。</li>
<li>Listener类：Notification机制中的Listener的作用即是普通RPC调用中服务端Server的作用，其实现也是类似的。Notification中定义了NotificationServer、BatchNotificationServer类来实现消息的监听与分发处理操作等。其中BatchNotificationServer类多用于处理批量的消息。</li>
<li>NotificationFilter类：该类主要用在Dispatcher类中对消息进行过滤。一般地，在NotificationDispatcher和BatchNotificationDispatcher类的dispatch()方法中，通过调用NotificationFilter对象的match()方法对消息的上下文信息context、发布者的publish_id、事件类型event_type、元数据metadata以及载荷payload等对消息进行过滤，从而使得监听器只处理监听器监听的消息。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="oslo-middleware"><a href="#oslo-middleware" class="headerlink" title="oslo.middleware"></a>oslo.middleware</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Bill_Xiang_/article/details/78552271">https://blog.csdn.net/Bill_Xiang_/article/details/78552271</a></p>
<p>oslo.middleware库可以添加在WSGI pipeline用来拦截request&#x2F;response请求。其基类可以为WSGI增强功能，如添加、删除、修改HTTP头部信息，支持限制大小和连接数等。</p>
<p>在需要使用oslo.middleware中的pipeline时，OpenStack各组件只需要在相应服务的WSGI配置文件(api-paste.ini)中添加一个对应的filter</p>
<hr>
<h3 id="oslo-policy"><a href="#oslo-policy" class="headerlink" title="oslo.policy"></a>oslo.policy</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Bill_Xiang_/article/details/78665544">https://blog.csdn.net/Bill_Xiang_/article/details/78665544</a></p>
<p>为所有OpenStack服务提供RBAC策略实施支持</p>
<hr>
<h3 id="oslo-serialization"><a href="#oslo-serialization" class="headerlink" title="oslo.serialization"></a>oslo.serialization</h3><p>为OpenStack其他组件提供序列化支持</p>
<p>如：Base64、JSON、MassagePack</p>
<ul>
<li>oslo_serialization.jsonutils<ul>
<li>dumps(obj, default&#x3D;to_primitive, **kwargs)：将一个对象obj序列化为JSON格式的字符串。</li>
<li>dump_as_bytes(obj, default&#x3D;to_primitive, encoding&#x3D;’utf-8’, **kwargs)：将一个对象obj序列化为JSON格式的byte数组。</li>
<li>dump(obj, fp, *args, **kwargs)：将一个对象obj序列化为JSON格式的流fp。</li>
<li>loads(s, encoding&#x3D;’utf-8’, **kwargs)：将JSON格式的字符串或字符数组s进行反序列化。</li>
<li>load(fp, encoding&#x3D;’utf-8’, **kwargs)：将JSON格式的流fp反序列化。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="oslo-service"><a href="#oslo-service" class="headerlink" title="oslo.service"></a>oslo.service</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Bill_Xiang_/article/details/78492967">https://blog.csdn.net/Bill_Xiang_/article/details/78492967</a></p>
<p>oslo.service为OpenStack各组件提供了一个定义新的长运行服务的框架；包括带有SSL和WSGI，周期性操作，结合systemd等的长运行应用。</p>
<p>这个模块的核心是Service类和Launcher类</p>
<ul>
<li><p>Service类有一套生命周期方法，其构造方法会创建一个线程组（就是eventlet的GreenPool）</p>
</li>
<li><p>Launcher类主要用来启动一个或多个服务并等待完成，有一套能管理其负责的S所有Service的生命周期的方法</p>
<p>它的launch_service方法接受一个service以及workers参数(workers是子进程的数目)，这两个参数warp在一起之后调用_start_child启动多个子线程（其实调用到os.fork()）</p>
</li>
</ul>
<hr>
<h3 id="oslo-utils"><a href="#oslo-utils" class="headerlink" title="oslo.utils"></a>oslo.utils</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Bill_Xiang_/article/details/78402660">https://blog.csdn.net/Bill_Xiang_/article/details/78402660</a></p>
<p>一些简化操作的工具类</p>
<hr>
<h3 id="pbr"><a href="#pbr" class="headerlink" title="pbr"></a>pbr</h3><p>pbr库是一个使用统一方式管理setuptools包的库。pbr库通过一个setup钩子函数读取并过滤setup.cfg中的数据，以填充默认值并提供更多合理的操作；然后将结果作为参数返回给setup.py。之后再由setuptools处理python包安装的具体工作。</p>
<p>使用简述：有一个setup.cfg，然后写一个setup.py，这个<code>setuptools.setup()</code>就会调用pbr.pbr()获取setup.cfg的配置参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> setuptools</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> multiprocessing  <span class="comment"># noqa</span></span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line">setuptools.setup(</span><br><span class="line">    setup_requires=[<span class="string">&#x27;pbr&gt;=2.0.0&#x27;</span>],</span><br><span class="line">    pbr=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="taskflow"><a href="#taskflow" class="headerlink" title="taskflow"></a>taskflow</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Bill_Xiang_/article/details/78764561">https://blog.csdn.net/Bill_Xiang_/article/details/78764561</a></p>
<p>实现一个高可用，易理解，声明式的执行工作、任务、流等的库</p>
<p>基本概念</p>
<ul>
<li>Atom：抽象类，taskflow中的最小单位</li>
<li>Task：继承自Atom类，表示一个任务流中的某一个任务</li>
<li>Flow：抽象类，关联所有相关Task的类，规定它们的执行和回滚顺序</li>
<li>Retry：继承自Atom，定义出错重试的操作</li>
<li>Engine：抽象类，载入Flow，驱动Flow的Task</li>
</ul>
<p>Flow类型</p>
<ul>
<li>linear_flow：按照Task&#x2F;Flow加入的顺序来依次执行，按照加入的倒序依次回滚</li>
<li>graph_flow：会按照给加入的Task&#x2F;Flow显式指定的依赖关系或通过其间的provides&#x2F;requires属性隐含的依赖关系执行和回滚</li>
<li>unordered_flow：会按照任意顺序执行或回滚</li>
</ul>
<p>使用简述：定义Task，定义Flow， 用Flow.add()添加ask，获取一个Engine，用Engine.run()执行</p>
<hr>
<h3 id="stevedore"><a href="#stevedore" class="headerlink" title="stevedore"></a>stevedore</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Bill_Xiang_/article/details/78852717">https://blog.csdn.net/Bill_Xiang_/article/details/78852717</a></p>
<p>提供动态加载功能，它基于setuptools的entry points来定义和加载扩展插件，提供了manager类来实现动态加载扩展插件的通用模式。</p>
<p>实现无关紧要</p>
<hr>
<h2 id="OpenStack-Swift组件"><a href="#OpenStack-Swift组件" class="headerlink" title="OpenStack Swift组件"></a>OpenStack Swift组件</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fang888/p/9014645.html">https://www.cnblogs.com/fang888/p/9014645.html</a></p>
<p>这个组件好像作为对象存储被Nvidia采用了，还成立了一个叫swiftstack的公司</p>
<hr>
<h2 id="Python相关"><a href="#Python相关" class="headerlink" title="Python相关"></a>Python相关</h2><h3 id="Python的装饰器"><a href="#Python的装饰器" class="headerlink" title="Python的装饰器"></a>Python的装饰器</h3><p>一个函数A,能够接收其他函数输入，然后函数A能够在执行输入的函数时自己加一些东西。为了简化语法，Python可以在需要被装饰的函数的名字前加入一个@A，那么这个函数就被A装饰了</p>
<hr>
<h3 id="all-的用法"><a href="#all-的用法" class="headerlink" title="__all__的用法"></a><code>__all__</code>的用法</h3><p>当我们向文件导入某个模块时，导入的是该模块中那些名称不以下划线（单下划线“_”或者双下划线“__”）开头的变量、函数和类。因此，如果我们不想模块文件中的某个成员被引入到其它文件中使用，可以在其名称前添加下划线</p>
<p>此外，当其它文件以<code>from 模块名 import *</code>的形式导入该模块时，该文件中只能使用 <code>__all__</code> 列表中指定的成员</p>
<hr>
<h3 id="name"><a href="#name" class="headerlink" title="__name__"></a><code>__name__</code></h3><p>表示程序名称</p>
<p>自己的 <code>__name__ </code>在自己用时就是 main，当自己作为模块被调用时就是自己的名字</p>
<hr>
<h3 id="metaclass"><a href="#metaclass" class="headerlink" title="metaclass"></a>metaclass</h3><p>元类，看openstack PeriodcTasks的代码时接触到</p>
<p>type</p>
<p>所有的用户定义的类都是type这个类的实例</p>
<p>定义类时其实是type类的<code>__call__</code>运算符重载</p>
<p>简单来说，当你定义一个类时，写成下面这样时：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    data = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>Python 真正执行的是下面这段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> = <span class="built_in">type</span>(classname, superclasses, attributedict)</span><br></pre></td></tr></table></figure>

<p>它会进一步调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span>.__new__(typeclass, classname, superclasses, attributedict)</span><br><span class="line"><span class="built_in">type</span>.__init__(<span class="keyword">class</span>, classname, superclasses, attributedict)</span><br></pre></td></tr></table></figure>

<p>metaclass是type的子类，可以重载<code>__call__</code>运算符，比如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mymeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(metaclass=Mymeta):</span><br><span class="line"><span class="comment">#本来Foo这个定义应该是执行下面这一句</span></span><br><span class="line"><span class="keyword">class</span> = <span class="built_in">type</span>(classname, superclasses, attributedict) </span><br><span class="line"><span class="comment">#但是变为了</span></span><br><span class="line"><span class="keyword">class</span> = Mymeta(classname, superclasses, attributedict)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="eventlet库"><a href="#eventlet库" class="headerlink" title="eventlet库"></a>eventlet库</h3><p><a target="_blank" rel="noopener" href="https://eventlet.net/doc/basic_usage.html">https://eventlet.net/doc/basic_usage.html</a></p>
<p>一个具有WSGI支持的异步框架</p>
<p>基于绿色线程，调度需要在代码中显式yield，而不是抢占式</p>
<p>绿色线程(green thread)：与操作系统线程(native thread)相对，是在用户控件实现的线程系统</p>
<p>api看官网吧</p>
<p>spawn(func, *args, **kw)，创建一个绿色线程执行func，返回一个GreenThread，用以获取返回值</p>
<hr>
<h3 id="SQLAlchemy"><a href="#SQLAlchemy" class="headerlink" title="SQLAlchemy"></a>SQLAlchemy</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/pycode/p/mysql-orm.html">https://www.cnblogs.com/pycode/p/mysql-orm.html</a></p>
<p>SQLAlchemy是Python编程语言下的一款ORM框架</p>
<p>该框架建立在DBAPI之上，使用关系对象映射进行数据库操作。简言之便是：将对象转换成SQL，然后使用数据API执行SQL并获取执行结果。它本身不能操作数据库，需要借助DBAPI插件，如pymysql。</p>
<hr>
<h3 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h3><p>语法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> context <span class="keyword">as</span> var:</span><br><span class="line">    with_suite</span><br></pre></td></tr></table></figure>

<p>代替try..except…finally</p>
<p>context通常是表达式，能返回一个带有<code>__enter__()</code>和<code>__exit__()</code>方法的对象，比如文件对象。</p>
<p><code>__enter__()</code>方法调用的返回值赋给var</p>
<p><code>__exit__()</code>会在context抛出异常时执行，可以在这个方法里面写清理环境的逻辑</p>
<hr>
<h3 id="setuptools"><a href="#setuptools" class="headerlink" title="setuptools"></a>setuptools</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ea9973091fdf">https://www.jianshu.com/p/ea9973091fdf</a></p>
<p>在python中安装包可以通过</p>
<ol>
<li>源码安装：python setup.py install</li>
<li>在线安装: pip install 包名 &#x2F; easy_install 包名</li>
</ol>
<p>源码安装的时候，需要一个setup.py，执行install之后会产生egg-info以及dist&#x2F;egg</p>
<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">demo</span><br><span class="line">|-- build</span><br><span class="line">|   `-- bdist.linux-x86_64</span><br><span class="line">|-- demo.egg-info</span><br><span class="line">|   |-- dependency_links.txt</span><br><span class="line">|   |-- PKG-INFO</span><br><span class="line">|   |-- SOURCES.txt</span><br><span class="line">|   `-- top_level.txt</span><br><span class="line">|-- dist</span><br><span class="line">|   `-- demo-0.1-py2.7.egg</span><br><span class="line">`-- setup.py</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>用abc模块</p>
<hr>
<h3 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pip install virtualenv</span><br><span class="line">virtualenv test_venv</span><br><span class="line">cd test_venv/Scripts</span><br><span class="line">activate #激活环境</span><br><span class="line">deactivate #关闭环境</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除虚拟环境可直接删除文件夹</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">此外还有一个更好用的封装库</span></span><br><span class="line">pip install virtualenvwrapper</span><br><span class="line">mkvirtualenv</span><br><span class="line">rmvirtualenv</span><br></pre></td></tr></table></figure>



<hr>
<p>YAML</p>
<p>数据序列化语言，可以用来序列化和反序列化数据</p>
<hr>
<h2 id="Linux相关"><a href="#Linux相关" class="headerlink" title="Linux相关"></a>Linux相关</h2><p>经典作死操作：<code>rm -rf /*</code>，<code>sudo chmod 777 -R /etc/</code></p>
<hr>
<p>su命令和su -命令最大的本质区别就是：前者只是切换了root身份，但Shell环境仍然是普通用户的Shell；而后者连用户和Shell环境一起切换成root身份了。只有切换了Shell环境才不会出现PATH环境变量错误。</p>
<hr>
<h3 id="常用位置"><a href="#常用位置" class="headerlink" title="常用位置"></a>常用位置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">service的位置</span></span><br><span class="line">/usr/lib/systemd/system/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">20.04网卡的位置，以及修改方式</span></span><br><span class="line">ls /etc/netplan/</span><br><span class="line">sudo vim /etc/netplan/xxx.yaml</span><br><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="命令行执行多个命令"><a href="#命令行执行多个命令" class="headerlink" title="命令行执行多个命令"></a>命令行执行多个命令</h3><ul>
<li><code>; </code>分号隔开，表示命令无论成功执行与否，都要执行**</li>
<li><code>&amp;&amp;</code> 符号隔开，表示依次执行命令，有一个失败，则退出执行，类似于循环中的break</li>
<li><code>||</code> 符号隔开，表示 依次执行命令，只要有一个执行成功，则退出执行</li>
</ul>
<hr>
<h3 id="dd命令"><a href="#dd命令" class="headerlink" title="dd命令"></a>dd命令</h3><p>convert and copy a file</p>
<h3 id="xxd命令"><a href="#xxd命令" class="headerlink" title="xxd命令"></a>xxd命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看文件的16进制形式</span></span><br><span class="line">xxd -u -a -g 1 -c 16 -l 80 文件名</span><br></pre></td></tr></table></figure>

<h3 id="sync命令"><a href="#sync命令" class="headerlink" title="sync命令"></a>sync命令</h3><p>把任何在内存中缓冲的数据写到磁盘上。这能包括（但不仅限于）修改了的超级块， i 节点，和延迟的读写</p>
<hr>
<h3 id="du命令"><a href="#du命令" class="headerlink" title="du命令"></a>du命令</h3><p>查看磁盘空间占用情况</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -sh /</span><br></pre></td></tr></table></figure>

<p>有时候du和df显示的结果会不一致，很有可能是因为删除的文件还在被某一个进程持有。du是看文件系统的，删除后目录不可见，但是由于仍有进程持有句柄，这个文件不会被真正删除，可以通过<code>lsof</code>命令查找被标注为<code>deleted</code>的文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lsof | grep -i deleted</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">z：压缩gzip</span><br><span class="line">c: 创建文档</span><br><span class="line">x：提取存档</span><br><span class="line">f：filename 要操作的文档名</span><br><span class="line">v：详细信息</span><br><span class="line">t：列出存档内容</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">压缩打包</span></span><br><span class="line">tar zcf a.tar.gz 文件名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压</span></span><br><span class="line">tar xf a.tar.gz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出内容</span></span><br><span class="line">tar tf a.tar</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="硬中断和软中断"><a href="#硬中断和软中断" class="headerlink" title="硬中断和软中断"></a>硬中断和软中断</h3><p><strong>硬中断</strong>：由与系统相连的外设(比如网卡、硬盘)自动产生的。主要是用来通知操作系统系统外设状态的变化。比如当网卡收到数据包的时候，就会发出一个中断。我们通常所说的中断指的是硬中断(hardirq)。</p>
<p><strong>软中断</strong>：为满足实时系统需求，中断处理应该是越快越好。linux为了实现这个特点，当中断发生的时候，硬中断处理那些短时间就可以完成的工作，而将那些处理事件比较长的工作，放到中断之后来完成，也就是软中断(softirq)来完成。</p>
<p><strong>中断嵌套</strong>：Linux下硬中断是可以嵌套的，但是没有优先级的概念，也就是说任何一个新的中断都可以打断正在执行的中断，但同种中断除外。而软中断不能嵌套，但相同类型的软中断可以在不同CPU上并行执行。</p>
<p><strong>软中断指令</strong>：int n指令会触发软中断n。相应的中断处理函数的地址为：中断向量表地址 + 4 * n。</p>
<hr>
<h3 id="linux文件系统"><a href="#linux文件系统" class="headerlink" title="linux文件系统"></a>linux文件系统</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jinking01/article/details/90669534">参考链接1</a> <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38971487/article/details/91492832">参考链接2</a></p>
<ul>
<li>层次：用户→库函数→系统调用→VFS API→具体文件系统的API实现</li>
<li>linux使用POSIX标准的API</li>
<li>VFS支持的系统可分为三类：disk-based FS、network FS、特殊FS</li>
<li>统一文件模型(common file model)的四个基本概念<ul>
<li>superblock：存储文件系统基本的metadata</li>
<li>index node(inode)：存储一个文件或目录相关的metadata(<strong>不包括这个文件的名称</strong>)(具体可以<code>man 7 inode</code>查看定义)</li>
<li>directory entry(dentry)：存储了对应关系&lt;文件(目录)名, 对应inode&gt;，同时可以实现目录与其包含的文件之间的映射关系。另外也作为缓存的对象，缓存最近最常访问的文件或目录</li>
<li>file：一个进程打开一个具体文件之后在内核创建的一个内存数据结构</li>
</ul>
</li>
<li>文件描述符：每个打开的文件对用户来说有一个文件描述符，fd是一个整数，是该进程的fd表中的一个下标。fd表中的每一项都包含一个指向file结构体的指针</li>
<li>也就是VFS抽象的file object。file object指向一个dentry</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看操作系统内核支持哪些文件系统，输出结果第一列的nodev表明文件系统不需要挂载在块设备上</span></span><br><span class="line">cat /proc/filesystems</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看已挂载的文件系统</span></span><br><span class="line">mount</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出：cgroup on /sys/fs/cgroup/systemd <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出含义</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">fs_spec on fs_file <span class="built_in">type</span> fs_vfstype (fs_mntopts)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">fs_spec：挂载的块设备或远程文件系统</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">fs_file：挂载点</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">fs_vfstype：文件系统的类型</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">fs_mntopts：与文件系统相关的更多选项，不同的文件系统其选项也不太一样</span></span><br></pre></td></tr></table></figure>

<ul>
<li>所以文件在一棵根为<code>/</code>的树中，一开始设备只是一个文件，不在目录树中。使用mount可以将一个设备（通常是存储设备）挂接到一个已存在的目录上。例子：新增硬盘一开始只是一个分区文件(比如：<code>/dev/sda</code>)，通过<code>mount  /dev/sda ~/newDir</code>可以把分区sda挂载到<code>~/newDir</code>目录上，具体使用见man手册</li>
<li>每一个 mount 的文件系统，都由一个 <code>vfsmount </code>实例来表示</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hiyun9/article/details/51967742">proc目录下常见文件的含义</a></p>
<hr>
<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/149346441">https://zhuanlan.zhihu.com/p/149346441</a></p>
<p><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/make.html#Reading">https://www.gnu.org/software/make/manual/make.html#Reading</a></p>
<p>切记，缩进敏感，而且需要是tab而不是4个空格</p>
<p>规则</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">target... : prerequisites...</span><br><span class="line">	command</span><br><span class="line"><span class="comment"># target也就是一个目标文件，可以是Object File，也可以是执行文件,还可以是一个标签</span></span><br><span class="line"><span class="comment"># prerequisites就是，要生成那个target所需要的文件或是目标。</span></span><br><span class="line"><span class="comment"># command也就是make需要执行的命令。（任意的Shell命令）</span></span><br></pre></td></tr></table></figure>

<p>工作方式</p>
<p>在默认的方式下，也就是我们只输入make命令：</p>
<ol>
<li>make会在当前目录下找名字叫“Makefile”或“makefile”的文件。</li>
<li>如果找到，它会找文件中的第一个target并把这个文件作为最终的目标文件。</li>
<li>如果target不存在，或是target所依赖的后面的 .o 文件的修改时间要比target新，那么，他就会执行command来生成target</li>
<li>如果target的依赖不存在，那么make会在当前文件中找依赖。</li>
<li>都编译好之后就开始连接</li>
</ol>
<p>简单的例子</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Makefile (井号为注释)</span></span><br><span class="line"><span class="comment"># 其中 all 、clean的术语为 target</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">        g++ -o hello main.cpp function1.cpp function2.cpp</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm -rf *.o hello</span><br></pre></td></tr></table></figure>

<p>输入make默认执行第一个target，如果要执行clean这个target，需要输入命令make clean</p>
<hr>
<h2 id="算法题小技巧"><a href="#算法题小技巧" class="headerlink" title="算法题小技巧"></a>算法题小技巧</h2><h3 id="递归Debug技巧"><a href="#递归Debug技巧" class="headerlink" title="递归Debug技巧"></a>递归Debug技巧</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247490945&idx=1&sn=03da23d366ad4577d2a22328f3ba04f9&chksm=9bd7e389aca06a9f791a442a58b27c4f076d0880003e28d6533cb50e812327d92db3faf4fb5f&mpshare=1&scene=23&srcid=0127Qz2HxCrfB4AkwaJPKJjv">地址</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归函数Debug的技巧</span></span><br><span class="line"><span class="comment">//在进入前count++打印</span></span><br><span class="line"><span class="comment">//在return前--count打印</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printIndent</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(string&amp; ring, <span class="type">int</span> i, string&amp; key, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// printIndent(count++);</span></span><br><span class="line">    <span class="comment">// printf(&quot;i = %d, j = %d\n&quot;, i, j);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j == key.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// printIndent(--count);</span></span><br><span class="line">        <span class="comment">// printf(&quot;return 0\n&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k : charToIndex[key[j]]) &#123;</span><br><span class="line">        res = <span class="built_in">min</span>(res, <span class="built_in">dp</span>(ring, j, key, i + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printIndent(--count);</span></span><br><span class="line">    <span class="comment">// printf(&quot;return %d\n&quot;, res);</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="问题规模："><a href="#问题规模：" class="headerlink" title="问题规模："></a>问题规模：</h3><p>$$<br>10^7&#x2F;1000ms<br>$$</p>
<p>一般是一秒千万次运算。所以对于输入规模，常见的时间复杂度要求如下：<br>$$<br>O(n!)要求n&lt;&#x3D;11\<br>O(2^n)要求n&lt;&#x3D;25\<br>O(n^2)要求n&lt;&#x3D;5000或2500或常见的1000\<br>O(nlogn)要求n&lt;&#x3D;10^5\<br>O(n)要求n&lt;&#x3D;10^7(也就是千万级)\<br>n&gt;&#x3D;10^8就只能用O(logn)了<br>$$</p>
<h3 id="低级错误"><a href="#低级错误" class="headerlink" title="低级错误"></a>低级错误</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n&amp;&amp;i!=j; i++)</span><br><span class="line"><span class="comment">//这不是跳过对角线，而是对角线之后的都不能遍历到</span></span><br></pre></td></tr></table></figure>

<h3 id="多源最短路径"><a href="#多源最短路径" class="headerlink" title="多源最短路径"></a>多源最短路径</h3><p>Floyd算法</p>
<p>核心代码，一个三重循环，但是要注意溢出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; k&lt;=n; k++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[i][k]!=Integer.MAX_VALUE &amp;&amp; dist[k][j]!=Integer.MAX_VALUE &amp;&amp; dist[i][j]&gt;dist[i][k]+dist[k][j])</span><br><span class="line">                dist[i][j]=dist[i][k]+dist[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="VS-code调试"><a href="#VS-code调试" class="headerlink" title="VS code调试"></a>VS code调试</h3><p>发生找不到主类的错误时，请不要打开workspace或add to workspace，直接打开文件夹就是了</p>
<hr>
<h2 id="读代码"><a href="#读代码" class="headerlink" title="读代码"></a>读代码</h2><ul>
<li><p>make rdm_run</p>
</li>
<li><p>运行<code>fenrir-rmd.py</code></p>
</li>
<li><p>运行<code>rdm.main()</code></p>
<ul>
<li><p>整了一个LOG还有CONF</p>
<ul>
<li><p>CONF经过fenrir&#x2F;conf模块下的注册好初始参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[api]</span><br><span class="line">port=10010</span><br><span class="line">host=127.0.0.1</span><br><span class="line">workers=3</span><br><span class="line">enable_ssl_api=False</span><br><span class="line"></span><br><span class="line">[fenrir_realtime_decision_maker]</span><br><span class="line">conductor_topic=fenrir.rdm.control</span><br><span class="line">notification_topics=[&#x27;nova.versioned_notifications&#x27;,</span><br><span class="line">                         &#x27;fenrir.fenrir_notifications&#x27;]</span><br><span class="line">publisher_id=fenrir.rdm.api</span><br><span class="line">max_workers=2</span><br><span class="line"></span><br><span class="line">[DEFAULT]</span><br><span class="line">periodic_interval=60</span><br><span class="line">pybasedir</span><br><span class="line">bindir</span><br><span class="line">state_path</span><br><span class="line"></span><br><span class="line">[database]</span><br><span class="line">mysql_engine=mysql_engine</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>prepare_service()</p>
<ul>
<li>根据命令行传入的conf路径再注册一些参数</li>
<li>设置消息队列exchange名为fenrir</li>
</ul>
</li>
<li><p>Service(manager.RDMManager)</p>
<ul>
<li>关于Manager的conductor_endpoints，目前在&#x2F;messaging模块下有两个endpoint——test_endpoint以及eventprocessor_endpoint，其中test_endpoint有一个the_test_func</li>
<li>conductor_topic_handler是一个RPCServer</li>
<li>notification_handler是一个notification_listener</li>
</ul>
</li>
<li><p>launch()</p>
</li>
<li><p>wait()</p>
</li>
</ul>
</li>
<li><p>make rdm_rpc_test_run</p>
<ul>
<li>prepare_service()</li>
<li>rdm_api.RealtimeDecisionMakerAPI()<strong>获取一个RPCClient？不，得到的是一个RDMAPI而不是client</strong></li>
<li>RDMAPI.call_test<ul>
<li>调用conductor_client.call()，conductor_client才是一个RPCClient</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="CAP原则"><a href="#CAP原则" class="headerlink" title="CAP原则"></a>CAP原则</h2><p>分布式系统的概念</p>
<ul>
<li><p>一致性（<strong>C</strong>onsistency）</p>
<p>在分布式系统完成某写操作后任何读操作，都应该获取到该写操作写入的那个最新的值。相当于要求分布式系统中的各节点时时刻刻保持数据的一致性。</p>
</li>
<li><p>可用性（<strong>A</strong>vailability）</p>
<p>一直可以正常的做读写操作。简单而言就是客户端一直可以正常访问并得到系统的正常响应。用户角度来看就是不会出现系统操作失败或者访问超时等问题。</p>
</li>
<li><p>分区容错性（<strong>P</strong>artition tolerance）</p>
<p>指的分布式系统中的某个节点或者网络分区出现了故障的时候，整个系统仍然能对外提供满足一致性和可用性的服务。也就是说部分故障不影响整体使用。</p>
</li>
</ul>
<p>CAP原则说的就是<strong>这三者只能最多同时实现两点，不可能三者兼顾</strong></p>
<p>那么就有以下的情况</p>
<ul>
<li><p>CA: 优先保证一致性和可用性，放弃分区容错。 这也意味着放弃系统的扩展性，系统不再是分布式的，有违设计的初衷。</p>
</li>
<li><p>CP: 优先保证一致性和分区容错性，放弃可用性。在数据一致性要求比较高的场合(譬如:zookeeper,Hbase) 是比较常见的做法，一旦发生网络故障或者消息丢失，就会牺牲用户体验，等恢复之后用户才逐渐能访问。</p>
</li>
<li><p>AP: 优先保证可用性和分区容错性，放弃一致性。NoSQL中的Cassandra 就是这种架构。跟CP一样，放弃一致性不是说一致性就不保证了，而是逐渐的变得一致。</p>
</li>
</ul>
<p>取舍例子：</p>
<p>​	比如你是一个文件上传的服务器，用户可能上传几个g的文件，那么如果用一个AP的系统，拿到的可能是不可用的节点，这样返回给客户端重试，客户端肯定得疯掉，这时候就需要用CP。而像 rpc 调用，调用失败了重试就好，成本代价都不大，这时候，用AP可能会更合适。</p>
<hr>
<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><p>一个开源的分布式应用程序协调服务</p>
<p>开发语言：java</p>
<p>提供Java和C的接口</p>
<p>是CAP原则中的满足CP的分布式系统</p>
<p><strong>谁能把这个数据同步的时间压缩的更短，谁的请求响应就更快，谁就更出色，Zookeeper就是其中的佼佼者</strong></p>
<h3 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h3><p>非常类似于标准文件系统，key-value 的形式存储。名称 key 是由斜线 <strong>&#x2F;</strong> 分割的路径。zookeeper 名称空间中的每个节点都是通过一个路径标识。</p>
<hr>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p>一个基于 ZooKeeper协调的分布式消息系统</p>
<p>用Scala和Java编写</p>
<hr>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li><p>消息系统： Kafka 和传统的消息系统（也称作消息中间件〉都具备系统解稿、冗余存储、流量削峰、缓冲、异步通信、扩展性、 可恢复性等功能。与此同时， Kafka 还提供了大多数消息系统难以实现的消息顺序性保障及回溯消费的功能 </p>
</li>
<li><p>存储系统： Kafka 把消息持久化到磁盘，相比于其他基于内存存储的系统而言，有效地降低了数据丢失的风险 。 也正是得益于 Kafka 的消息持久化功能和多副本机制，我们可以把 Kafka 作为长期的数据存储系统来使用，只需要把对应的数据保留策略设置为“永久”或启用主题的日志压缩功能即可 </p>
</li>
<li><p>流式处理平台： Kafka 不仅为每个流行的流式处理框架提供了可靠的数据来源，还提供了一个完整的流式处理类库，比如窗口、连接、变换和聚合等各类操作</p>
</li>
</ul>
<hr>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li>Producer ： 生产者，也就是发送消息的一方。生产者负责创建消息 ， 然后将其投递到Kafka 中 。</li>
<li>Consumer：消费者，也就是接收消息的一方。消费者连接到 Kafka 上并接收消息，进而进行相应的业务逻辑处理 。</li>
<li>Consumer Group：一个消费者只能在一个组中，不同组对消息的消费互相独立</li>
<li>Broker：服务代理节点。对于 Kafka 而言， Broker 可以简单地看作一个独立的 Kafka服务节点或 Kafka 服务实例。  </li>
<li>Topic：消息按照主题分类</li>
<li>Partition：一个分区只属于一个主题，一个主题的不同分区有不同消息。存储层面上看，一个分区是一个可追加的log，每条消息追加到Log时有一个特定的offset作为消息在分区中的唯一标识。分区可以在不同的broker上，这使得能够让主题横跨多个broker</li>
<li>kafka保证分区有序而不是主题有序</li>
</ul>
<hr>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>分区有多个副本，用leader&amp;follower模式</p>
<p>不是完全的同步复制（要求所有follower都复制完才认为消息成功提交），也不是单纯的异步复制</p>
<p>kafka的这个机制名字叫 ISR，这种设计可以避免高时延的follower副本影响整个集群的性能</p>
<ol>
<li>leader会维护一个与其基本保持同步的Replica列表，该列表称为ISR(in-sync Replica)，每个Partition都会有一个ISR，而且是由leader动态维护</li>
<li>如果一个follower比一个leader落后太多(通过log的offset裁定)，或者超过一定时间未发起数据复制请求，则leader将其重ISR中移除</li>
<li>当ISR中所有Replica都向Leader发送ACK时，leader才commit</li>
</ol>
<ul>
<li><p>ps.副本复制实际上是通过如下流程实现：</p>
<ol>
<li><p>生产者向一个partition推送消息</p>
</li>
<li><p>该分区Leader Replica把消息追加到log中并递增该副本的LEO(log end offset指向追加到当前副本的最后一个消息的offeset)</p>
</li>
<li><p>Follower副本从Leader副本拉取消息进行同步</p>
</li>
<li><p>Follower副本将拉取到的消息更新到本地log中并递增LEO</p>
</li>
<li><p>当ISR集合中所有副本都完成新消息的同步，Leader副本递增其HW(高水位：消费者消费消息时只能拉取到HW前的消息)</p>
</li>
</ol>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37502106/article/details/80271800">参考链接</a></p>
<hr>
<h3 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h3><p>Key 值相同的数据，压缩后只记录同 Key 值最新的一条数据</p>
<p>Key 不为空，Value 为空的消息，这种消息在日志压缩过程中会被设置为墓碑消息</p>
<hr>
<h3 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动kafka</span></span><br><span class="line">sudo ./kafka-server-start.sh ../config/server.properties</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭kafka</span></span><br><span class="line">sudo ./kafka-server-stop.sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动控制台消费者脚本</span></span><br><span class="line">./kafka-console-consumer.sh --bootstrap-server 192.168.88.128:9092 --topic topic-demo</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>参考《Apache Kafka源码剖析》</p>
<hr>
<h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><ul>
<li><p>KafkaProducer是线程安全的，多个线程可以共享使用同一个KafkaProducer</p>
</li>
<li><p>发送消息的两种方式：同步发送、异步发送，底层都是异步，同步只是调用了futrue.get()</p>
</li>
<li><p>分为主线程和 Sender 线程  </p>
</li>
<li><p>发送消息流程</p>
</li>
</ul>
<ol>
<li><code>KafkaProducer</code>调用<code>ProducerInterceptors</code>拦截消息</li>
<li><code>Serializer</code>对消息的key和value进行序列化</li>
<li><code>Partitioner</code>为消息选择合适的分区</li>
<li><code>RecordAccumulator</code>收集消息，实现批量发送</li>
<li><code>Sender</code>从<code>RecordAccumulator</code>获取消息</li>
<li>构造<code>ClientRequest</code></li>
<li>将<code>ClientRequest</code>交给<code>NetworkClient</code>，准备发送</li>
<li><code>NetworkClient</code>将请求放入<code>KafkaChannel</code>的缓存</li>
<li>执行网络I&#x2F;O，发送请求</li>
<li>收到回应，调用一堆回调函数</li>
</ol>
<ul>
<li><p>元数据</p>
<ul>
<li>由于创建消息后只知道主题的名称，对于其他一些必要的信息却一无所知 。<code>KafkaProducer</code>要将此消息追加到指定主题的某个分区所对应的 leader 副本之前还需要知道集群的信息。因此需要有元数据来记录集群信息（诸如集群有哪些节点，有哪些主题，主题在什么分区等），这些信息可以用集合或者Map映射描述。</li>
<li>源码的<code>Metadata</code>类以及<code>Cluster</code>类有具体实现。至于元数据的更新会用到监听器，主线程在发现需要更新元数据时通过wait&#x2F;notify线程通信通知<code>Sender</code>线程完成更新数据的操作。</li>
</ul>
</li>
<li><p><code>Partitioner</code>默认会这样进行负载均衡：如果消息没有key，就用counter%分区个数，保证消息均匀分布到各个分区。如果有key，就用hash算法计算。</p>
</li>
<li><p><code>RecordAccumulator</code></p>
<ul>
<li><code> KafkaProducer .send()</code>最终会调用<code>RecordAccumulator.append()</code>。</li>
<li>唤醒Sender线程的条件是追加到<code>RecordAccumulator</code>的消息所在的最后一个<code>RecordBatch</code>满了或者队列中不止一个<code>RecordBatch</code>。设计了一个<code>RecordAccumulator.ready()</code>方法实现这个条件检查。</li>
<li>这个类主要包含一个<code>ConcurrentMap&lt;TopicPartition, ArrayDeque&lt;RecordBatch&gt;&gt;</code>的结构，也即不同分区都有一个队列保存批量消息。</li>
<li><code>RecordAccumulator</code>需要至少一个业务线程以及一个Send线程并发，因此实现要保证线程安全。</li>
<li><code>RecordAccumulator</code>的结构记录的是&lt;分区→批量信息&gt;的映射，对于下层负责I&#x2F;O的逻辑而言需要知道的是&lt;节点→批量信息&gt;的映射，因此设计了一个<code>RecordAccumulator.drain()</code>实现这种映射的转换</li>
</ul>
</li>
<li><p><code>Sender</code>线程</p>
<ul>
<li>run方法流程：<ol>
<li>从MetaData获取集群数据Cluster</li>
<li>调用<code>RecordAccumulator。ready()</code>选出可向哪些Node发送消息</li>
<li>检查是否有Node是不知道Leader的，如果有就需要更新集群元数据</li>
<li>对第二步选出的Node再通过<code>NetworkClient</code>筛选出符合发送条件的节点</li>
<li>调用<code>RecordAccumulator.drain()</code></li>
<li>调用<code>RecordAccumulator.abortExpiredBatches()</code>处理超时消息</li>
<li>调用<code>Sender.createProduceRequests()</code>把消息封装为<code>ClientRequest</code></li>
<li>调用<code>NetworkClient.send()</code>将<code>ClientRequest</code>写入<code>KafkaChannel</code>的<code>send</code>字段</li>
<li>调用<code>NetworkClient.poll()</code>将上述<code>ClientRequest</code>发送出去，同时处理服务端回应等</li>
</ol>
</li>
<li>一个Node只生成一个<code>ClientRequest</code>，同节点不同分区的消息在创建<code>ClientRequest</code>时会按节点分类整理到一起</li>
</ul>
</li>
<li><p>NetworkClient</p>
<ul>
<li><code>NetworkClient.ready()</code>检查是否可以向一个Node发请求。需要满足三个条件<ol>
<li>Metadata不处于正在更新或需要更新状态</li>
<li>已成功建立连接且连接正常</li>
<li><code>InFlightRequest.canSendMore()</code>返回true，即说明 已发送但未收到回应的消息数目 还没超过上限</li>
</ol>
</li>
<li><code>NetworkClient.poll()</code>调用<code>KSelector.poll()</code>进行网络I&#x2F;O，这个<code>KSelector</code>又是用的<code>java.nio</code></li>
<li>维护连接的时候使用了LRU</li>
<li>读写数据如果不能完整读写一个NetworkService的话会分多次读写+</li>
</ul>
</li>
</ul>
<hr>
<h3 id="流式处理"><a href="#流式处理" class="headerlink" title="流式处理"></a>流式处理</h3><p>kafka stream</p>
<ul>
<li><p>术语</p>
<ul>
<li><p>时间</p>
<ul>
<li><p>事件时间</p>
<p>事件时间是指事件的发生时间或事件的创建时间，如商品的出售时间，用户的访问时间。在Kakfa 0.10之后的版本，生产者会自动在记录中添加创建时间，如果与业务的事件时间不一致，那就需要手动设置这个时间。</p>
</li>
<li><p>日志追加时间</p>
<p>日志追加时间是指时间保存到kafka broker上的时间。</p>
</li>
<li><p>处理时间</p>
<p>处理时间是指我们的应用在收到事件后对其处理的时间。同一个事件的处理时间可能不同，这取决于不同的应用何时读取这个时间</p>
</li>
</ul>
</li>
<li><p>窗口：有两种，时间窗口和会话窗口。</p>
<p>​	时间窗有两个重要的属性：窗口大小和步长(移动间隔)。</p>
<ul>
<li>滚动窗口：步长等于窗口大小，滚动窗口是没有没有记录的重叠。</li>
<li>跳跃窗口：步长不等于窗口大小</li>
<li>滑动窗口：窗口随着每一条记录移动，滑动窗口不与时间对齐，而是与数据记录时间戳对齐。</li>
<li>会话窗口：会话窗口与时间窗最大的不同是，他的大小是不确定的（因为它的大小是由数据本身决定的）</li>
</ul>
</li>
<li><p>拓扑：一个操作和变换的集合，每个事件从输入到输出都会流经它</p>
</li>
<li><p>流处理器：是处理拓扑中的各个节点，代表拓扑中的每个处理步骤，用来完成数据转换功能，如过滤、映射、分组、聚合等</p>
</li>
</ul>
</li>
<li><p>API</p>
<ul>
<li><p>KStream：数据流抽象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StreamsBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamsBuilder</span>();</span><br><span class="line">KStream&lt;String, Long&gt; wordCounts = builder.stream(</span><br><span class="line">    <span class="string">&quot;word-counts-input-topic&quot;</span>, <span class="comment">// 输入的topic </span></span><br><span class="line">    Consumed.with(Serdes.String(), Serdes.Long())   <span class="comment">//key和value的序列化方式</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
</li>
<li><p>KTable：数据表抽象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">KStream&lt;String, Long&gt; wordCounts = builder.table(</span><br><span class="line"> <span class="string">&quot;word-counts-input-topic&quot;</span>, <span class="comment">// 输入的topic</span></span><br><span class="line"> Consumed.with(Serdes.String(), Serdes.Long(), <span class="comment">//key和value的序列化方式</span></span><br><span class="line"> Materialized.as(<span class="string">&quot;word-counts-store&quot;</span>)    <span class="comment">// 状态存储名</span></span><br><span class="line"> );</span><br></pre></td></tr></table></figure>

<ul>
<li>KStream对于流中的记录始终解释为<strong>insert</strong>（即流记录表示新增），而KTable对流中的记录解释为<strong>upsert</strong>(即流记录表示更新，即表的数据更改)</li>
</ul>
</li>
<li><p>无状态转换</p>
<ul>
<li><p>branch：将一个Kstream分成多个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">KStream&lt;String, Long&gt;[] branches = stream.branch(</span><br><span class="line">    (key, value) -&gt; key.startsWith(<span class="string">&quot;A&quot;</span>), <span class="comment">//branches[0]中只包含key以“A”开头的所有记录</span></span><br><span class="line">    (key, value) -&gt; key.startsWith(<span class="string">&quot;B&quot;</span>), <span class="comment">//branches[1]中只包含key以“B”开头的所有记录</span></span><br><span class="line">    (key, value) -&gt; <span class="literal">true</span>                 <span class="comment">//branches[2]中包含其他记录</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>filter：过滤操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 过滤掉value不大于0的记录</span></span><br><span class="line">KStream&lt;String, Long&gt; onlyPositives = stream.filter((key, value) -&gt; value &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>filterNot：反向过滤，与filter相反</p>
</li>
<li><p>flatMap：将一条记录转换成0条、1条或多条记录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把一条记录转换成了两条记录。如: (345L, &quot;Hello&quot;) -&gt; (&quot;HELLO&quot;, 1000), (&quot;hello&quot;, 9000)</span></span><br><span class="line">KStream&lt;String, Integer&gt; transformed = stream.flatMap((key, value) -&gt; &#123;</span><br><span class="line">      List&lt;KeyValue&lt;String, Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">      result.add(KeyValue.pair(value.toUpperCase(), <span class="number">1000</span>));</span><br><span class="line">      result.add(KeyValue.pair(value.toLowerCase(), <span class="number">9000</span>));</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>flatMapValues：作用和flatMap相同，但是只是对value操作，转换后记录的key同原来的key</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过空格拆分成单个单词</span></span><br><span class="line">KStream&lt;<span class="type">byte</span>[], String&gt; words = sentences.flatMapValues(value -&gt; Arrays.asList(value.split(<span class="string">&quot;\\s+&quot;</span>)));</span><br></pre></td></tr></table></figure>
</li>
<li><p>foreach：循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环打印出每条记录</span></span><br><span class="line">stream.foreach((key, value) -&gt; System.out.println(key + <span class="string">&quot; =&gt; &quot;</span> + value));</span><br></pre></td></tr></table></figure>
</li>
<li><p>groupByKey：根据key分组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KGroupedStream&lt;<span class="type">byte</span>[], String&gt; groupedStream = stream.groupByKey();</span><br></pre></td></tr></table></figure>
</li>
<li><p>GroupBy: 分组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分组，并修改了key和value的类型</span></span><br><span class="line">KGroupedStream&lt;String, String&gt; groupedStream = stream.groupBy(</span><br><span class="line">    (key, value) -&gt; value, Serialized.with(Serdes.String(), Serdes.String())  </span><br><span class="line">);</span><br><span class="line"><span class="comment">// 分组，并生成新的key，并且修改了key和value的类型</span></span><br><span class="line">KGroupedTable&lt;String, Integer&gt; groupedTable = table.groupBy(</span><br><span class="line">    (key, value) -&gt; KeyValue.pair(value, value.length()),</span><br><span class="line">    Serialized.with(Serdes.String(), Serdes.Integer()) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>map：将一条记录转换成另一条记录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KStream&lt;String, Integer&gt; transformed = stream.map(key, value) -&gt; KeyValue.pair(value.toLowerCase(), value.length()));</span><br></pre></td></tr></table></figure>
</li>
<li><p>mapValues：作用同map，但是只是对value操作，转换后记录的key同原来的key</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KStream&lt;<span class="type">byte</span>[], String&gt; uppercased = stream.mapValues(value -&gt; value.toUpperCase());</span><br></pre></td></tr></table></figure>
</li>
<li><p>merge：合并两个流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KStream&lt;<span class="type">byte</span>[], String&gt; merged = stream1.merge(stream2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>peek：对每条记录执行无状态操作，并返回未更改的流,也就是说peek中的任何操作，返回的都是以前的流，可以用来调试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KStream&lt;<span class="type">byte</span>[], String&gt; unmodifiedStream = stream.peek((key, value) -&gt; System.out.println(<span class="string">&quot;key=&quot;</span> + key + <span class="string">&quot;, value=&quot;</span> + value));</span><br></pre></td></tr></table></figure>
</li>
<li><p>print：打印流，可以用来调试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.print();</span><br></pre></td></tr></table></figure>
</li>
<li><p>SelectKey：重新构建key</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将key值改为value的第一个单词</span></span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">KStream&lt;String, String&gt; rekeyed = stream.selectKey((key, value) -&gt; value.split(<span class="string">&quot; &quot;</span>)[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>toStream：将KTable转换成KStream</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KStream&lt;<span class="type">byte</span>[], String&gt; stream = table.toStream();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34405557/article/details/92280481">参考链接</a></p>
<hr>
<h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p><a target="_blank" rel="noopener" href="https://www.oracle.com/cn/java/technologies/apache-maven-getting-started-1.html">参考链接</a></p>
<p>Maven是基于项目对象模型(POM project object model)，可以通过一小段描述信息（配置）来管理项目的构建，报告和文档的软件项目管理工具</p>
<p>使得可以通过pom.xml文件的配置获取jar包，而不用手动去添加jar包</p>
<p>如果需要使用pom.xml来获取jar包，那么首先该项目就必须为maven项目</p>
<h3 id="maven项目的结构"><a href="#maven项目的结构" class="headerlink" title="maven项目的结构"></a>maven项目的结构</h3><p><code>mvn</code> 本身不会做太多的事情，它不知道怎么样编译或者怎么样打包。它把构建的任务交给插件去做。</p>
<p>想要单独启动某个带有main函数的类，可以使用exec插件这样做：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.cd至$&#123;basedir&#125;</span><br><span class="line"></span><br><span class="line">2.`$mvn compile`</span><br><span class="line"></span><br><span class="line">3.`$mvn exec:java -Dexec.mainClass=org.example.App`</span><br><span class="line"></span><br><span class="line">然后 maven会在 `$&#123;basedir&#125;` 下建立一个新的目录 `$&#123;basedir&#125;/target/`</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>路径</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>${basedir}&#x2F;target&#x2F;classes</td>
<td>存放编译后的class文件</td>
</tr>
<tr>
<td>${basedir}&#x2F;target&#x2F;test-classes</td>
<td>存放编译后的测试类class文件</td>
</tr>
</tbody></table>
<p><code>mvn 生命周期</code>（比如<code>mvn package</code>)的意思是：依次执行默认生命周期中直到包括 package 阶段前的所有阶段的插件目标</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>一个项目的生命周期如下：</p>
<table>
<thead>
<tr>
<th align="left">阶段</th>
<th align="left">处理</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">验证 validate</td>
<td align="left">验证项目</td>
<td align="left">验证项目是否正确且所有必须信息是可用的</td>
</tr>
<tr>
<td align="left">编译 compile</td>
<td align="left">执行编译</td>
<td align="left">源代码编译在此阶段完成</td>
</tr>
<tr>
<td align="left">测试 Test</td>
<td align="left">测试</td>
<td align="left">使用适当的单元测试框架（例如JUnit）运行测试。</td>
</tr>
<tr>
<td align="left">包装 package</td>
<td align="left">打包</td>
<td align="left">创建JAR&#x2F;WAR包如在 pom.xml 中定义提及的包</td>
</tr>
<tr>
<td align="left">检查 verify</td>
<td align="left">检查</td>
<td align="left">对集成测试的结果进行检查，以保证质量达标</td>
</tr>
<tr>
<td align="left">安装 install</td>
<td align="left">安装</td>
<td align="left">安装打包的项目到本地仓库，以供其他项目使用</td>
</tr>
<tr>
<td align="left">部署 deploy</td>
<td align="left">部署</td>
<td align="left">拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程</td>
</tr>
</tbody></table>
<h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>通过坐标<code>&lt;dependency&gt;</code>管理，公共库的坐标可以去 <a target="_blank" rel="noopener" href="https://mvnrepository.com/">Maven公共库</a> 搜索</p>
<h3 id="Maven库"><a href="#Maven库" class="headerlink" title="Maven库"></a>Maven库</h3><p>远程库：<code>maven</code> 默认的远程库(<a target="_blank" rel="noopener" href="http://repo1.maven.org/maven2">http://repo1.maven.org/maven2</a>)</p>
<p>本地库： <code>maven</code> 下载了插件或者 <code>jar</code> 文件后存放在本地机器上的拷贝。</p>
<p>​				在 Linux 上，它的位置在 <code>~/.m2/repository</code></p>
<p><code>$mvn install</code>可以把项目安装到本地库</p>
<h3 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h3><p><a target="_blank" rel="noopener" href="https://www.runoob.com/maven/maven-pom.html">参考链接</a></p>
<table>
<thead>
<tr>
<th>标签</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>project</td>
<td>一个项目，一般是pom最顶层标签</td>
</tr>
<tr>
<td>modelVersion</td>
<td>没什么具体意义</td>
</tr>
<tr>
<td>groupId</td>
<td>公司或组织的一个大项目组的ID(com.xxx)</td>
</tr>
<tr>
<td>artifactId</td>
<td>此项目(project)的ID，一个项目组可能有很多个项目，以此区分不同项目</td>
</tr>
<tr>
<td>version</td>
<td>此项目的版本号</td>
</tr>
<tr>
<td>name</td>
<td>此项目的名字</td>
</tr>
<tr>
<td>url</td>
<td>此项目的url</td>
</tr>
<tr>
<td>description</td>
<td>此项目的描述</td>
</tr>
<tr>
<td>properties</td>
<td>此项目的属性</td>
</tr>
<tr>
<td>dependencies</td>
<td>此项目引入插件需要的额外依赖</td>
</tr>
<tr>
<td>dependency</td>
<td>上述依赖中的一个，依赖需要坐标(artifactId, groupId, version)</td>
</tr>
<tr>
<td>scope</td>
<td>指定作用范围(依赖范围)</td>
</tr>
<tr>
<td>parent</td>
<td>指定父项目(artifactId, groupId, version)。<strong>继承的目的是为了消除重复配置或统一依赖版本</strong></td>
</tr>
<tr>
<td>build</td>
<td>构建标签</td>
</tr>
<tr>
<td>plugins</td>
<td>插件标签(构建(build)插件或报表(reporting)插件)</td>
</tr>
<tr>
<td>plugin</td>
<td>具体插件需要指定坐标</td>
</tr>
<tr>
<td>exclude</td>
<td>排除的模式列表</td>
</tr>
<tr>
<td>resources</td>
<td>项目需要的资源</td>
</tr>
<tr>
<td>resource</td>
<td>资源标签，需要<code>&lt;directory&gt;</code>，可用<code>&lt;include&gt;&lt;exclude&gt;排除</code></td>
</tr>
<tr>
<td>modules</td>
<td>模块(子项目)，通过这个可使得一次构建多个项目。<strong>目标是方便构建整个项目</strong></td>
</tr>
<tr>
<td>module</td>
<td>具体模块，需要填写路径</td>
</tr>
</tbody></table>
<ul>
<li>modules实现聚合，parent实现继承<ul>
<li>聚合主要是为了方便快速构建项目，继承主要是为了消除重复配置以及统一依赖版本</li>
<li>对于聚合模块而言，它知道有哪些被聚合的模块，但那些被聚合的模块不知道这个聚合模块的存在；</li>
<li>对于继承的父pom 而言，它不知道有哪些子模块继承它，但那些子模块都必须知道自己的父pom 是什么</li>
</ul>
</li>
</ul>
<p>一个模块用另一个模块的东西的步骤：</p>
<ol>
<li>调用模块的pom添加被调用模块的denpency</li>
<li>将被调用模块重新install</li>
<li>将调用模块重新构建</li>
</ol>
<hr>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="编译相关"><a href="#编译相关" class="headerlink" title="编译相关"></a>编译相关</h3><p>java中类名后面$1表示类中存在内部类，普通内部类编译出class为内部类类名$1,匿名内部类编译成class为类$1</p>
<p>比如</p>
<pre><code>ProducerTest$1.class
ProducerTest.class
</code></pre>
<h3 id="代码相关"><a href="#代码相关" class="headerlink" title="代码相关"></a>代码相关</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="meta">@Setter</span> <span class="meta">@Getter</span> 是lombok的注解</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="VMWare网络连接方式"><a href="#VMWare网络连接方式" class="headerlink" title="VMWare网络连接方式"></a>VMWare网络连接方式</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010948569/article/details/80766597">参考链接</a></p>
<h3 id="桥接"><a href="#桥接" class="headerlink" title="桥接"></a>桥接</h3><p>与vmnet0（交换机）有关。主机网卡与vmnet0之间利用虚拟网桥进行通讯。</p>
<p>虚拟机实例中的网卡如eth0，会连接到vmnet0下。</p>
<p>结构即：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">路由器---主机网卡---虚拟网桥---vmnet0(虚拟交换机)---各个虚拟机网卡eth0/eth1/...</span><br></pre></td></tr></table></figure>

<p>虚拟网桥转发主机网卡收到的广播与组播信息，以及目标为vmnet0网段下的单播。</p>
<p>所以虚拟机ip与主机网卡在同一个网段，网关与DNS也与主机网卡一致</p>
<hr>
<h3 id="NAT-1"><a href="#NAT-1" class="headerlink" title="NAT"></a>NAT</h3><p>与vmnet8、虚拟NAT设备有关。</p>
<p>结构即：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">路由器---主机网卡---主机---主机下的vmnet8网卡---vmnet8(虚拟交换机)---各个虚拟机的网卡</span><br></pre></td></tr></table></figure>

<p>需要注意：上面<code>主机下的vmnet8网卡---vmnet8(虚拟交换机)---各个虚拟机的网卡</code>只用于主机与虚拟机通信。虚拟机与外部联网需要通过虚拟NAT设备，与主机下的vmnet8网卡无关。</p>
<p>所以虚拟机ip、vmnet8(虚拟交换机)、主机下的vmnet8网卡在同一网段，这些网段下的接口都得经过NAT设备才能通信</p>
<hr>
<h3 id="Host-Only"><a href="#Host-Only" class="headerlink" title="Host-Only"></a>Host-Only</h3><p>与vmnet1有关。</p>
<p>结构即：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">路由器---主机网卡---主机---主机下的vmnet1网卡---vmnet1(虚拟交换机)---各个虚拟机的网卡</span><br></pre></td></tr></table></figure>

<p>和nat差不多，但是不通过nat设备通讯，而是通过<code>主机下的vmnet1网卡---vmnet1(虚拟交换机)---各个虚拟机的网卡</code>这样使得虚拟机只能与主机通讯</p>
<p>所以虚拟机ip、vmnet8(虚拟交换机)、主机下的vmnet8网卡在同一网段，这些网段下的接口只能与主机通讯</p>
<hr>
<h2 id="一个简单的操作系统"><a href="#一个简单的操作系统" class="headerlink" title="一个简单的操作系统"></a>一个简单的操作系统</h2><h3 id="32位、64位"><a href="#32位、64位" class="headerlink" title="32位、64位"></a>32位、64位</h3><p>CPU的32位、64位指的是通用寄存器的位数而不是地址总线的条数。</p>
<p>地址总线的条数不一定与这个寄存器位数相等，但数据总线的条数是相等的。</p>
<p>比如：8086是16位CPU，它的寄存器是16位的，但是地址总线扩展到了20位(使得寻址能力到了1MB)</p>
<hr>
<h3 id="启动计算机"><a href="#启动计算机" class="headerlink" title="启动计算机"></a>启动计算机</h3><p>当计算机电源被打开时，会加电自检(POST)，然后寻找启动盘，如果是选择从软盘启动，就会检查软盘的0面0磁道1扇区，如果发现该扇区以<code>0xAA55</code>结束，BIOS就会认为它是一个引导扇区。（该引导扇区应该包含一段少于512字节的执行码），然后BIOS会把这些执行码装载到内存地址<code>0x7c00</code>处，然后跳转到<code>0x7c00</code>，把控制权交给这个代码。</p>
<p>制作一张虚拟软盘，执行码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">	org	07c00h			; 告诉编译器程序加载到7c00处</span><br><span class="line">	mov	ax, cs</span><br><span class="line">	mov	ds, ax</span><br><span class="line">	mov	es, ax</span><br><span class="line">	call	DispStr			; 调用显示字符串例程</span><br><span class="line">	jmp	$			; 无限循环</span><br><span class="line">DispStr:</span><br><span class="line">	mov	ax, BootMessage</span><br><span class="line">	mov	bp, ax			; ES:BP = 串地址</span><br><span class="line">	mov	cx, 16			; CX = 串长度</span><br><span class="line">	mov	ax, 01301h		; AH = 13,  AL = 01h</span><br><span class="line">	mov	bx, 000ch		; 页号为0(BH = 0) 黑底红字(BL = 0Ch,高亮)</span><br><span class="line">	mov	dl, 0</span><br><span class="line">	int	10h			; 10h号中断，这是由BIOS对屏幕及显示器提供的</span><br><span class="line">	ret</span><br><span class="line">BootMessage:		db	&quot;Hello, OS world!&quot;</span><br><span class="line">times 	510-($-$$)	db	0	; 填充剩下的空间，使生成的二进制代码恰好为512字节</span><br><span class="line">dw 	0xaa55				; 结束标志</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h3><details> 
    <summary>保护模式的由来</summary> 
    <p>8086处理器引入了一个重要概念--段。（目标，想要的结果）8086处理器的寻址目标是1M大的内存空间，于是它的地址总线扩展到了20位。但是，一个问题摆在了Intel设计人员面前，（问题）虽然地址总线宽度是20位的，但是CPU中“算术逻辑运算单元（ALU）”的宽度，即数据总线却只有16位，也就是可直接加以运算的指针长度是16位的。如何填补这个空隙呢？可能的解决方案有多种，例如，可以像一些8位CPU中那样，增设一些20位的指令专用于地址运算和操作，但是那样又会造成CPU内存结构的不均匀。又例如，当时的PDP－11小型机也是16位的，但是其内存管理单元（MMU）可以将16位的地址映射到24位的地址空间。受此启发，（解决方案）Intel设计了一种在当时看来不失为巧妙的方法，即分段的方法。</p>
    <p>为了支持分段，Intel在8086 CPU中设置了四个段寄存器：CS、DS、SS和ES，分别用于可执行代码段、数据段、堆栈段及其他段。每个段寄存器都是16位的，对应于地址总线中的高16位。每条“访内”指令中的内部地址也都是16位的，但是在送上地址总线之前，CPU内部自动地把它与某个段寄存器中的内容相加。因为段寄存器中的内容对应于20位地址总线中的高16位（就是把段寄存器左移4位），所以相加时实际上是内存总线中的高12位与段寄存器中的16位相加，而低4位保留不变，这样就形成一个20位的实际地址，也就实现了从16位内存地址到20位实际地址的转换，或者叫“映射”。段式内存管理带来了显而易见的优势，程序的地址不再需要硬编码了，调试错误也更容易定位了，更可贵的是支持更大的内存地址。程序员开始获得了自由。</p>
    <p>技术的发展不会就此止步。intel的80286处理器于1982年问世了，它的地址总线位数增加到了24位，因此可以访问到16M的内存空间。更重要的是从此开始引进了一个全新理念--保护模式。这种模式下内存段的访问受到了限制。访问内存时不能直接从段寄存器中获得段的起始地址了，而需要经过额外转换和检查。为了和过去兼容，80286内存寻址可以有两种方式，一种是先进的保护模式，另一种是老式的8086方式，被成为实模式。系统启动时处理器处于实模式，只能访问1M空间，经过处理可进入保护模式，访问空间扩大到16M，但是要想从保护模式返回到实模式，你只有重新启动机器。还有一个致命的缺陷是80286虽然扩大了访问空间，但是每个段的大小还是64k，程序规模仍受到限制。因此这个先天低能儿注定寿命不会很久。很快它就被天资卓越的兄弟--80386代替了。</p>
    <p>80386是一个32位的CPU，也就是它的ALU数据总线是32位的，同时它的地址总线与数据总线宽度一致，也是32位，因此，其寻址能力达到4GB。对于内存来说，似乎是足够了。从理论上说，当数据总线与地址总线宽度一致时，其CPU结构应该简洁明了。但是，80386无法做到这一点。作为X86产品系列的一员，80386必须维持那些段寄存器的存在，还必须支持实模式，同时又要能支持保护模式，这给Intel的设计人员带来很大的挑战。Intel选择了在段寄存器的基础上构筑保护模式，并且保留段寄存器16位。在保护模式下,它的段范围不再受限于64K，可以达到4G。这一下真正解放了软件工程师,他们不必再费尽心思去压缩程序规模，软件功能也因此迅速提升。</p>
    <p>从8086的16位到80386的32位处理器，这看起来是处理器位数的变化，但实质上是处理器体系结构的变化，从寻址方式上说，就是从“实模式”到“保护模式”的变化。从80386以后，Intel的CPU经历了80486、Pentium、PentiumII、PentiumIII等型号，虽然它们在速度上提高了好几个数量级，功能上也有不少改进，但基本上属于同一种系统结构的改进与加强，而无本质的变化，所以我们把80386以后的处理器统称为IA32（32 Bit Intel Architecture）。
    </p>
</details>
保护模式为段访问提供了保护机制。为了保护段访问，需要规定好段的范围，那么就需要段描述符。描述符中包含的段基址和段界限定义了一个段的范围，越界访问是禁止的。由于某些历史原因，需要把段描述符放置到一个数组中，这个数组就是描述符表，有一个全局的描述符表叫GDT。

<hr>
<p>实模式跳转到保护模式的步骤（感觉没必要知道）</p>
<ol>
<li>准备GDT（Global Descriptor Table）</li>
<li>用lgdt指令加载GDTR（放GDT入口位置的寄存器）</li>
<li>打开A20地址线</li>
<li>置cr0的PE位为1</li>
<li><code>jmp dword SelectorCode32:0</code> 跳转到保护模式</li>
</ol>
<hr>
<p>intel的特权级分四级（ring）</p>
<ul>
<li>内核：ring0</li>
<li>服务：ring1,ring2</li>
<li>应用程序：ring3</li>
</ul>
<p>特权级检验用到的概念</p>
<ul>
<li>CPL：当前特权级</li>
<li>DPL：描述符特权级，规定了访问该段需要的级别</li>
<li>RPL：请求特权级</li>
</ul>
<p>简单的理解：RPL代表真正请求者的特权级，也就是说，你是一个普通用户，特权级为3，当你通过调用门后，你的CPL为0，但是你的这个段选择子的RPL位仍为3，所以cpu一看，小样，你还是3级用户，我DPL高级的资源可不能让你访问。</p>
<hr>
<p>关于一致代码段的概念</p>
<p>在保护模式下，内核程序和用户程序需要分开，但是用户程序也需要读取内核的某些数据，于是操作系统就从内核程序中分配一些可以给用户程序访问的段</p>
<p>用户程序遵循规则：</p>
<ul>
<li>内核程序不知道用户程序的数据，不调用用户程序的数据，也不转移到用户程序</li>
<li>用户程序只能访问到内核的一致代码段</li>
</ul>
<p>一致代码段遵循规则：</p>
<ul>
<li>特权级高的程序不能访问特权级低的数据</li>
<li>特权级低的程序可以访问特权级高的程序，但是特权级不会改变，即不会从用户态切换到内核态</li>
</ul>
<p>非一致代码段遵循规则：</p>
<ul>
<li>只允许同级访问</li>
<li>绝对禁止不同特权级直接访问：内核态不去用户态，用户态不使用内核态</li>
<li>低特权级代码必须通过门(gate)调用来实现对高特权级代码的访问和调用</li>
</ul>
<p><code>call</code>与<code>jmp</code>的转移遵循的规则如下：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">特权级 低→高</th>
<th align="center">特权级 高→低</th>
<th align="center">相同特权间</th>
<th>适用于何种代码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">一致代码段</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">√</td>
<td>不访问受保护资源以及某些类型的异常处理的系统代码</td>
</tr>
<tr>
<td align="center">非一致代码段</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
<td>避免低特权级的程序访问而被保护起来的系统代码</td>
</tr>
<tr>
<td align="center">数据段(总是非一致)</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
<td></td>
</tr>
</tbody></table>
<hr>
<p>门(gate)</p>
<ul>
<li><p>门也是一种描述符：描述了由一个选择子和一个偏移所指定的线性地址，程序通过这个地址进行转移。</p>
</li>
<li><p>x86有四种门：调用门、中断门、陷阱门、任务门</p>
</li>
</ul>
<p>使用调用门的过程分为两个部分：</p>
<ol>
<li>通过调用门和call能从低特权级转到高特权级</li>
<li>通过ret指令能从高特权级转到低特权级（示例代码通过自行把运行在ring3的代码段压栈，然后执行retf指令，从而转移到ring3）</li>
</ol>
<hr>
<p>页式存储</p>
<p>CR3：指向PDE</p>
<p>PDE(Page Directory Entry)：指向PTE</p>
<p>PTE(Page Table Entry)：指向物理页</p>
<hr>
<p>中断和异常</p>
<p>无特权级变换的中断或异常发生时，eflags、cs、eip将依次被压入栈</p>
<p>有特权级变换的中断或异常发生时，会切换栈！</p>
<p>中断门和陷阱门的区别是：通过中断门进入中断服务程序时CPU会自动将中断关闭（将EFLAGS寄存器中IF标志位置0），以防止嵌套中断产生，而通过陷阱门进入服务程序时则维持IF标志位不变</p>
<p>int vec这个汇编指令会向CPU发送中断，vec是中断号</p>
<p>CPU通过中断向量号找到对应的中断向量，这需要我们在内存中建立一张中断向量表（在32位保护模式下，这个表叫做中断描述符表(IDT)),这本书附带的程序在保护模式(<code>protect.c</code>)中初始化IDT</p>
<hr>
<p>Loader的引入</p>
<p>由于512字节限制，需要写一个文件通过引导扇区加载入内存，然后把控制权交给它。但是操作系统开机到运行大概需要经过“引导→加载内核入内存→跳入保护模式→开始执行内核”的过程，这一系列工作512字节可能不够用，所以引入了一个模块叫Loader。先加载Loader到内存，然后Loader加载内核到内存，并跳入保护模式。</p>
<hr>
<h3 id="汇编代码与c代码的相互调用，"><a href="#汇编代码与c代码的相互调用，" class="headerlink" title="汇编代码与c代码的相互调用，"></a>汇编代码与c代码的相互调用，</h3><p>例子</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当前目录下有 bar.c foo.asm</span></span><br><span class="line">nasm -f elf foo.asm -o foo.o # 用nasm把asm编译成.o</span><br><span class="line">gcc -c bar.c -o bar.o #用gcc把.c编译成.o</span><br><span class="line">ld -s foo.o bar.o -o foobar #用ld把 两个.o 链接起来</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># foo.asm</span><br><span class="line"># global是把汇编的函数导出让外面用的关键字</span><br><span class="line"># extern是用到汇编外的函数时需要的声明关键字</span><br><span class="line">global myprint	; 导出myprint函数让 bar.c 使用，需要用golbal声明</span><br><span class="line">global _start	; 必须导出 _start 这个入口，以便让链接器识别。</span><br><span class="line">extern choose	; 汇编用到bar.c中的int choose(int a, int b);函数，需要用extern</span><br></pre></td></tr></table></figure>

<p>由于调用时就是把参数压栈，所以汇编通过压栈可以传参，通过出栈可以读参</p>
<h3 id="ELF文件"><a href="#ELF文件" class="headerlink" title="ELF文件"></a>ELF文件</h3><p>linux的主要可执行文件格式</p>
<p>包括：ELF header、Program header table、Sections、Section header table</p>
<p>组成：ELF header、Program header table、Sections、Section header table</p>
<p>Program header：描述一个段在文件中的位置、大小以及被放进内存后的位置和大小</p>
<hr>
<h3 id="asm汇编指令简述"><a href="#asm汇编指令简述" class="headerlink" title="asm汇编指令简述"></a>asm汇编指令简述</h3><p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html">参考链接</a></p>
<p><strong>x86</strong>上的寄存器名字</p>
<p>通用寄存器：EAX（一般用于存放函数返回值）、EBX、ECX、EDX、EDI、ESI</p>
<p>指针寄存器：</p>
<ul>
<li><p>ESP（栈顶指针，保存当前栈顶地址 extended instruction pointer）</p>
</li>
<li><p>EBP（栈底指针，存放栈的栈底地址 extended base pointer）</p>
</li>
<li><p>EIP（指令指针，存放下一次要执行的指令的地址 extended instruction pointer)，与常说的PC指针相比，就是PC指向正在执行的指令，而IP指向下一条指令</p>
</li>
</ul>
<p>段寄存器：cs、ds、es、fs、gs、ss这样的以s结尾的是段寄存器，用来段寻址用</p>
<p>标志寄存器：eflags，记录一些flag</p>
<p><code>[addr]</code>取地址addr的值</p>
<p>指令</p>
<ul>
<li><p><code>push</code>指令用于将值放入 Stack，这个指令会使得ESP的值减小</p>
</li>
<li><p><code>mov</code>指令用于将一个值写入某个寄存器，如<code>mov a b</code>会把b的值写入a</p>
</li>
<li><p><code>call</code>指令用来调用函数，程序就会去找对应函数名字的标签，并为该函数建立一个新的帧</p>
</li>
<li><p><code>add</code>指令用于将两个运算子相加，并将结果写入第一个运算子</p>
</li>
<li><p><code>pop</code>指令用于取出 Stack 最近一个写入的值（即最低位地址的值），并将这个值写入运算子指定的位置，这个指令会使得ESP的值增加</p>
</li>
<li><p><code>ret</code>指令用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。</p>
</li>
</ul>
<p>例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add_a_and_b</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> add_a_and_b(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译之后的汇编是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_add_a_and_b:</span><br><span class="line">   push   %ebx</span><br><span class="line">   mov    %eax, [%esp+8] </span><br><span class="line">   mov    %ebx, [%esp+12]</span><br><span class="line">   add    %eax, %ebx </span><br><span class="line">   pop    %ebx </span><br><span class="line">   ret  </span><br><span class="line"></span><br><span class="line">_main:</span><br><span class="line">   push   3</span><br><span class="line">   push   2</span><br><span class="line">   call   _add_a_and_b </span><br><span class="line">   add    %esp, 8</span><br><span class="line">   ret</span><br></pre></td></tr></table></figure>

<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>一、简单的进程结构</p>
<p>PCB、进程体、GDT以及TSS（task state segment）组成</p>
<ol>
<li>PCB：进程的描述，进程中断时，各个寄存器的值都被保存到PCB</li>
<li>进程体：进程代码、数据、堆栈</li>
<li>GDT：存放段描述符的项</li>
<li>TSS：存储了不同特权级下的ss和esp，可以在权限级转换进行切换栈的时候使用</li>
</ol>
<p>实现的简单的步骤</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 准备一个进程体（样例代码中的main.c）</span><br><span class="line"><span class="bullet">2.</span> 准备一个PCB：定义并初始化（proc.h中定义了STACK<span class="emphasis">_FRAME结构体）</span></span><br><span class="line"><span class="emphasis">3. 准备GDT和TSS（protect.h定义了TSS结构体）</span></span><br></pre></td></tr></table></figure>

<p>进程简单的运行过程</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 准备好进程体</span><br><span class="line"><span class="bullet">2.</span> 初始化GDT中的TSS和LDT这两个描述符，以及初始化TSS</span><br><span class="line"><span class="bullet">3.</span> 准备PCB</span><br><span class="line"><span class="bullet">4.</span> 完成ring0→ring1跳转（kernel.asm中的restart）</span><br></pre></td></tr></table></figure>

<hr>
<p>二、加入时钟中断，考虑进程切换</p>
<p>打开时钟中断(i8259.c中的代码)，然后修改在kernel.asm里面的中断例程<code>hwint00</code>，中断例程的具体逻辑如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 原寄存器值压入现在的栈</span><br><span class="line"><span class="bullet">2.</span> 切换到内核栈（为了不让当前栈被破坏）,esp指向内核栈顶</span><br><span class="line"><span class="bullet">3.</span> 处理逻辑</span><br><span class="line"><span class="bullet">4.</span> 离开内核栈，esp指向原来的PCB</span><br><span class="line"><span class="bullet">5.</span> 从当前栈pop原寄存器值</span><br><span class="line"><span class="bullet">6.</span> iretd中断返回</span><br></pre></td></tr></table></figure>

<p>中断嵌套，比较简单的方法就是增加一个全局的计数器</p>
<hr>
<p>三、多进程</p>
<p>关键是修改中断例程，可以编写一个包含时钟处理逻辑的<code>clock.c</code>，然后在中断例程中调用，中断例程修改为</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 原寄存器值压入现在的栈</span><br><span class="line"><span class="bullet">2.</span> 切换到内核栈（为了不让当前栈被破坏）,esp指向内核栈顶</span><br><span class="line"><span class="bullet">3.</span> call一个clock<span class="emphasis">_handle函数</span></span><br><span class="line"><span class="emphasis">4. 离开内核栈，esp指向一个PCB（p_</span>proc<span class="emphasis">_ready）</span></span><br><span class="line"><span class="emphasis">5. 从当前栈pop原寄存器值</span></span><br><span class="line"><span class="emphasis">6. iretd中断返回</span></span><br></pre></td></tr></table></figure>

<p>clock_handle函数通过修改p_proc_ready的指向来更换进程，在此可以设计调度算法</p>
<p>比如进程调度可以简单地根据时钟数tick为每个进程分配时间片，用完就到下一个，通过时间片分配的多少可以实现优先级</p>
<p>增加一个任务（进程）简要的修改步骤</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 添加一个进程体</span><br><span class="line"><span class="bullet">2.</span> 在task<span class="emphasis">_table中添加一项进程(global.c)</span></span><br><span class="line"><span class="emphasis">3. 定义任务栈(proc.h)</span></span><br><span class="line"><span class="emphasis">4. 修改STACK_</span>SIZE<span class="emphasis">_TOTAL(proc.h)</span></span><br><span class="line"><span class="emphasis">5. 添加新任务执行体的函数声明(proto.h)</span></span><br></pre></td></tr></table></figure>

<hr>
<p>四、系统调用</p>
<p>让一个中断门和系统调用逻辑对应起来，这样就能通过中断进行系统调用（书里是让0x90号中断与sys_call)绑定</p>
<p>对应不同的调用，可以设立一个函数指针数组sys_call_table以处理相应的系统调用</p>
<p>插一句：</p>
<p>Minix的系统调用仅有3个：<code>send</code>,<code>receive</code>,<code>sendrec</code>，然后以此建立一套消息机制，需要系统支持的功能都是通过消息机制做的。这是一种微内核的思想。</p>
<p>linux则选择了宏内核（单内核）：内核继承了很多模块，各模块直接调用函数，效率高。</p>
<hr>
<h3 id="进程的栈"><a href="#进程的栈" class="headerlink" title="进程的栈"></a>进程的栈</h3><p>当进程由于中断或系统调用从用户态转换到内核态时，进程所使用的栈也要从用户栈切换到内核栈。系统调用实质就是通过指令产生中断，称为软中断。进程因为中断（软中断或硬件产生中断），使得CPU切换到特权工作模式，此时进程陷入内核态，进程进入内核态后，首先把用户态的堆栈地址保存在内核堆栈中，然后设置esp的地址为内核栈地址，这样就完成了用户栈向内核栈的切换</p>
<hr>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>Linux内核没有线程这个概念，线程仅仅被视为一个与其他进程共享某些资源的进程。</p>
<hr>
<h3 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h3><p>为了协调 <strong>IO 设备与 CPU 之间速度的不匹配</strong>，设计出了缓冲区。</p>
<p>这个章节像是在写驱动，不想看</p>
<hr>
<h3 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h3><p>书里采用同步IPC，参照Minix的消息机制</p>
<p>增加了一个系统调用叫sendrec（绑定一个软中断），这个中断调用<code>sys_sendrec</code></p>
<p><code>sys_sendrec</code>会把SEND消息交给<code>msg_send</code>处理，把RECEIVE消息交给<code>msg_receive</code>处理</p>
<p>(实现的代码在chapter8）</p>
<p>在proc.h定义了进程PCB的结构proc，增加了一个状态p_flags，取值如下：</p>
<ul>
<li><p>0表示进程正在运行或准备运行</p>
</li>
<li><p>SENDING表示进程处于发送消息的阻塞状态</p>
</li>
<li><p>RECEIVING表示进程处于接受消息的阻塞状态</p>
</li>
</ul>
<p>进程A向进程B发送消息的步骤:</p>
<ol>
<li><p>A准备好消息M</p>
</li>
<li><p>A通过系统调用<code>sendrec</code>，最终调用<code>msg_send</code></p>
</li>
<li><p>简单判断是否发生死锁</p>
</li>
<li><p>判断目标进程B是否正在等待来自A的消息</p>
<ul>
<li>如果是（B正在阻塞等待）：消息被复制给B，B被解除阻塞继续运行</li>
<li>如果否：A被阻塞，并加入到B的发送队列中</li>
</ul>
</li>
</ol>
<p>进程B想要接受消息（来自特定进程、中断或任意进程）的过程：</p>
<ol>
<li><p>B准备一个空的消息结构体M用于接受消息</p>
</li>
<li><p>B通过系统调用<code>sendrec</code>，最终调用<code>msg_receive</code></p>
</li>
<li><p>判断B是否有个来自硬件的消息(判断has_int_msg) ， 如果是， 并且B准备接收来自中断的消息或准备接收任意消息，则马上准备一个消息给B， 并返回。</p>
</li>
<li><p>如果B想接收来自任意进程（ANY）的消息， 则从自己的发送队列中选取第一个(如果队列非空的话） 将其消息复制给M。还要把这个发送者从发送队列移除掉。</p>
</li>
<li><p>如果B是想接收来自特定进程A的消息， 则先判断A是否正在等待向B发送消息， 若是的话， 将其消息复制给M。还要这个发送者从发送队列移除掉。</p>
</li>
<li><p>如果此时没有任何进程发消息给B， B会被阻塞。</p>
</li>
</ol>
<p>值得说明的是， 不管是接收方还是发送方， 都各自维护一个消息结构体， 只不过发送方的结构体是携带了消息内容的而接收方的是空的。</p>
<p>引入消息机制后增加了一个状态p_flags，在进程调度时只考虑<code>p_flags==0</code>的进程，其他状态(SENDING以及RECEIVING)的进程因此被“阻塞”</p>
<hr>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>跳过了硬盘驱动的部分</p>
<p>这本书的文件系统也是参照Minix的FAT，而且不支持文件夹</p>
<p>需要说明一下：文件系统是要安装到硬盘的一个分区上的，而且一个硬盘可以有多个文件系统共存</p>
<p>文件系统的要素：</p>
<ul>
<li>要有地方放Metadata——superblock</li>
<li>要有地方记录扇区使用情况——sector map</li>
<li>要有地方记录任一文件的信息——inode map以及inode array</li>
<li>要有地方存放文件索引——root数据区</li>
</ul>
<hr>
<p>一、一些结构</p>
<p>硬盘相关：</p>
<ul>
<li><p>分区表：一个结构体数组，记录了状态（可否引导）、起始磁头号等等信息</p>
</li>
<li><p>主\次设备号：主设备号用来区分不同种类的设备，而次设备号用来区分同一类型的多个设备。主设备号告诉操作系统用哪个驱动处理，次设备号告诉驱动这是哪个设备。</p>
</li>
</ul>
<p>文件系统相关(定义在<code>fs.h</code>)：</p>
<ul>
<li><p>super_block：包括文件系统的相关信息（Metadata）</p>
</li>
<li><p>inode：描述文件信息（起始扇区、总扇区数、文件大小等信息）</p>
</li>
<li><p>dir_entry：(inode,文件名)</p>
</li>
<li><p>文件描述符：每个使用中的fd都有一个指针指向一个inode</p>
</li>
<li><p>flip数组：修改<code>proc.h</code>中PCB的定义，增加一个fd数组，记录进程打开了的文件</p>
</li>
</ul>
<hr>
<p>二、文件系统实现</p>
<p>创建文件系统的流程(<code>fs/main.c</code>里面的<code>mkfs()</code>)：</p>
<ul>
<li>向驱动索取ROOT_DEV的起始扇区和大小</li>
<li>建立超级块</li>
<li>建立inode_map(记录inode占用情况)</li>
<li>建立sector_map(记录扇区占用情况)</li>
<li>写入inode_array(这个所谓的inode_array是存在磁盘里的，操作时需要加载到内存，书里用了一个缓冲区inode_table[]缓存所有inode)</li>
<li>建立根目录文件</li>
</ul>
<p>打开关闭读写文件（在<code>lib/</code>下）：</p>
<p>只描述一个，其他的看代码或者看书吧</p>
<p>创建文件的流程(库函数是<code>lib/open.c</code>“系统调用”（其实不是，因为是微内核）是<code>fs/open.c</code>)：</p>
<ul>
<li>调用库函数open()，会发送一个OPEN消息给文件系统</li>
<li>文件系统函数(fs&#x2F;open.c)做以下的事</li>
<li>在调用进程的flip数组中找一个空的fd用来存放即将打开的文件的fd</li>
<li>查找文件是否已经存在（因为是创建，所以肯定不存在）</li>
<li>为文件数据分配扇区</li>
<li>在inode_array中分配一个inode</li>
<li>在inode_map中分配一位</li>
<li>在sector_map分配一位或多位</li>
<li>在相应目录中写入一个dir_entry</li>
<li>系统函数返回消息给库函数</li>
<li>库函数返回消息中的fd</li>
</ul>
<p><code>nr</code>是Linux的源码中为每个系统调用加上的前缀，不知道这里的代码的nr是不是这个意思</p>
<hr>
<h3 id="内存管理-fork"><a href="#内存管理-fork" class="headerlink" title="内存管理?(fork)"></a>内存管理?(fork)</h3><p>这个名字有问题，这个其实是讲新进程怎么创建）</p>
<p>init进程</p>
<p>fork“系统调用”(<code>forkexit.c</code>)的过程：</p>
<ul>
<li>准备一个proc(PCB)给子进程</li>
<li>从proc_table(PCB表)找一个空位给这个PCB，得到的编号作为子进程的pid</li>
<li>把父进程的PCB复制给子进程</li>
<li>获取父进程的内存占用情况，分配同样多的内存给子进程并且要把内容复制过去</li>
<li>调用文件系统操作使得子进程共享父进程的打开了的文件</li>
<li>发送子进程的pid给父进程</li>
<li>由于子进程和父进程的PCB一致，所以在父进程fork的这个时候子进程也处于挂起状态，因此需要发送一个消息给给子线程解除子进程阻塞状态</li>
<li>发送的这个消息pid设置为0，所以子进程收到一个pid是0的消息</li>
</ul>
<hr>
<p>exit：让进程死亡的系统调用：</p>
<ul>
<li><p>通知文件系统清除对应的fd相关项</p>
</li>
<li><p>释放调用exit的这个进程A的内存</p>
</li>
<li><p>设置A的exit_status，这是要返回给父进程的</p>
</li>
<li><p>检查父进程P的状态</p>
<ul>
<li>WAITING：清除P的WAITING位，发送一个消息给P解除阻塞</li>
<li>不是WAITING：置A的HANGING位</li>
</ul>
</li>
<li><p>遍历proc_table找到A的所有子进程B，让B的父进程变成INIT</p>
<ul>
<li><p>如果INIT是WAITING，B也是HANGING，清除INIT的WAITING位，发送一个消息给INIT解除阻塞</p>
</li>
<li><p>如果INIT是WAITING，B不是HANGING，就等B将来调用<code>exit()</code></p>
</li>
<li><p>如果INIT不是WAITING，B是HANGING，就等INIT将来调用wait()</p>
</li>
</ul>
</li>
</ul>
<p>wait：父进程P等待子进程返回的调用：</p>
<ul>
<li>遍历proc_table<ul>
<li>如果P的存在子进程A处于HANGING，那么向P发送消息解除阻塞，释放A的PCB</li>
<li>如果P的子进程都不处于HANGING，置P的WAITING位</li>
<li>如果P根本就没子进程，向P发送消息，消息携带一个表示出错的返回值</li>
</ul>
</li>
</ul>
<p>ps.</p>
<ul>
<li>HANGING表示除了PCB（包含进程的exit_status），进程的所有东西都被清理掉了</li>
<li>WAITING表示一个进程至少有一个子进程，并且这个进程正在等待子进程exit</li>
<li>僵尸进程：自己exit但父进程还没调用wait的子进程（僵尸进程存在父进程）</li>
<li>孤儿进程：父进程exit但自己还在运行的子进程（孤儿进程父进程是INIT）</li>
<li>exit和wait可以理解为实现一次“握手”，这个设计是为了能满足一些进程想要获取子进程结束时返回状态的需求</li>
<li>在这个设计下，INIT进程就成了“收养孤儿进程的孤儿院”</li>
</ul>
<hr>
<p>exec：</p>
<ul>
<li>从消息体中获取各种参数。</li>
<li>通过新的系统调用<code>stat()</code>获取被执行文件大小</li>
<li>使用文件系统的系统调用把文件全部读入MM自己的缓冲区</li>
<li>根据ELF文件的Program Header把被执行文件的各个段放置到合适的位置</li>
<li>建立参数栈</li>
<li>为被执行程序的eax和exx寄存器（分别存放argv和argc）赋值</li>
<li>为程序的eip赋值，这是程序的入口地址，即<code>_start</code>处</li>
<li>为程序的esp赋值</li>
<li>把进程名字改成被执行程序的名字</li>
</ul>
<hr>
<h2 id="C-x2F-C"><a href="#C-x2F-C" class="headerlink" title="C&#x2F;C++"></a>C&#x2F;C++</h2><h3 id="likely-x2F-unlikely"><a href="#likely-x2F-unlikely" class="headerlink" title="likely&#x2F;unlikely"></a>likely&#x2F;unlikely</h3><p>用来优化的宏，当程序员可以确定某种可能较大，可以使用likely()告诉编译器将可能情况对应的的二进制代码紧跟在前面程序的后面，这样就cache在预取数据时就可以将二进制代码拿到cache中。这样，也就增加了cache的命中率。</p>
<hr>
<h3 id="静态库和动态库"><a href="#静态库和动态库" class="headerlink" title="静态库和动态库"></a>静态库和动态库</h3><ul>
<li><p>静态库：函数和数据被编译进一个二进制文件（扩展名通常为.lib）,在使用静态库的情况下，在编译链接可执行文件时，链接器从静态库中复制这些函数和数据，并把它们和应用程序的其他模块组合起来创建最终的可执行文件（.exe）。当发布产品时，只需要发布这个可执行文件，并不需要发布被使用的静态库。</p>
</li>
<li><p>动态库：在使用动态库时，往往提供两个文件：一个引入库（.lib，非必须）和一个.dll文件。这里的引入库和静态库文件虽然扩展名都是.lib，但是有着本质上的区别，对于一个动态链接库来说，其引入库文件包含该动态库导出的函数和变量的符号名，而.dll文件包含该动态库实际的函数和数据。</p>
</li>
</ul>
<p>dll的好处：如果多个应用程序使用同一个dll，该dll的页面只需要存入内存一次，所有的应用程序都可以共享它的页面，从而节省内存。</p>
<p>.so是Linux下的动态链接库，称为动态共享对象（Dynamic Shared Objects）</p>
<p>一般的编译链接命令行为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIC -shared func.c -o libfunc.so</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>core模块：IOC容器，解决对象创建和之间的依赖关系。</p>
<h3 id="获取IOC容器"><a href="#获取IOC容器" class="headerlink" title="获取IOC容器"></a>获取IOC容器</h3><p>IOC容器有两类：BeanFactory或ApplicationContext</p>
<ul>
<li><p>通过Resource获取BeanFactory</p>
<ol>
<li><p>加载Spring配置文件</p>
</li>
<li><p>通过XmlBeanFactory+配置文件来创建IOC容器</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载Spring的资源文件</span></span><br><span class="line">Resource resource = <span class="keyword">new</span> <span class="built_in">ClassPathResource</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="comment">//创建IOC容器对象【IOC容器=工厂类+applicationContext.xml】</span></span><br><span class="line">BeanFactory beanFactory = <span class="keyword">new</span> <span class="built_in">XmlBeanFactory</span>(resource);</span><br></pre></td></tr></table></figure>
</li>
<li><p>类路径下XML获取ApplicationContext</p>
<ul>
<li>直接通过ClassPathXmlApplicationContext对象来获取</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到IOC容器对象</span></span><br><span class="line">ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(ac);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="配置对象"><a href="#配置对象" class="headerlink" title="配置对象"></a>配置对象</h3><p>三种方式</p>
<ul>
<li><p>方式一、使用XML文件配置</p>
<ul>
<li><p>在applicationContext.xml文件中配置对应的信息</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">使用bean节点来创建对象</span></span><br><span class="line"><span class="comment">id属性标识着对象</span></span><br><span class="line"><span class="comment">name属性代表着要创建对象的类全名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;User&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>再通过IOC容器对象得到User对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到IOC容器对象</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) ac.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">System.out.println(user);</span><br></pre></td></tr></table></figure>
</li>
<li><p>关于xml配置的细节：如带参构造、工厂静态方法、工厂非静态方法该如何配置在此略过</p>
</li>
</ul>
</li>
<li><p>方式二、使用注解来配置</p>
<ol>
<li><p>引入context名称空间</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启扫描器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者也可以通过自定义扫描类以<code>@CompoentScan</code>修饰来扫描IOC容器的bean对象。如下代码:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表明该类是配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//启动扫描器，扫描bb包下的</span></span><br><span class="line"><span class="comment">//也可以指定多个基础包</span></span><br><span class="line"><span class="comment">//也可以指定类型</span></span><br><span class="line"><span class="meta">@ComponentScan(<span class="string">&quot;bb&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationScan</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>方式三、使用JavaConfig来配置</p>
<ul>
<li><p>编写一个java类，使用<code>@Configuration</code>修饰该类</p>
</li>
<li><p>使用<code>@Bean</code>来修饰方法，该方法返回一个对象</p>
</li>
<li><p>不管方法体内的对象是怎么创建的，Spring可以获取得到对象就行了</p>
</li>
<li><p>Spring内部会将该对象加入到Spring容器中</p>
</li>
<li><p>容器中bean的ID默认为方法名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@org</span>.springframework.context.annotation.Configuration</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Configuration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">userDao</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDao</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;我是在configuration中的&quot;</span>+userDao);</span><br><span class="line">        <span class="keyword">return</span> userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用时需要使用<code>@ContextConfiguration</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载配置类的信息</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = Configuration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test33</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bb/bean.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (UserDao) ac.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        System.out.println(userDao);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="注解一览"><a href="#注解一览" class="headerlink" title="注解一览"></a>注解一览</h3><ul>
<li><p><code>@ComponentScan</code>扫描器</p>
</li>
<li><p><code>@Configuration</code>表明该类是配置类</p>
</li>
<li><p><code>@Component</code> 指定把一个对象加入IOC容器—&gt;<code>@Name</code>也可以实现相同的效果【一般少用】</p>
</li>
<li><p><code>@Repository 作用同@Component</code>； 在持久层使用</p>
</li>
<li><p><code>@Service 作用同@Component</code>； 在业务逻辑层使用</p>
</li>
<li><p><code>@Controller 作用同@Component</code>； 在控制层使用</p>
</li>
<li><p><code>@Resource</code> 依赖关系</p>
<ul>
<li>如果<code>@Resource</code>不指定值，那么就根据类型来找，相同的类型在IOC容器中不能有两个</li>
<li>如果<code>@Resource</code>指定了值，那么就根据名字来找</li>
</ul>
</li>
<li><p><code>@Autowired</code>作用同<code>@Resource</code>，前者是Spring的注解，后者是J2EE的注解</p>
<ul>
<li><code>@Autowired</code>先byType，类型相同再byName自动注入，而<code>@Resource</code>默认按 byName自动注入(当然也可以指定type&#x3D;”xxx.class”)</li>
</ul>
</li>
<li><p><code>@value</code>修饰一个field，即使给变量赋了初值也会以配置文件application.properties的值为准。</p>
</li>
<li><p><code>@PostConstruct</code> 和 <code>@PreDestory</code> 实现初始化和销毁bean之前进行的操作</p>
</li>
<li><p><code>@primary</code>自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常</p>
</li>
<li><p><code>@Async</code>标注的方法，称之为异步方法,这个注解用于标注某个方法或某个类里面的所有方法都是需要异步处理的。被注解的方法被调用的时候，会在新线程中执行，而调用它的方法会在原来的线程中执行</p>
</li>
<li><p><code>@Valid</code>保证了整个对象的验证, 但是它是对整个对象进行验证，当仅需要部分验证的时候就会出现问题。 这时候，可以使用<code>@Validated</code> 进行分组验证。</p>
</li>
<li><p><code>@scope</code>指定scope属性。属性的值就只有两个：singleton&#x2F;prototype。当使用singleton的时候，对象在IOC容器之前就已经创建了。而使用prototype的时候，对象在使用的时候才创建</p>
</li>
<li><pre><code class="java">//示例
//DAO层注入
@Repository
public class UserDao &#123;&#125;
//业务层注入
@Service
public class UserService &#123;
    //如果@Resource不指定值，那么就根据类型来找---&gt;UserDao....当然了，IOC容器不能有两个UserDao类型的对象
    //这里指定了值，那么Spring就在IOC容器找有没有id为userDao的对象。
    @Resource(name = &quot;userDao&quot;)
    private UserDao userDao;
&#125;
//控制层注入
@Controller
public class UserAction &#123;
    @Resource(name = &quot;userService&quot;)
    private UserService userService;
    public String execute() &#123;
        userService.save();
        return null;
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 注解原理</span><br><span class="line"></span><br><span class="line">注解是基于java的接口进行实现的一种特殊的接口类型。</span><br><span class="line">注解可分三种情况</span><br><span class="line"></span><br><span class="line">1. 是在编译前就会被丢弃的</span><br><span class="line">2. 是编译后留在class中的</span><br><span class="line">3. 一直存在，运行的时候注解也会被保留(框架的注解一般都是第三种)</span><br><span class="line"></span><br><span class="line">Class对象，Method对象，Parameter对象，Constructor对象等java反射对象通常都具有getAnnotation方法。可以直接获取保留到运行时的注解实例，就像这样：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">@Component</span><br><span class="line">class AnnoTest &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>这样的一个类，有一个component注解，我们可以通过这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Component</span> <span class="variable">comp</span> <span class="operator">=</span> AnnoTest.class.getAnnotation(Component.class);</span><br><span class="line">Annotation[] annotations = AnnoTest.class.getAnnotations();</span><br><span class="line"><span class="comment">// 其实还有两个注解的get方法，你可以自己去看，这里不多说。</span></span><br></pre></td></tr></table></figure>
<p>就直接得到了class上面的注解。</p>
<p>注解和普通接口不一样，他声明的语法比较特别，<code>public @interface 注解名</code>。为了标识注解的使用范围还需要使用一些java提供的几个其他注解，这些用来描述注解的注解被称为元注解。<br>@Retention，保留范围（在源码中存在，还是在字节码里面，还是一直留到运行环境），一般是Runtime<br>@Target 注解的作用对象，类型还是字段还是方法，这个注解是写在什么地方的<br>@Inherited 是否可以继承此注解，这个注解仅仅在针对类的注解中起效，如果一个类继承了使用了含有他的注解的父类，那么这个类也会拥有父类的那个注解<br>@Documented 注解再生成JavaDoc的时候是否会被写入Javadoc。</p>
<p>总之，这样就是有一个注解了，比如这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Component &#123;</span><br><span class="line">	<span class="comment">//组件名称,实际上是之后使用注解时放在@component(name=&quot;xxxx&quot;)这里面的那个name，没写的话就是这里的default默认值</span></span><br><span class="line">	String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="comment">//组件创建类型</span></span><br><span class="line">	Scope <span class="title function_">scope</span><span class="params">()</span> <span class="keyword">default</span> Scope.SINGLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，用反射的手法拿到这些带有注解的class，method，field之类的，然后get到他们的注解，然后对注解进行处理，无论是aop还是注入，按照你的需要自己实现。</p>
<p>这里有一个例子，这个是仿照spring进行properties文件进行值注入的方法，他通过读取class的configProperties注解得到properties文件的位置，然后注入到bean的字段中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">prcess</span><span class="params">(Object target, Definition definition, IFactory factory)</span> &#123;</span><br><span class="line">	Class&lt;?&gt; clazz = definition.getClazz();</span><br><span class="line">	<span class="type">ConfigProperties</span> <span class="variable">config</span> <span class="operator">=</span> clazz.getAnnotation(ConfigProperties.class);</span><br><span class="line">	<span class="keyword">if</span> (config == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> target;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">String</span> <span class="variable">location</span> <span class="operator">=</span> config.value();</span><br><span class="line">	<span class="keyword">if</span> (!location.startsWith(File.separator)) &#123;</span><br><span class="line">		location = File.separator + location;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> clazz.getResource(location);</span><br><span class="line">	<span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		props.load(url.openStream());</span><br><span class="line">		<span class="comment">// 这个只是对properties的封装，就当他是普通properties好了</span></span><br><span class="line">		<span class="type">PropertiesConfig</span> <span class="variable">propsConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertiesConfig</span>();</span><br><span class="line">		propsConfig.setProperties(props);</span><br><span class="line">		Set&lt;String&gt; keys = props.stringPropertyNames();</span><br><span class="line">		<span class="keyword">for</span> (String propName : keys) &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">fieldName</span> <span class="operator">=</span> propName.replace(config.prefix() + <span class="string">&quot;.&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//按照properties的key，去掉前缀后读取类的字段Field</span></span><br><span class="line">				<span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(fieldName);</span><br><span class="line">				<span class="comment">// 开启操作权限</span></span><br><span class="line">				field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">				<span class="comment">// 字段不是string型就需要转换一下</span></span><br><span class="line">				<span class="keyword">if</span> (field.getType() != String.class) &#123;</span><br><span class="line">					<span class="comment">// 获取类型转换器</span></span><br><span class="line">					<span class="type">ICovertor</span> <span class="variable">covertor</span> <span class="operator">=</span> Covertors</span><br><span class="line">					  .getCovertor(String.class, field.getType());</span><br><span class="line">					<span class="keyword">if</span> (covertor != <span class="literal">null</span>) &#123;</span><br><span class="line">						<span class="comment">// 转换类型并且注入</span></span><br><span class="line">						field.set(target, covertor</span><br><span class="line">						  .covert(propsConfig.get(propName)));</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">// 反向获取类型转换器（这里的转换器接口</span></span><br><span class="line">						<span class="comment">//是双向的，其实这样区分方向转换不是很好，</span></span><br><span class="line">						<span class="comment">//但是我现在没有来得及改他。</span></span><br><span class="line">						covertor = Covertors</span><br><span class="line">					 	    .getCovertorRev(field.getType(), </span><br><span class="line">						    String.class);</span><br><span class="line">						<span class="comment">// 转换并注入， 其实这里应该判空，</span></span><br><span class="line">						<span class="comment">// 但是当时应该是我忘记了</span></span><br><span class="line">						field.set(target, covertor.</span><br><span class="line">						 covertRev(propsConfig.get(propName)));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// 类型一致，直接注入</span></span><br><span class="line">					field.set(target, propsConfig.get(propName));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				<span class="comment">// 注入失败也无所谓，无视这个字段下一个注入</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(TYPE)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConfigProperties &#123;</span><br><span class="line">	String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">	String <span class="title function_">prefix</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>附一个近期手写的ioc容器，仿springboot，用注解驱动的那种，虽然水平比较菜，但是注解还是用了不少的，哦，对了，这个代码需要Java11才行。</p>
<p><a href="https://link.zhihu.com/?target=https://github.com/SW-Fantastic/ApplicationSupporthttps://github.com/SW-Fantastic/ApplicationSupport">代码</a></p>
<hr>
<h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><ul>
<li><p><code>@Controller</code></p>
<ul>
<li><p>注解在类上表明是Spring MVC的Controller，Dispatcher Servlet会自动扫描注解了此注解的类。它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示</p>
</li>
<li><p>处理方法返回值可以是如下类型</p>
<ul>
<li><p><code>ModelAndView </code>：能够跳转到其他资源且能传递数据</p>
</li>
<li><p><code>String</code>：如果不加注解<code>@ResponseBody</code>，则表示跳转到其他页面但这样不能传递数据。如果有这个注解，就是字符串。如果没有定义外部资源的话，就算不加也是返回字符串</p>
</li>
<li><p><code>void</code>：用于处理ajax响应(<code>response.getWriter().write()</code>即可传递数据，所以不需要返回值)</p>
<p>如果在方法内通过原始servlet的<code>getRequestDispatcher().forward()</code>跳转，那也不需要返回值。</p>
</li>
<li><p><code>Object</code>：会带有<code>@ResponseBody</code>，表示返回的就是数据，详见<code>@ResponseBody</code>注解</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>@RequestMapping</code></p>
<ul>
<li>建立请求URL和处理方法之间的对应关系</li>
<li>作用在类上：第一级的访问目录<br>作用在方法上：第二级的访问目录，无标注则使用类级的路径</li>
<li>path-指定请求路径的URL<br>value属性和path属性是一样的<br>mthod 指定该方法的请求方式<br>params 指定限制请求参数的条件<br>headers 发送的请求中必须包含的请求头</li>
<li>配合<code>@PathVariable</code>可以提取path中的变量</li>
<li><code>@RequestParam</code>接收来自请求体或url的queryString中的参数</li>
<li><code>@RequestBody</code>接收来自请求体的参数(常用application&#x2F;json、xml)</li>
</ul>
</li>
<li><p><code>@Autowired</code></p>
<ul>
<li>用了@Autowired，就不需要写getter&#x2F;setter方法了</li>
</ul>
</li>
<li><p><code>@ResponseBody</code></p>
<ul>
<li><p>通常使用在控制层的方法上</p>
</li>
<li><p>用于将Controller的方法返回的对象，通过springmvc提供的<code>HttpMessageConverter</code>接口转换为指定格式的数据如：json、xml等，通过Response响应给客户端。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login.do&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">login</span><span class="params">(String name, String password, HttpSession session)</span> &#123;</span><br><span class="line">	user = userService.checkLogin(name, password);</span><br><span class="line">	session.setAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>(user);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>@RequestBody</code></p>
<ul>
<li><p>作用：用于获取请求体的内容，把请求中的JSON转为对应对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path=&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(<span class="meta">@RequestBody</span> String body)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">    System.out.println(body);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>@RestController</p>
<p>@RestController &#x3D; @Controller + @ResponseBody</p>
</li>
</ul>
<h3 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h3><p>使用WebMvcConfigurer代替web.xml配置web项目</p>
<p>interceptor与servlet的filter类似</p>
<p>spring mvc中路径参数带点’.’的话后面的值会被忽略</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fundebug/p/real-time-communication-technologies-of-web.html">web实时推送技术</a> websocket</p>
<hr>
<h2 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h2><p>随着Spring注解的数量越来越多，并且被大量的使用，尤其是相同的多个注解会被大量重复地用到各个类或者方法中。这样就导致了繁琐的配置及大量冗余的代码。Spring Boot框架本质上就是通过<strong>组合注解</strong>的方式实现了诸多Spring注解的组合，从而极大地简化了Spring框架本身的繁琐配置，实现快速的集成和开发。</p>
<p>spring项目的文件结构</p>
<table>
<thead>
<tr>
<th>路径</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>${basedir}</td>
<td>存放 pom.xml和所有的子目录</td>
</tr>
<tr>
<td>${basedir}&#x2F;src&#x2F;main&#x2F;java</td>
<td>项目的 java源代码</td>
</tr>
<tr>
<td>${basedir}&#x2F;src&#x2F;main&#x2F;resources</td>
<td>项目的资源，比如说 property文件</td>
</tr>
<tr>
<td>${basedir}&#x2F;src&#x2F;test&#x2F;java</td>
<td>项目的测试类，比如说 JUnit代码</td>
</tr>
<tr>
<td>${basedir}&#x2F;src&#x2F;test&#x2F;resources</td>
<td>测试使用的资源</td>
</tr>
</tbody></table>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">com</span><br><span class="line">  +- example</span><br><span class="line"><span class="code">    +- myproject</span></span><br><span class="line"><span class="code">      +- Application.java</span></span><br><span class="line"><span class="code">      |</span></span><br><span class="line"><span class="code">      +- domain</span></span><br><span class="line"><span class="code">      |  +- Customer.java</span></span><br><span class="line"><span class="code">      |  +- CustomerRepository.java</span></span><br><span class="line"><span class="code">      |</span></span><br><span class="line"><span class="code">      +- service</span></span><br><span class="line"><span class="code">      |  +- CustomerService.java</span></span><br><span class="line"><span class="code">      |</span></span><br><span class="line"><span class="code">      +- controller</span></span><br><span class="line"><span class="code">      |  +- CustomerController.java</span></span><br></pre></td></tr></table></figure>

<p>helloworld</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># helloworld</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改<code>src/main/resources/application.properties</code>，增加<code>server.port=8081</code>可以更改端口</p>
<h3 id="spring-boot运作原理"><a href="#spring-boot运作原理" class="headerlink" title="spring boot运作原理"></a>spring boot运作原理</h3><p>关键：针对不同场景组合不同的条件注解(@Conditional)</p>
<p>@SpringBootApplication注解实际上是一个组合注解，一共组合了以下三个注解</p>
<ul>
<li>@SpringBootConfiguration：声明当前类是一个配置类</li>
<li>@EnableAutoConfiguration：开启自动配置功能，自动加载核心包来配置项目。<ul>
<li>具体是通过导入注解<code>import(EnableAutoConfigurationImportSelector.class)</code>类的实例，在逻辑上实现了对所依赖的核心jar下META-INF&#x2F;spring.factories文件的扫描，该文件则声明了有哪些自动配置需要被Spring容器加载，从而Spring Boot应用程序就能自动加载Spring核心容器配置，以及其他依赖的项目组件配置，从而最终完成应用的自动初始化，通过这种方法就向开发者屏蔽了启动加载的过程。</li>
</ul>
</li>
<li>@ComponentScan：实现了对开发者自定义的应用包扫描<ul>
<li>具体是通过basePackageClasses或者basePackages属性来指定要扫描的包。如果没有指定这些属性，那么将从声明这个注解的类所在的包开始，扫描包及子包。而@SpringBootApplication注解声明的类就是main函数所在的启动类，因此扫描的包是该类所在包及其子包。因此，一般启动类会放在一个比较前的包目录中。</li>
</ul>
</li>
</ul>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>spring boot有集成websocket，但是用的是更高层的STOMP协议</p>
<ol>
<li><p>添加websocket的依赖</p>
</li>
<li><p>编写配置类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractWebSocketMessageBrokerConfigurer</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> &#123;</span><br><span class="line">        registry.addEndpoint(<span class="string">&quot;/endpointWisely&quot;</span>).withSockJS(); </span><br><span class="line">        registry.addEndpoint(<span class="string">&quot;/endpointChat&quot;</span>).withSockJS();<span class="comment">//注册STOMP端点，指定使用SockJS协议</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageBroker</span><span class="params">(MessageBrokerRegistry registry)</span> &#123;</span><br><span class="line">        registry.enableSimpleBroker(<span class="string">&quot;/queue&quot;</span>,<span class="string">&quot;/topic&quot;</span>); <span class="comment">//其中/queue是点对点消息代理，/topic是广播式消息代理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写浏览器向服务端的请求消息类、服务端向浏览器的应答消息类</p>
</li>
<li><p>编写控制器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WsController</span> &#123;</span><br><span class="line">	<span class="meta">@MessageMapping(&quot;/welcome&quot;)</span><span class="comment">//浏览器发送请求时会映射到/welcome</span></span><br><span class="line">	<span class="meta">@SendTo(&quot;/topic/getResponse&quot;)</span><span class="comment">//服务端有消息时则会对订阅了/topic/getRespons的浏览器发送消息</span></span><br><span class="line">	<span class="keyword">public</span> WiselyResponse <span class="title function_">say</span><span class="params">(WiselyMessage message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WiselyResponse</span>(<span class="string">&quot;Welcome, &quot;</span> + message.getName() + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> SimpMessagingTemplate messagingTemplate;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@MessageMapping(&quot;/chat&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleChat</span><span class="params">(Principal principal, String msg)</span> &#123; <span class="comment">//2</span></span><br><span class="line">		<span class="keyword">if</span> (principal.getName().equals(<span class="string">&quot;wyf&quot;</span>)) &#123;<span class="comment">//3</span></span><br><span class="line">			messagingTemplate.convertAndSendToUser(<span class="string">&quot;wisely&quot;</span>,</span><br><span class="line">					<span class="string">&quot;/queue/notifications&quot;</span>, principal.getName() + <span class="string">&quot;-send:&quot;</span>+ msg);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			messagingTemplate.convertAndSendToUser(<span class="string">&quot;wyf&quot;</span>,</span><br><span class="line">					<span class="string">&quot;/queue/notifications&quot;</span>, principal.getName() + <span class="string">&quot;-send:&quot;</span>+ msg);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写演示页面，利用js订阅主题</p>
</li>
<li><p>为页面配置viewController</p>
</li>
</ol>
<h3 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h3><ul>
<li><p>Spring Data JPA(Java Persistence API)</p>
<ul>
<li>其实就是想摆脱SQL，但是还是SQL更好用</li>
<li>配置使用Spring Data JPA<ul>
<li><code>@EnableJpaRepositories</code></li>
</ul>
</li>
<li>定义DAO层(是接口，不是类)：继承一个JpaRespository接口</li>
<li>定义查询方法<ul>
<li>根据字段写方法名，如<code>findBy&lt;字段名&gt;[Like]</code></li>
<li><code>@Query(&quot;sql语句&quot;)</code></li>
<li>如果语句是一个delete或update操作时需要加上<code>@Modifying</code>注解</li>
<li>事务操作可以添加<code>@Transactional</code></li>
</ul>
</li>
<li>Specification，JPA提供Criteria查询来动态构建复杂的查询条件<ul>
<li>通过实现一个<code>Specification</code>接口，在重写的<code>toPredicate</code>方法中添加复杂的条件</li>
</ul>
</li>
</ul>
</li>
<li><p>Spring Data REST</p>
<ul>
<li>基于Spring Data JPA的repository，可自动输出为REST资源。</li>
</ul>
</li>
<li><p>Spring Data JPA对所有默认方法都开启了事务支持</p>
</li>
<li><p>cache</p>
</li>
<li><p>spring boot整合mybatis</p>
<ul>
<li>pom添加依赖</li>
<li>创建实体类xxx</li>
<li>编写xxxMapper接口，使用<code>@Mapper</code>注解</li>
<li>在resources&#x2F;mapper中添加实体类对应的xxxMapper.xml</li>
<li>编写xxxService类：<code>@Service</code>注解、注入xxxMapper，利用xxxMapper接口的方法进行操作</li>
<li>编写xxxController</li>
<li>启动类增加Mapper扫描注解<code>@MapperScan(&quot;mapper路径&quot;)</code></li>
</ul>
</li>
</ul>
<hr>
<h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h2><p><a target="_blank" rel="noopener" href="https://dubbo.gitbooks.io/dubbo-user-book/content/preface/architecture.html">参考链接</a></p>
<p>dubbo是一个分布式的服务框架，致力于提供高性能和<strong>透明化</strong>的<strong>RPC</strong>方案，以及SOA服务治理方案。</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ol start="0">
<li>容器启动provider算作开始</li>
<li>provider一开始就向registry注册自己提供的服务</li>
<li>consumer也一开始就向registry订阅需要的服务</li>
<li>registry向consumer异步提示(notify)</li>
<li>consumer向provider进行同步RPC调用(invoke)</li>
<li>consumer和provider在内存中累计调用次数和调用时间，定时异步发送一次统计数据到监控中心</li>
</ol>
<h3 id="交互原理浅析"><a href="#交互原理浅析" class="headerlink" title="交互原理浅析"></a>交互原理浅析</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/stuqbx/article/details/88724205">参考链接</a></p>
<ul>
<li><p>Provider可通过<code>@Service</code>（注意！这不是spring的注解，是dubbo的注解）暴露服务；Consumer可通过<code>@Reference</code>引用服务</p>
<ul>
<li>ps.这个注解好像被弃用了，换成了<code>@DubboService</code>和<code>@DubboReference</code></li>
</ul>
</li>
<li><p>上述配置(不一定是注解，可以使xml或者是java)，反正到最后都会被解析为一堆<code>xxxConfig</code>以及<code>xxxBean</code>，而其中比较重要的就是<code>ServiceBean</code>和<code>ReferenceBean</code>，这两个Bean都有一个成员<code>Protocol</code></p>
</li>
<li><p>而Consumer和Provider之间就是通过<code>Protocol</code>交互的</p>
<ul>
<li><code>Protocol</code>接口中的<code>export(Invoker)</code>负责暴露<code>Invoker</code>、<code>refer(url)</code>负责通过url获取<code>Invoker</code>。</li>
<li><code>Invoker</code>代表一个可执行体，有<code>invoke(Invocation)</code></li>
<li><code>Invocation</code>可认为是session，持有调用过程的变量(如：方法名，参数)</li>
</ul>
</li>
</ul>
<hr>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/">教程</a></p>
<p>用js动态把数据渲染进DOM，通过vue处理DOM而不需要接触DOM</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;<span class="attr">el</span>:<span class="string">&#x27;app-4&#x27;</span>&#125;) <span class="comment">//js创建一个vue实例，对应DOM中id为app-4的元素</span></span><br></pre></td></tr></table></figure>

<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p><code>v-xxx:attribute</code>出现在html标签的属性上则表明这是 Vue 提供的特殊属性</p>
<ul>
<li><code>v-bind:href=&quot;url&quot;</code>绑定元素的href属性为表达式url的值</li>
<li><code>v-if</code>&#x2F;<code>v-for</code>条件与循环</li>
<li><code>v-on:click=&quot;doSomething&quot;</code>click事件监听与doSomething绑定</li>
<li><code>v-model</code>双向绑定(表单数据, 应用状态)</li>
<li><code>v-once</code>一次性插入一个值</li>
<li><code>v-html</code>插入html(不要乱用，可能会导致XSS攻击)</li>
</ul>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><ul>
<li><p>对应html标签？通过在Vue中注册新组件可以自定义新的html标签？</p>
<ul>
<li><p>新组件用<code>template</code>来描述其模板特性，还可用<code>props</code>来定义组件的属性(即，新标签的属性)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个名为button-counter 的新组件</span></span><br><span class="line"><span class="comment">//1.组件名为&quot;button-counter&quot;</span></span><br><span class="line"><span class="comment">//2.data必须是一个函数(只有这样才能为每个实例维护一份被返回对象的独立的拷贝)</span></span><br><span class="line"><span class="comment">//3.template 写组件的内容(元素和触发的事件)</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;button-counter&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;button v-on:click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--div是vue实例的根元素，button-counter作为自定义元素被嵌套在里面，每使用一次就有一个新的button-counter实例，它们是独立的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;components-demo&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个对应上述根元素的vue实例，在这个元素内部可以使用此前注册过的组件</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123; <span class="attr">el</span>: <span class="string">&#x27;#components-demo&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>组件注册</p>
<ul>
<li>全局注册：即便你已经不再使用一个组件了，它仍然会被包含在你最终的构建结果中。<strong>全局注册的行为必须在根 Vue 实例 (通过 <code>new Vue</code>) 创建之前发生</strong></li>
<li>局部注册：在new Vue的时候再加入<code>components</code>选项js对象以及其要使用的组件。</li>
</ul>
</li>
<li><p>模块</p>
<ul>
<li><code>import</code></li>
<li>&#96;&#96;export default&#96;</li>
</ul>
</li>
</ul>
<h3 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h3><ul>
<li>只有当实例被创建时就已经存在于 data 中的 property 才是响应式的</li>
<li>实例有生命周期hook</li>
</ul>
<h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><ul>
<li><code>&#123;&#123;&#125;&#125;</code>(双大括号，也叫mustache)会把数据解释为普通文本而非HTML</li>
<li><code>.</code>是修饰符，用于指出一个指令应该以特殊方式绑定</li>
<li><code>:bind</code>与<code>@click</code>是<code>v-bind</code>与<code>v-on:click</code>的缩写</li>
</ul>
<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>使用例子</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Original message: &quot;&#123;&#123; message &#125;&#125;&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">// 计算属性的 getter</span></span><br><span class="line">    <span class="attr">reversedMessage</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// `this` 指向vm</span></span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">message</span>.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>computed</code>，我理解为在html的元素中声明变量，然后在js的Vue示例中使用这些变量</li>
<li>计算属性是基于它们的响应式依赖进行缓存的，<strong>只在相关响应式依赖发生改变时它们才会重新求值</strong></li>
<li><code>method</code>也可以计算，但每次渲染都会执行函数</li>
</ul>
<h3 id="侦听器watch"><a href="#侦听器watch" class="headerlink" title="侦听器watch"></a>侦听器watch</h3><ul>
<li><code>watch</code>，可以监控一个值的变换，并调用因为变化需要执行的方法</li>
</ul>
<h3 id="单文件组件-amp-生产环境"><a href="#单文件组件-amp-生产环境" class="headerlink" title="单文件组件&amp;生产环境"></a>单文件组件&amp;生产环境</h3><ul>
<li>可以写成<code>.vue</code>文件<ul>
<li>包括<code>&lt;template&gt;</code>、<code>&lt;script&gt;</code>、<code>&lt;style&gt;</code>三部分</li>
</ul>
</li>
<li>Vue独立版本可以直接用 <code>&lt;script&gt;</code> 元素引入 Vue 而不提前进行构建</li>
<li>在生产中则会使用构建工具(如webpack)</li>
</ul>
<p>下略，详见官方教程</p>
<h3 id="Vue项目结构"><a href="#Vue项目结构" class="headerlink" title="Vue项目结构"></a>Vue项目结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">├─build <span class="comment">#构建脚本</span></span><br><span class="line">├─config <span class="comment">#存放项目的一些基本配置信息</span></span><br><span class="line">├─src <span class="comment">#项目的源码</span></span><br><span class="line">│  ├─api <span class="comment">#我看的实例项目添加了一个api目录，里面封装一些利用ajax(axios)进行的请求操作</span></span><br><span class="line">│  ├─assets <span class="comment">#资产文件？</span></span><br><span class="line">│  │  ├─icon</span><br><span class="line">│  │  └─style</span><br><span class="line">│  ├─common</span><br><span class="line">│  ├─components <span class="comment">#存放Vue组件</span></span><br><span class="line">│  ├─mock <span class="comment">#mock测试</span></span><br><span class="line">│  ├─page <span class="comment">#存放完整页面Vue文件</span></span><br><span class="line">│  ├─router <span class="comment">#路由的js文件，与vue的路由管理器有关(https://router.vuejs.org/zh/guide/#html)，将components映射到routes</span></span><br><span class="line">│  ├─store </span><br><span class="line">│  ├─utils</span><br><span class="line">|  ├─App.vue <span class="comment">#项目的第一个Vue组件,在main.js中会创建一个实例与index.html中的&lt;div id=&quot;app&quot;&gt;对应</span></span><br><span class="line">|  └─main.js <span class="comment">#相当于Java中的main方法，是整个项目的入口js</span></span><br><span class="line">├─static <span class="comment">#静态资源</span></span><br><span class="line">|  ├─geetest</span><br><span class="line">|  ├─images</span><br><span class="line">|  ├─qr</span><br><span class="line">|  └─svg</span><br><span class="line">├─index.gtml <span class="comment">#入口页，是项目唯一的HTML页面</span></span><br><span class="line">├─package.json <span class="comment">#定义了项目的所有依赖，包括开发时依赖和发布时依赖</span></span><br><span class="line">└─package-lock.json <span class="comment">#控制依赖版本用</span></span><br></pre></td></tr></table></figure>

<p><code>App.vue</code>←—(创建组件)—<code>main.js</code>—(组件对应<code>&lt;div id=&quot;#app&quot;</code>)—→index.html</p>
<p><code>App.vue</code>包括模板、脚本、样式</p>
<ul>
<li>模板包含<code>router-view</code>(以简单理解为一个占位符，这个占位符展示的内容将根据当前具体的 URL 地址来定。具体展示的内容，要参考路由表，即 router&#x2F;index.js 文件)</li>
<li>脚本用于初始化数据</li>
<li>样式用于页面美化</li>
</ul>
<hr>
<h2 id="Vue-CLI"><a href="#Vue-CLI" class="headerlink" title="Vue CLI"></a>Vue CLI</h2><p><a target="_blank" rel="noopener" href="https://cli.vuejs.org/zh/guide/">教程</a></p>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul>
<li>CLI (<code>@vue/cli</code>)：快速构造原型</li>
<li>CLI 服务 (<code>@vue/cli-service</code>) ：开发依赖</li>
<li>CLI插件(@vue&#x2F;cli-plugin-)：如 Babel&#x2F;TypeScript 转译、ESLint 集成、单元测试和 end-to-end 测试等</li>
</ul>
<h3 id="快速开发"><a href="#快速开发" class="headerlink" title="快速开发"></a>快速开发</h3><ul>
<li><code>vue serve</code>：在开发环境模式下零配置为 .js 或 .vue 文件启动一个服务器</li>
<li><code>vue build</code>：在生产环境模式下零配置构建一个 .js 或 .vue 文件</li>
<li><code>vue create</code>：创建新项目</li>
<li><code>vue add</code>：添加插件</li>
<li><code>public/index.html</code> 文件是一个会被 <a target="_blank" rel="noopener" href="https://github.com/jantimon/html-webpack-plugin">html-webpack-plugin</a> 处理的模板。</li>
</ul>
<h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>默认情况下，一个 Vue CLI 项目有三个模式</p>
<ul>
<li><code>development</code> 模式用于 <code>vue-cli-service serve</code></li>
<li><code>test</code> 模式用于 <code>vue-cli-service test:unit</code></li>
<li><code>production</code> 模式用于 <code>vue-cli-service build</code> 和 <code>vue-cli-service test:e2e</code></li>
</ul>
<hr>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>开源的应用容器引擎，基于Go语言</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><strong>镜像（Image）</strong>：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li>
<li><strong>容器（Container）</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li>
<li><strong>仓库（Repository）</strong>：仓库可看成一个代码控制中心，用来保存镜像。</li>
</ul>
<p>一个docker镜像由多个可读的镜像层组成，然后运行的容器会在这个docker的镜像上面多加一层可写的容器层，任何的对文件的更改都只存在此容器层。因此任何对容器的操作均不会影响到镜像。</p>
<p>如果需要获取某个文件，那么容器曾会从上到下去下一层的镜像层去获取文件，如果该层文件不存在，那么就会去下一镜像层去寻找，直到最后一层。<br>对于用户而言，用户面向的是一个叠加后的文件系统</p>
<hr>
<p>docker run的流程</p>
<ol>
<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个ip地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ol>
<hr>
<h3 id="命令大全"><a href="#命令大全" class="headerlink" title="命令大全"></a><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-command-manual.html">命令大全</a></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br><span class="line">docker search httpd</span><br><span class="line">docker pull ubuntu:15.10</span><br><span class="line">docker image ls</span><br><span class="line">docker run -it ubuntu:15.10 /bin/bash</span><br><span class="line">docker run -d#后台运行容器并返回容器ID</span><br><span class="line">docker exec -it a22bb8267fb1 /bin/bash</span><br><span class="line">docker stop a22bb8267fb1</span><br><span class="line">docker rm -f 1e560fca3906</span><br><span class="line">docker rmi hello-world #删除镜像</span><br><span class="line">docker login docker.io #登录自己的仓库</span><br><span class="line">docker commit -a &quot;runoob.com&quot; -m &quot;my apache&quot; a404c6c174a2  mymysql:v1 #提交镜像</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">镜像保存与加载至tar</span></span><br><span class="line">docker save ubuntu:load &gt; /root/ubuntu.tar</span><br><span class="line">docker load&lt;ubuntu.tar</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">映射端口, -p 外部端口:内部端口</span></span><br><span class="line">docker run -p 81:80</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">挂载数据卷, -v 宿主机目录:容器目录</span></span><br><span class="line">sudo docker run -d --rm --name nginx_with_baidu -d -p 82:80 -v ~/test_docker_volume:/usr/share/nginx/html tzl/nginx:v1.12.2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">传递环境变量, -e NAME=VALUE</span></span><br><span class="line">docker run --name mydocker -e USERNAME=&quot;WANFEI&quot; www/test-docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将宿主机文件复制到容器内</span></span><br><span class="line">docker cp 文件名 容器ID:/home</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">容器ssh(失败，不知道为什么就是permission denied)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行一个系统镜像，--privileged，使用该参数后容器内的root拥有真正的root权限</span></span><br><span class="line">docker run -dit --privileged silence1990/docker_for_traceanomaly:v1.1 init</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装sudo</span></span><br><span class="line">apt-get install sudo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改root密码(好像不用sudo是改不了的)</span></span><br><span class="line">sudo passwd root</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载openssh-client</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改ssh配置</span></span><br><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line">PermitRootLogin yes #root能使用ssh登录</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker commit修改好的容器</span></span><br><span class="line">docker commit -a &quot;zltan&quot; -m &quot;ssh_installed&quot; 1016d13f852e silence1990/docker_for_traceanomaly:v1.2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动一个容器，执行/usr/sbin/sshd</span></span><br><span class="line">docker run -d -p 9926:22 silence1990/docker_for_traceanomaly:v1.2 /usr/sbin/sshd -D</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ssh</span></span><br><span class="line">ssh root@192.168.138.3 9926</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">反过来查看dockerfile</span></span><br><span class="line">docker history xxx:xxx --no-trunc</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h3><p>dockerfile是用来构建镜像的文本文件，build过程会用到</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos <span class="comment">#FROM 基础镜像</span></span><br><span class="line"><span class="keyword">USER</span> nginx <span class="comment">#USER 指定执行后续命令的用户和用户组，即whoami的结果</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /usr/share/nginx/html <span class="comment">#WORKDIR 指定工作目录，即pwd的结果</span></span></span><br><span class="line"><span class="comment">#RUN 在docker bulid阶段执行的命令，每执行一次都会在docker上新建一层</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum install wget</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> tar -xvf redis.tar.gz</span></span><br><span class="line"><span class="comment"># 以上执行会创建3层镜像。可简化为以下格式：</span></span><br><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum install wget \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; tar -xvf redis.tar.gz</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> index.html /usr/share/nginx/html/index.html <span class="comment">#COPY 从宿主机目录中复制文件或者目录到容器里指定路径。</span></span></span><br><span class="line"><span class="keyword">ENV</span> VER=<span class="number">1.12</span>.<span class="number">2</span> <span class="comment">#ENV 设置环境变量</span></span><br><span class="line"><span class="comment">#CMD 在docker run 时运行的指令</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build . -t docker.io/tzl/nginx:v1.12.2</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h3><p>主机上创建一个名为docker0的虚拟网桥</p>
<p>Docker使用了Linux的Namespaces技术来进行资源隔离</p>
<ul>
<li>host模式，使用–net&#x3D;host指定。容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace</li>
<li>container模式，使用–net&#x3D;container:NAME_or_ID指定。指定新创建的容器和已经存在的一个容器共享同一个Network Namespace</li>
<li>none模式，使用–net&#x3D;none指定。容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。</li>
<li>bridge模式（默认），使用–net&#x3D;bridge指定。为每一个容器分配Network Namespace、设置IP等，在主机上创建一对虚拟网卡veth pair设备，Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0（容器中的网卡），另一端在主机中以vethxxx这样类似的名字命名，并将这个网络设备加入到docker0网桥中</li>
</ul>
<hr>
<h3 id="架构原理"><a href="#架构原理" class="headerlink" title="架构原理"></a>架构原理</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhangxingeng/p/11236968.html">参考链接</a></p>
<ul>
<li><p>Docker 并不像KVM， Virtualbox，VMware那样虚拟出机器的各个硬件，Docker仅仅在同一操作系统中对应用实现资源分配并且实现应用之间的隔离</p>
</li>
<li><p>docker本质是宿主机的一个进程，通过cgroup进行资源限制、记录、调整，通过namespace进行内核环境隔离，通过cow(写时复制)实现高效文件操作</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/misterchi/article/details/78924896?spm=1001.2014.3001.5501">namespace</a>是linux内核实现的技术，可隔离7种namespace</p>
<table>
<thead>
<tr>
<th>Namespace</th>
<th>宏</th>
<th>隔离内容</th>
</tr>
</thead>
<tbody><tr>
<td>Cgroup</td>
<td>CLONE_NEWCGROUP</td>
<td>Cgroup root directory</td>
</tr>
<tr>
<td>IPC</td>
<td>CLONE_NEWIPC</td>
<td>System V IPC, POSIX message queues</td>
</tr>
<tr>
<td>Network</td>
<td>CLONE_NEWNET</td>
<td>Network devices, stacks, ports, etc.</td>
</tr>
<tr>
<td>Mount</td>
<td>CLONE_NEWNS</td>
<td>Mount points</td>
</tr>
<tr>
<td>PID</td>
<td>CLONE_NEWPID</td>
<td>Process IDs</td>
</tr>
<tr>
<td>User</td>
<td>CLONE_NEWUSER</td>
<td>User and group IDs</td>
</tr>
<tr>
<td>UTS</td>
<td>CLONE_NEWUTS</td>
<td>Hostname and NIS domain name</td>
</tr>
</tbody></table>
<p>具体的，Namespace API与三个系统调用<code>clone()</code>，<code>unshare()</code>和<code>setns()</code>以及一些 <code>/proc</code>文件相关。</p>
<p><code>ll /proc/$$/ns</code>：可列出当前进程在其ns上的操作句柄的inode链接</p>
<p>PID namespace使容器之间的进程树互不可见</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/misterchi/article/details/78947459?spm=1001.2014.3001.5501">Mount namespace</a>隔离了名称空间中的进程所看到的挂载点列表</p>
<p>docker目前未使用<a target="_blank" rel="noopener" href="https://blog.csdn.net/misterchi/article/details/79047213?spm=1001.2014.3001.5501">user namespace</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/misterchi/article/details/79154031?spm=1001.2014.3001.5501">cgroup</a>：API以一个伪文件系统的方式实现。细粒度到线程级别。运行用户态代码操作cgroup</p>
<ul>
<li><p>task：系统的一个进程</p>
</li>
<li><p>control group：一组按照某种标准划分的进程</p>
</li>
<li><p>hierarchy：控制族群可以组织成 hierarchical 的形式，即mkd一棵控制族群树。控制族群树上的子节点控制族群是父节点控制族群的孩子，继承父控制族群的特定的属性</p>
</li>
<li><p>subsystem：一个子系统就是一个资源控制器，比如 cpu 子系统就是控制 cpu 时间分配的一个控制器。子系统必须attach到一个层级上才能起作用，一个子系统附加到某个层级以后，这个层级上的所有控制族群都受到这个子系统控制。</p>
</li>
<li><p>subsystem一览</p>
<table>
<thead>
<tr>
<th>名字</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>cpu</td>
<td>限制cpu使用率</td>
</tr>
<tr>
<td>cpuacct</td>
<td>统计cpu使用率</td>
</tr>
<tr>
<td>cpuset</td>
<td>绑定cgroup到指定CPUs和NUMA节点</td>
</tr>
<tr>
<td>memory</td>
<td>统计和限制cgroup的内存的使用率，包括process memory, kernel memory, 和swap</td>
</tr>
<tr>
<td>devices</td>
<td>限制cgroup创建(mknod)和访问设备的权限</td>
</tr>
<tr>
<td>freezer</td>
<td>suspend和restore一个cgroup中的所有进程。</td>
</tr>
<tr>
<td>net_cls</td>
<td>将一个cgroup中进程创建的所有网络包加上一个classid标记，用于tc和iptables。 <strong>只对发出去的网络包生效，对收到的网络包不起作用</strong></td>
</tr>
<tr>
<td>blkio</td>
<td>限制cgroup访问块设备的IO速度</td>
</tr>
<tr>
<td>perf_event</td>
<td>对cgroup进行性能监控</td>
</tr>
<tr>
<td>net_prio</td>
<td>针对每个网络接口设置cgroup的访问优先级</td>
</tr>
<tr>
<td>hugetlb</td>
<td>限制cgroup的huge pages的使用量</td>
</tr>
<tr>
<td>pids</td>
<td>限制一个cgroup及其子孙cgroup中的总进程数</td>
</tr>
</tbody></table>
</li>
<li><p>cgroup VFS，默认挂载到<code>/sys/fs/cgroup</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">挂载一棵和所有subsystem关联的cgroup树到/sys/fs/cgroup</span></span><br><span class="line">mount -t cgroup &lt;cgroup name&gt; /sys/fs/cgroup</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载一棵和cpuset subsystem关联的cgroup树到/sys/fs/cgroup/cpuset</span></span><br><span class="line">mkdir /sys/fs/cgroup/cpuset</span><br><span class="line">mount -t cgroup -o cpuset &lt;cgroup name&gt; /sys/fs/cgroup/cpuset</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载一棵与cpu和cpuacct subsystem关联的cgroup树到/sys/fs/cgroup/cpu,cpuacct</span></span><br><span class="line">mkdir /sys/fs/cgroup/cpu,cpuacct</span><br><span class="line">mount -t cgroup -o cpu,cpuacct &lt;cgroup name&gt; /sys/fs/cgroup/cpu,cpuacct</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载一棵cgroup树，但不关联任何subsystem，下面就是systemd所用到的方式</span></span><br><span class="line">mkdir /sys/fs/cgroup/systemd</span><br><span class="line">mount -t cgroup -o none,name=systemd &lt;cgroup name&gt; /sys/fs/cgroup/systemd</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="备份还原"><a href="#备份还原" class="headerlink" title="备份还原"></a>备份还原</h3><p>目前有一个工具CRIU可以做到，<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38669561/article/details/98183545">参考链接</a></p>
<ul>
<li><p>用python操作CRIU，其实是CRIU会有一个socket，python再通过protobuf格式向该socket传一个请求。请求的options见<a target="_blank" rel="noopener" href="https://github.com/checkpoint-restore/criu/blob/cbaa59976dbf9db618a7bbf3e9f175f40bba72bc/images/rpc.proto">criu&#x2F;images&#x2F;rpc.proto</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pycriu.criu <span class="keyword">as</span> criu</span><br><span class="line"><span class="keyword">import</span> pycriu.rpc_pb2 <span class="keyword">as</span> rpc</span><br><span class="line">c=criu()</span><br><span class="line"></span><br><span class="line">c.use_sk(<span class="string">&quot;/var/run/criu-service.socket&quot;</span>)</span><br><span class="line">req=rpc.criu_req()</span><br></pre></td></tr></table></figure></li>
</ul>
<p>安装了CRIU之后，用以下docker指令即可进行C&#x2F;R(前提是必须修改<code>/etc/docker/daemon.json</code>中的<code>&quot;experimental&quot;: &quot;true&quot;</code>)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker checkpoint create 容器名 checkpoint名</span><br><span class="line">docker start --checkpoint checkpoint名 容器名</span><br><span class="line">但是如果要迁移到其它主机，则需要把检查点文件拷贝到另一个主机存放检查点的目录</span><br></pre></td></tr></table></figure>

<p>以下是通过python api操作docker的例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#docker有python接口,pip install docker，但是这个api没有checkpoint功能</span></span><br><span class="line">doc:</span><br><span class="line">    https://docker-py.readthedocs.io/en/stable/</span><br><span class="line">    </span><br><span class="line"><span class="keyword">import</span> docker</span><br><span class="line">client=docker.from_env()</span><br><span class="line">client.containers.run(<span class="string">&quot;mariadb&quot;</span>, command=<span class="string">&quot;/bin/bash&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>[]</p>
<hr>
<h2 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h2><h3 id="etcd部署的坑"><a href="#etcd部署的坑" class="headerlink" title="etcd部署的坑"></a>etcd部署的坑</h3><p>其中一个节点启动的时候出现<code>panic: tocommit(8) ...</code>这样的故障log时，我通过删除所有节点的<code>var/lib/etcd</code>下的<code>default.etcd</code>后再重启就好了</p>
<hr>
<h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><p>不同版本的api不一样，下面这个是v3版本的，建议看help</p>
<p>etcd在键的组织上采用了层次化的空间结构(类似于文件系统中目录的概念)，用户指定的键可以为单独的名字，如：testkey，此时实际上放在根目录&#x2F;下面，也可以为指定目录结构</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">v3版本的api</span></span><br><span class="line">etcdctl put /testdir/testkey &quot;Hello world&quot;</span><br><span class="line">etcdctl get /testdir/testkey</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h2><hr>
<h3 id="社区指南"><a href="#社区指南" class="headerlink" title="社区指南"></a>社区指南</h3><p><a target="_blank" rel="noopener" href="https://github.com/ysicing/kubernetes-handbook">https://github.com/ysicing/kubernetes-handbook</a></p>
<hr>
<h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/boshen-hzb/p/7495344.html">基于DNS的服务发现原理</a></p>
<hr>
<h3 id="部署以及遇到的坑"><a href="#部署以及遇到的坑" class="headerlink" title="部署以及遇到的坑"></a>部署以及遇到的坑</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ljx1528/article/details/108465272">二进制部署流程</a></p>
<p><a href="%5B%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B%5D(https://blog.csdn.net/ljx1528/article/details/108465272)">部署流程</a></p>
<p>etcd服务启动的时候所有节点的<code>etcd.conf</code>的<code>ETCD_INIT_CLUSTER_STATE</code>都是new</p>
<p>etcd启动服务时，先启动的节点会卡住，在这段时间内需要启动其他节点的服务</p>
<p>etcd出现<code>request cluster ID mismatch</code>错误时：删除所有etcd节点的<code>data-dir</code>目录(<code>/var/lib/etcd</code>)</p>
<p>etcd出现TLS证书问题时查看一下json里面的host是否有写错</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查etcd是否正常，在任何一个节点执行以下命令</span></span><br><span class="line">ETCDCTL_API=3 /opt/etcd/bin/etcdctl --cacert=/opt/etcd/ssl/ca.pem --cert=/opt/etcd/ssl/server.pem --key=/opt/etcd/ssl/server-key.pem --endpoints=&quot;https://192.168.40.10:2379,https://192.168.40.11:2379,https://192.168.40.12:2379&quot; endpoint health</span><br></pre></td></tr></table></figure>

<p>Unable to register node “master” with API server: nodes “master” is forbidden: node “k8s-master” is not allowed to modify错误：需要删除kubelet.kubeconfig(这个文件是master认证后客户端自动生成的，如果不删除会报node节点forbidden)，重新启动着2个服务，master端重新kubectl certificate approve  name名称  就可以看到新名称。因为在master上通过kubectl get node 获得的列表中，Name显示的名称是通过客户端kubelet和proxy配置文件中hostname-override配置参数定义的，修改这2个参数为你想要的名称。</p>
<p>位置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下面这几个在/opt/kubernetes/bin</span></span><br><span class="line">kube-apiserver</span><br><span class="line">kube-scheduler</span><br><span class="line">kube-controller-manager</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下面这个在/usr/bin/</span></span><br><span class="line">kubectl</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其他</span></span><br><span class="line">/opt/kubernetes/cfg/kube-apiserver.conf</span><br><span class="line">我改成了~/k8s_ca而不是~/TLS/k8s</span><br></pre></td></tr></table></figure>

<p>生成ca的时候出现过如下WARNNG，没有管</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">This certificate lacks a &quot;hosts&quot; field. This makes it unsuitable for</span><br><span class="line">websites. For more information see the Baseline Requirements for the Issuance and Management</span><br><span class="line">of Publicly-Trusted Certificates, v.1.1.6, from the CA/Browser Forum (https://cabforum.org);</span><br><span class="line">specifically, section 10.2.3 (&quot;Information Requirements&quot;).</span><br></pre></td></tr></table></figure>

<p>主机名为k8s-master&#x2F;k8s-node1&#x2F;k8s-node2都没有改，这和系统的hostname不一致，这样不行。因为k8s会用hostname访问，DNS配置错误就会出问题！</p>
<p>在server1上配置了CNI后节点还是没有Ready，重启kubelet以及docker后发现Ready</p>
<p>kubectl所需的配置是通过&#x2F;root&#x2F;.kube&#x2F;config提供的，所以需要在root下才能运行kubectl</p>
<p><code>/opt/kubernetes/cfg/kubelet.conf</code>里的这个<code>--pod-infra-container-image=lizhenliang/pause-amd64:3.0</code>不可用</p>
<hr>
<h3 id="ubuntu上部署"><a href="#ubuntu上部署" class="headerlink" title="ubuntu上部署"></a>ubuntu上部署</h3><p>关防火墙是sudo ufw disable</p>
<hr>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/linuxk/p/10291178.html">一篇比较综合的博客</a></p>
<ul>
<li><p>Master: k8s的主控组件，对应的对象是node。master节点上主要有三个以docker的形式存在的进程:</p>
<ul>
<li>kube-apiserver</li>
<li>kube-controller-manager：管理很多 controller</li>
<li>kube-scheduler：负责 Pod 调度</li>
</ul>
</li>
<li><p>Node: 是k8s集群的机器节点。一个node就对应一个具体的物理机或者虚拟机。每个 node 上都运行三个服务：</p>
<ul>
<li>docker：处理容器操作的工具</li>
<li>kubelet：管理本node上的容器的生命周期</li>
<li>kube-proxy：管理 service 的访问入口</li>
</ul>
</li>
<li><p>Container: 是一个镜像容器，一个container是一个镜像实例</p>
</li>
<li><p>Pod: 是k8s集群的最小单元，一个pod可以包含一个或者多个container。</p>
<ul>
<li><p>每个Pod都会被指派一个唯一的IP地址。</p>
</li>
<li><p>在Pod中所有的容器能够访问共享存储卷，允许这些容器共享数据。</p>
</li>
<li><p>同一个Pod中的容器共享存储、网络和命名空间。对于应用而言，pod可看做逻辑主机。</p>
</li>
</ul>
<p>默认只能在同一个k8s集群中可见。</p>
</li>
<li><p>Service: 多个相同的pod组成一个服务，统一对外提供服务。</p>
<ul>
<li>服务有Type属性：<ul>
<li>ClusterIP(默认)：Service 只能从集群内访问</li>
<li>NodePort：可以使用<code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code> 从集群外部访问 Service</li>
<li>LoadBalancer.</li>
</ul>
</li>
</ul>
</li>
<li><p>Volume: 存储卷，pod对外暴露的共享目录，它可以挂载在宿主机上，这样就能让同node上多个pod共享一个目录。</p>
</li>
<li><p>Replication Controller: 用于控制pod集群的控制器，可以制定各种规则来让它控制一个service中的多个pod的创建和消亡, 很多地方简称为rc。</p>
</li>
<li><p>ReplicaSet：副本集</p>
</li>
<li><p>Namespace: 命名空间，用于将一个k8s集群隔离成不同的空间，pod, service, rc, volume 都可以在创建的时候指定其namespace。</p>
</li>
<li><p>StatefulSet: 部署有状态应用，比如一个主从的mysql集群就是有状态集群，需要先启动主再启动从，这就是一种有状态的集群。</p>
</li>
<li><p>Persistent Volume: 持久存储卷。之前说的volume是挂载在一个pod上的，多个pod(非同node)要共享一个网络存储，就需要使用持久存储卷，简称为pv。</p>
</li>
<li><p>Persistent Volume Claim: 持久存储卷声明。他是为了声明pv而存在的，一个持久存储，先申请空间，再申明，才能给pod挂载volume，简称为pvc。</p>
</li>
<li><p>Label: 标签。我们可以给大部分对象概念打上标签，然后可以通过selector进行集群内标签选择对象概念，并进行后续操作。</p>
</li>
<li><p>Secret: 私密凭证。密码保存在pod中其实是不利于分发的。k8s支持我们创建secret对象，并将这个对象打到pod的volume中，pod中的服务就以文件访问的形式获取密钥。</p>
</li>
<li><p>EndPoint: 用于记录 service 和 pod 访问地址的对应关系。只有 service 配置了 selector, endpoint controller 才会自动创建endpoint对象。</p>
</li>
<li><p>emptyDir卷：</p>
<p>当 Pod 指定到某个节点上时,首先创建的是一个 emptyDir 卷,并且只要 Pod 在该节点上运行,卷就一直存在。 就像它的名称表示的那样,卷最初是空的。 尽管Pod 中的容器挂载 emptyDir 卷的路径可能相同也可能不同,但是这些容器都可以读写 emptyDir 卷中相同的文件。 当 Pod 因为某些原因被从节点上删除时,emptyDir 卷中的数据也会永久删除。<br>emptyDir 的使用场景：<br>​	缓存空间,例如基于磁盘的归并排序。为耗时较长的计算任务提供检查点,以便任务能方便地从崩溃前状态恢复执行。在 Web 服务器容器服务数据时,保存内容管理器容器获取的文件。默认情况下, emptyDir 卷存储在支持该节点所使用的介质上;这里的介质可以是磁盘或 SSD 或网络存储,这取决于您的环境。 但是,您可以将emptyDir.medium 字段设置为 “Memory”,以告诉 Kubernetes 为您安装 tmpfs(基于内存的文件系统)。虽然tmpfs 速度非常快,但是要注意它与磁盘不同。 tmpfs 在节点重启时会被清除,并且您所写入的所有文件都会计入容器的内存消耗,受容器内存限制约束。</p>
</li>
<li><p>nodePort：外部流量访问k8s集群service入口的一组方式（另一种方式是LoadBalaner），即<code>nodeIP:nodePort</code>是提供给外部流量访问k8s集群中service的入口。比如外部用户要访问k8s集群中的一个Web应用，那么我们可以配置对应service的<code>type=NodePort</code>，<code>nodePort=30001</code>。其他用户就可以通过浏览器<code>http://node:30001</code>访问到该web服务。而数据库等服务可能不需要被外界访问，只需被内部服务访问即可，那么我们就不必设置service的NodePort。</p>
</li>
<li><p>port：k8s集群内部服务之间访问service的入口。即<code>cluseterIP:port</code>是service保留在clusterIP上的端口</p>
</li>
<li><p>targetPort：容器的端口(最终流量的端口)。targrtPort是pod上的端口。从port和nodePort上来的流量，经过kube-proxy流入到后端的pod的targetPort上，最终进入容器。与制作容器时暴露的端口一致（使用DockerFile中的EXPOSE）</p>
</li>
<li><p>containerPort：pod内部容器的端口，targetPort映射到containerPort。</p>
</li>
<li><p>nodeSelector：通过kubernetes的label-selector机制进行节点选择，由scheduler调度策略<code>MatchNodeSelector</code>进行label匹配，使pod被调度到符合label描述的目标节点上</p>
</li>
<li><p>nodeName：用于强制约束将Pod调度到指定的Node节点上</p>
</li>
</ul>
<hr>
<h3 id="操作工具-kubectl"><a href="#操作工具-kubectl" class="headerlink" title="操作工具 kubectl"></a>操作工具 kubectl</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">命令后面加 --<span class="built_in">help</span>可以显示帮助</span></span><br><span class="line">kubectl get cs #查看master组件的健康状态</span><br><span class="line">kubectl version #Client指kubectl，Server指K8s</span><br><span class="line">kubectl get nodes #显示node</span><br><span class="line">kubectl create deployment #部署应用</span><br><span class="line">kubectl describe pods #显示pod的详细信息</span><br><span class="line">kubectl logs $POD_NAME #显示日志</span><br><span class="line">kubectl exec -ti $POD_NAME -- bash #进入一个pod的bash</span><br><span class="line">kubectl expose #将资源暴露为新的Kubernetes Service</span><br><span class="line">kubectl label pod $POD_NAME version=v1 #给一个pod打一个标签：version=v1</span><br><span class="line">kubectl get rs #列出副本集(ReplicaSet)</span><br><span class="line">kubectl scale #缩放某个Deployment</span><br><span class="line">kubectl set image #设置某个Deployment的镜像，可用于滚动更新一个Deployment中的应用</span><br><span class="line">kubectl rollout #更新的回滚</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">部署java微服务的例子</span></span><br><span class="line">mvn package -pl system #用maven构建名为system的微服务项目</span><br><span class="line">mvn package -pl inventory #用maven构建名为inventory的微服务项目</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#然后需要编写kubernetes.yaml</span></span></span><br><span class="line">kubectl apply -f kubernetes.yaml #应用yaml进行资源配置</span><br><span class="line">kubectl delete -f kubernetes.yaml #应用yaml取消资源配置</span><br><span class="line">kubectl wait --for=condition=ready pod -l app=inventory #检查pod是否已经准备好</span><br><span class="line">kubectl create configmap #创建一个ConfigMap</span><br><span class="line">kubectl create secret #创建一个secret(用以配置敏感信息，如凭证)</span><br><span class="line">kubectl replace --force -f kubernetes.yaml #更新deployment</span><br></pre></td></tr></table></figure>

<h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><a target="_blank" rel="noopener" href="https://www.luozhiyun.com/archives/tag/%e6%b7%b1%e5%85%a5k8s">深入k8s博客</a></p>
<p>Kubernetes平台由6个组件组成：apiserver、scheduler、controller-manager、kubelet、kube-proxy、etcd</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/XIkQdh5gnr-KJhuFHboNag">安全认证机制</a></p>
<h3 id="k8s网络如何实现跨主机"><a href="#k8s网络如何实现跨主机" class="headerlink" title="k8s网络如何实现跨主机"></a>k8s网络如何实现跨主机</h3><ul>
<li>docker-compose只能编排单机的，k8s和docker-swarm则可以跨主机管理容器，需要好好了解如何实现</li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2090641">k8s跨主机通信</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/388742230">linux中的TUN与TAP是什么</a></li>
</ul>
<hr>
<h2 id="Istio"><a href="#Istio" class="headerlink" title="Istio"></a>Istio</h2><p><a target="_blank" rel="noopener" href="https://www.servicemesher.com/istio-handbook/">https://www.servicemesher.com/istio-handbook/</a></p>
<hr>
<h2 id="elastic-search"><a href="#elastic-search" class="headerlink" title="elastic search"></a>elastic search</h2><ul>
<li><a href="%60https://www.elastic.co/guide/en/elasticsearch/reference/5.6/index.html%60">es5.6的reference</a></li>
</ul>
<h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul>
<li>document: 基础单元，相当于关系数据库的一行, 用JSON表示</li>
<li>index: 是一堆document组成的集合, index通过一个名字标识，这个名字必须全都是小写字母</li>
<li>type: document的类型</li>
<li>shards: 同一个index可以分布在不同的node上，这需要划分，而这些划分就叫做shard</li>
<li>replica shard或叫replica: 用作备份的副本</li>
<li>mapping: 定义如何存储和索引一个document以及它所包含的field的过程</li>
<li>aliases: 一组data stream或index的别名</li>
</ul>
<h3 id="REST-API"><a href="#REST-API" class="headerlink" title="REST API"></a>REST API</h3><ul>
<li>功能<ul>
<li>检查cluster, node, index的health. status以及statistics</li>
<li>管理cluster, node, index data以及metadata</li>
<li>CRUD</li>
<li>高级搜索: paging, sorting, filtering, scripting, aggregations</li>
</ul>
</li>
<li>具体格式<ul>
<li>检查集群健康: <code>curl -X GET &quot;localhost:9200/_cat/health?v&amp;pretty&quot;</code>，有三种颜色状态：green, yellow(没有一些replica), red</li>
<li>获取node: <code>curl -X GET &quot;localhost:9200/_cat/nodes?v&amp;pretty&quot;</code></li>
<li>获取所有index(indices): <code>curl -X GET &quot;localhost:9200/_cat/indices?v&amp;pretty&quot;</code></li>
<li>创建一个叫做customer的index: <code>curl -X PUT &quot;localhost:9200/customer?pretty&amp;pretty&quot;</code></li>
<li>向customer这个index添加一个type为external, id为1的document, 需要注意的是，如果这个index没创建过也是可以直接加document的，会自动创建: <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT &quot;localhost:9200/customer/external/1?pretty&amp;pretty&quot; -H &#x27;Content-Type: application/json&#x27; -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#x27;</span><br></pre></td></tr></table></figure>
response如下<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;_index&quot; : &quot;customer&quot;,</span><br><span class="line">&quot;_type&quot; : &quot;external&quot;,</span><br><span class="line">&quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">&quot;_version&quot; : 1,</span><br><span class="line">&quot;result&quot; : &quot;created&quot;,</span><br><span class="line">&quot;_shards&quot; : &#123;</span><br><span class="line">  &quot;total&quot; : 2,</span><br><span class="line">  &quot;successful&quot; : 1,</span><br><span class="line">  &quot;failed&quot; : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;created&quot; : true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在customer这个index中获取type为external, id为1的document: <code>curl -X GET &quot;localhost:9200/customer/external/1?pretty&amp;pretty&quot;</code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;_index&quot; : &quot;customer&quot;,</span><br><span class="line">&quot;_type&quot; : &quot;external&quot;,</span><br><span class="line">&quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">&quot;_version&quot; : 1,</span><br><span class="line">&quot;found&quot; : true,</span><br><span class="line">&quot;_source&quot; : &#123;</span><br><span class="line">   &quot;name&quot;: &quot;John Doe&quot; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
结果里的<code>found</code>表明是否找到, <code>_source</code>则是完整的JSON</li>
<li>删除一个index<code>curl -X DELETE &quot;localhost:9200/customer?pretty&amp;pretty&quot;</code></li>
<li>修改也是直接put</li>
<li>ID是可选的，如果不指定需要用POST，ES会产生一个随机的ID给document<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST &quot;localhost:9200/customer/external?pretty&amp;pretty&quot; -H &#x27;Content-Type: application/json&#x27; -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;Jane Doe&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#x27;</span><br></pre></td></tr></table></figure></li>
<li>ES的update操作都是删掉旧的再创建一个新的, 更新的例子<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST &quot;localhost:9200/customer/external/1/_update?pretty&amp;pretty&quot; -H &#x27;Content-Type: application/json&#x27; -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;: &#123; &quot;name&quot;: &quot;Jane Doe&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x27;</span><br></pre></td></tr></table></figure></li>
<li>通过script进行更新操作<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST &quot;localhost:9200/customer/external/1/_update?pretty&amp;pretty&quot; -H &#x27;Content-Type: application/json&#x27; -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot; : &quot;ctx._source.age += 5&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#x27;</span><br></pre></td></tr></table></figure>
<code>ctx._source</code>指的就是当前的document的内容</li>
<li><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/docs-update-by-query.html">类似SQL的update by query操作</a></li>
<li>删除document: <code>curl -X DELETE &quot;localhost:9200/customer/external/2?pretty&amp;pretty&quot;</code></li>
<li>批处理API, 批量添加两个type为external的document到名为customer的index中:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST &quot;localhost:9200/customer/external/_bulk?pretty&amp;pretty&quot; -H &#x27;Content-Type: application/json&#x27; -d&#x27;</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:&quot;1&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;: &quot;John Doe&quot; &#125;</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:&quot;2&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;: &quot;Jane Doe&quot; &#125;</span><br><span class="line">&#x27;</span><br></pre></td></tr></table></figure></li>
<li><strong>Search API</strong>有两种方式，一种是放在URI上，一种是放在请求体内</li>
<li><code>curl -X GET &quot;localhost:9200/bank/_search?q=*&amp;sort=account_number:asc&amp;pretty&amp;pretty&quot;</code><br><code>q=*</code>表示匹配这个index的所有document<br><code>sort=account_number:asc</code>表示按照<code>account_number</code>这个field升序排列<br>response如下<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;took&quot; : 63,</span><br><span class="line">  &quot;timed_out&quot; : false,</span><br><span class="line">  &quot;_shards&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 5,</span><br><span class="line">    &quot;successful&quot; : 5,</span><br><span class="line">    &quot;skipped&quot; : 0,</span><br><span class="line">    &quot;failed&quot; : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;hits&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 1000,</span><br><span class="line">    &quot;max_score&quot; : null,</span><br><span class="line">    &quot;hits&quot; : [ &#123;</span><br><span class="line">      &quot;_index&quot; : &quot;bank&quot;,</span><br><span class="line">      &quot;_type&quot; : &quot;account&quot;,</span><br><span class="line">      &quot;_id&quot; : &quot;0&quot;,</span><br><span class="line">      &quot;sort&quot;: [0],</span><br><span class="line">      &quot;_score&quot; : null,</span><br><span class="line">      &quot;_source&quot; : &#123;&quot;account_number&quot;:0,&quot;balance&quot;:16623,&quot;firstname&quot;:&quot;Bradshaw&quot;,&quot;lastname&quot;:&quot;Mckenzie&quot;,&quot;age&quot;:29,&quot;gender&quot;:&quot;F&quot;,&quot;address&quot;:&quot;244 Columbus Place&quot;,&quot;employer&quot;:&quot;Euron&quot;,&quot;email&quot;:&quot;bradshawmckenzie@euron.com&quot;,&quot;city&quot;:&quot;Hobucken&quot;,&quot;state&quot;:&quot;CO&quot;&#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      &quot;_index&quot; : &quot;bank&quot;,</span><br><span class="line">      &quot;_type&quot; : &quot;account&quot;,</span><br><span class="line">      &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">      &quot;sort&quot;: [1],</span><br><span class="line">      &quot;_score&quot; : null,</span><br><span class="line">      &quot;_source&quot; : &#123;&quot;account_number&quot;:1,&quot;balance&quot;:39225,&quot;firstname&quot;:&quot;Amber&quot;,&quot;lastname&quot;:&quot;Duke&quot;,&quot;age&quot;:32,&quot;gender&quot;:&quot;M&quot;,&quot;address&quot;:&quot;880 Holmes Lane&quot;,&quot;employer&quot;:&quot;Pyrami&quot;,&quot;email&quot;:&quot;amberduke@pyrami.com&quot;,&quot;city&quot;:&quot;Brogan&quot;,&quot;state&quot;:&quot;IL&quot;&#125;</span><br><span class="line">    &#125;, ...</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>took</code>表示消耗多少ms<br><code>timed_out</code>表示是否超时<br><code>_shards</code>表示搜了多少个shard<br><code>hits</code>结果<br><code>hits.total</code>document条目总数<br><code>hits.hits</code>实际结果，默认是搜索10个document<br><code>hits.sort</code>排序的key，如果没有则按score排序?<br><code>hits._score</code>和<code>max_score</code>先不用管这个</li>
<li>与上面等价的放在请求体内的格式<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET &quot;localhost:9200/bank/_search?pretty&quot; -H &#x27;Content-Type: application/json&#x27; -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123; &quot;account_number&quot;: &quot;asc&quot; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">&#x27;</span><br></pre></td></tr></table></figure></li>
<li>匹配<code>address</code>包含”mill”或”lane”的document，从第10个开始挑10个结果, 且结果的<code>_source</code>只包含<code>[&quot;account_number&quot;, &quot;balance&quot;]</code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET &quot;localhost:9200/bank/_search?pretty&quot; -H &#x27;Content-Type: application/json&#x27; -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match&quot;: &#123;&quot;address&quot;: &quot;mill lane&quot;&#125; &#125;,</span><br><span class="line">  &quot;from&quot;: 10,</span><br><span class="line">  &quot;size&quot;: 10,</span><br><span class="line">  &quot;sort&quot;: &#123;&quot;balance&quot;: &#123;&quot;order&quot;: &quot;desc&quot;&#125;&#125;,</span><br><span class="line">  &quot;_source&quot;: [&quot;account_number&quot;, &quot;balance&quot;]</span><br><span class="line">&#125;</span><br><span class="line">&#x27;</span><br></pre></td></tr></table></figure></li>
<li><code>&quot;query&quot;: &#123; &quot;match_phrase&quot;: &#123; &quot;address&quot;: &quot;mill lane&quot; &#125;</code>不是匹配包含”mill”或”lane”，而是匹配”mill lane”</li>
<li>布尔查询, <code>must</code>是全都满足, <code>should</code>是满足任意一个, <code>must_not</code>是全部不满足<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET &quot;localhost:9200/bank/_search?pretty&quot; -H &#x27;Content-Type: application/json&#x27; -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;address&quot;: &quot;mill&quot; &#125; &#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;address&quot;: &quot;lane&quot; &#125; &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;address&quot;: &quot;mill&quot; &#125; &#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;address&quot;: &quot;lane&quot; &#125; &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;must_not&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;address&quot;: &quot;mill&quot; &#125; &#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;address&quot;: &quot;lane&quot; &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x27;</span><br></pre></td></tr></table></figure></li>
<li><code>_score</code>标识了查询结果的相关性, 分数越高的document越相关</li>
<li>range查询balance在[20000,30000]的document<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET &quot;localhost:9200/bank/_search?pretty&quot; -H &#x27;Content-Type: application/json&#x27; -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;range&quot;: &#123;</span><br><span class="line">          &quot;balance&quot;: &#123;</span><br><span class="line">            &quot;gte&quot;: 20000,</span><br><span class="line">            &quot;lte&quot;: 30000</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x27;</span><br></pre></td></tr></table></figure></li>
<li>聚合操作<br><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/search-aggregations.html">聚合API文档</a><br>一般分为bucketing, metric, matrix, pipeline四种类别的聚合函数<br>常用聚合函数<ul>
<li>bucketing: <code>histogram</code>, <code>date_histogram</code>, <code>terms</code>, <code>range</code>…</li>
<li>metrics: <code>avg</code>, <code>max</code>, <code>min</code>, <code>sum</code>, <code>count</code>, <code>percentiles</code>,  <code>stats</code>(同时返回前面那一堆聚合量), <code>top_hits</code>, <code>value_count</code>…</li>
<li>matrix: <code>matrix_stats</code>返回指定field的一些统计数据<ul>
<li>count, mean, variance, skewness等</li>
</ul>
</li>
<li>暂略，详见api文档</li>
</ul>
</li>
<li>以下是一个名为”group_by_state”的聚合,聚合函数是”terms”,聚合的key是state<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET &quot;localhost:9200/bank/_search?pretty&quot; -H &#x27;Content-Type: application/json&#x27; -d&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 0,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;group_by_state&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;state.keyword&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h2 id="flink"><a href="#flink" class="headerlink" title="flink"></a>flink</h2><ul>
<li>流数据处理引擎  </li>
<li><a target="_blank" rel="noopener" href="https://ashiamd.github.io/docsify-notes/#/study/BigData/Flink/">参考链接</a>  </li>
<li>框架的代码语法看看就知道怎么写了，毕竟都是框架</li>
<li>关键概念：窗口(window)、水位(watermark)、状态(state)、检查点(checkpoint)</li>
<li>窗口<ul>
<li>时间窗口(Time Window)<ul>
<li>滚动时间窗口(thumbling window)</li>
<li>滑动时间窗口(sliding window)</li>
</ul>
</li>
<li>会话窗口<ul>
<li>计数窗口(Count Window)</li>
<li>滚动计数窗口</li>
<li>滑动计数窗口</li>
</ul>
</li>
<li>API此略</li>
</ul>
</li>
<li>水位<ul>
<li>时间语义：<ul>
<li>Event Time：事件创建时间</li>
<li>Ingestion Time：数据进入Flink的时间</li>
<li>Processing Time：执行操作算子的本地系统时间，与机器相关</li>
</ul>
</li>
<li>获取Event Time通常需要数据带有时间戳</li>
<li>由于网络传输以及并行处理，到达flink的数据可能会迟到或乱序，因此针对这个问题引入一些手段</li>
<li>Flink对于迟到数据有三层保障，保障顺序如下：<ul>
<li>WaterMark &#x3D;&gt; 某个窗口边界等于watermark时开启该窗口的运算</li>
<li>allowedLateness &#x3D;&gt; 允许迟到(ProcessingTime超时，但是EventTime没超时)，当(到来数据的时间戳减去水位)超过这个时间则会关闭窗口</li>
<li>sideOutputLateData &#x3D;&gt; 超过迟到时间，另外捕获至边路输出，之后得自己进行批处理来合并先前的数据</li>
</ul>
</li>
<li>水位含义：watermark是一条特殊的数据记录，表明“eventTime-容忍范围”已经到多少了<br>比如说：假设窗口大小为5容忍数据迟到3s，那么，对于如下数据流(数字表示该数据的时间戳)<br>数据源-&gt;7-&gt;8-&gt;6-&gt;3-&gt;5-&gt;1-&gt;flink  <ul>
<li>1到来时，watermark&#x3D;max(0, 1-3)，把1放到窗口[0,5)</li>
<li>5到来时，watermark&#x3D;max(0, 5-3), 把5放到窗口[5,10)</li>
<li>3到来时, watermark&#x3D;max(2, 3-3), 把3放到窗口[0,5)  </li>
<li>6到来时，watermark&#x3D;max(2, 6-3), 把6放到窗口[5,10)</li>
<li>8到来时，watermark&#x3D;max(3, 8-3), 把8放到窗口[5,10), 同时，水位等于窗口[0,5)的边界，该窗口开始运算</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="Opentelemetry"><a href="#Opentelemetry" class="headerlink" title="Opentelemetry"></a>Opentelemetry</h2><p>trace工具</p>
<p>概念：</p>
<ul>
<li><p>Traces：记录经过分布式系统的请求活动，一个trace是spans的有向无环图</p>
</li>
<li><p>Spans：一个trace中表示一个命名的，基于时间的操作。Spans嵌套形成trace树。每个trace包含一个根span，描述了端到端的延迟，其子操作也可能拥有一个或多个子spans。</p>
</li>
<li><p>Metrics：在运行时捕获的关于服务的原始度量数据。Opentelemetry定义的metric instruments(指标工具)如下。Observer支持通过异步API来采集数据，每个采集间隔采集一个数据。</p>
<table>
<thead>
<tr>
<th>name</th>
<th>Synchronous</th>
<th>Adding</th>
<th>Monotonic</th>
</tr>
</thead>
<tbody><tr>
<td>Counter</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>UpDownCounter</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>ValueRecorder</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>SumObserver</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>UpDownSumObserver</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>ValueObserver</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
</tbody></table>
</li>
<li><p>Context：一个span包含一个<strong>span context</strong>，它是一个全局唯一的标识，表示每个span所属的唯一的请求，以及跨服务边界转移trace信息所需的数据。OpenTelemetry 也支持<strong>correlation context</strong>，它可以包含用户定义的属性。<strong>correlation context</strong>不是必要的，组件可以选择不携带和存储该信息。</p>
</li>
<li><p>Context propagation：表示在不同的服务之间传递上下文信息，通常通过HTTP首部。 Context propagation是Opentelemetry系统的关键功能之一。除了tracing之外，还有一些有趣的用法，如，执行A&#x2F;B测试。OpenTelemetry支持通过多个协议的Context propagation来避免可能发生的问题，但需要注意的是，在自己的应用中最好使用单一的方法。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://opentelemetry.io/docs/java/manual_instrumentation/">java API</a></p>
<hr>
<h2 id="Delta压缩"><a href="#Delta压缩" class="headerlink" title="Delta压缩"></a>Delta压缩</h2><p>当新旧文件不在同一个host上，可以通过<a target="_blank" rel="noopener" href="https://coolshell.cn/articles/7425.html">rsync</a>算法进行压缩</p>
<p>rsync主要就是思想是把文件分块，然后计算校验和，通过校验和比较来跳过相同的块。其中为了解决位置移动，用到了滚动校验和rolling checksum</p>
<p>这个与diff很像，diff在比较两个文本文件时基于行计算校验码</p>
<hr>
<h2 id="数据库分类"><a href="#数据库分类" class="headerlink" title="数据库分类"></a>数据库分类</h2><p><a target="_blank" rel="noopener" href="https://db-engines.com/en/">DB-engine</a></p>
<ul>
<li>关系数据库：Oracle&#x2F;MySQL等</li>
<li>KV数据库：Redis&#x2F;Memcache等</li>
<li>面向文档：MongoDB等</li>
<li>时序数据库：InfluxDB&#x2F;Kdb+&#x2F;Prometheus等</li>
<li>图数据库：Neo4j等</li>
<li>搜索引擎：Elasticsearch&#x2F;Splunk&#x2F;Sphinx等</li>
<li>空间数据库：PostGIS等</li>
</ul>
<hr>
<h2 id="HTTPS-x2F-SSL-x2F-TLS"><a href="#HTTPS-x2F-SSL-x2F-TLS" class="headerlink" title="HTTPS&#x2F;SSL&#x2F;TLS"></a>HTTPS&#x2F;SSL&#x2F;TLS</h2><ul>
<li>SSL：（Secure Socket Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL记录协议和SSL握手协议。</li>
<li>TLS：（Transport Layer Security，传输层安全协议），用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。</li>
</ul>
<hr>
<h2 id="微信的过载控制"><a href="#微信的过载控制" class="headerlink" title="微信的过载控制"></a>微信的过载控制</h2><p>腾讯写的一篇关于<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/84415217">微信过载控制机制的文章</a></p>
<p>论文名为Overload Control for Scaling WeChat Microservices</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c7cc62b9923a">微信的备注功能是在客户端处理的</a></p>
<hr>
<h2 id="一个分布式博客"><a href="#一个分布式博客" class="headerlink" title="一个分布式博客"></a>一个分布式博客</h2><p><a target="_blank" rel="noopener" href="https://alvaro-videla.com/2015/12/learning-about-distributed-systems.html">https://alvaro-videla.com/2015/12/learning-about-distributed-systems.html</a></p>
<h3 id="timing-model"><a href="#timing-model" class="headerlink" title="timing model"></a>timing model</h3><ul>
<li>synchronous<ul>
<li>假设可以估计进程的速度，虽然不现实，但可以达到理论结果</li>
</ul>
</li>
<li>asynchronous<ul>
<li>不保证可以估计进程的速度，比较接近现实，但允许进程一直卡住。所以这个模型的问题就是如何估计一个进程的活跃状态，因为一个进程有可能已经崩了或者只是一直卡住。</li>
</ul>
</li>
<li>partially synchronous<ul>
<li>组件有些关于时间的信息，能够估计一个消息要发多久或者一个进程要等多久才会执行到下一步</li>
</ul>
</li>
</ul>
<h3 id="ipc"><a href="#ipc" class="headerlink" title="ipc"></a>ipc</h3><ul>
<li>消息传递<ul>
<li>可以利用消息传递算法构建分布式共享内存的对象？</li>
</ul>
</li>
<li>共享内存</li>
</ul>
<h3 id="failure-mode"><a href="#failure-mode" class="headerlink" title="failure mode"></a>failure mode</h3><ul>
<li>crash-stop：一旦出错不再恢复</li>
<li>crash-recovery：可以恢复</li>
<li>omission failure：无法收发消息</li>
<li>Byzantine&#x2F;arbitrary failures：进程可以发送错误信息给peer</li>
</ul>
<h3 id="failure-detectors"><a href="#failure-detectors" class="headerlink" title="failure detectors"></a>failure detectors</h3><ul>
<li>根据time mode和failure mode讨论</li>
<li>举了心跳机制的例子</li>
</ul>
<h3 id="leader-election"><a href="#leader-election" class="headerlink" title="leader election"></a>leader election</h3><ul>
<li>确保一致性</li>
<li>例如：Paxos、Raft、Zab协议</li>
<li>有leader会导致节点非对称，带来瓶颈问题</li>
</ul>
<h3 id="consensus"><a href="#consensus" class="headerlink" title="consensus"></a>consensus</h3><ul>
<li><a target="_blank" rel="noopener" href="http://research.microsoft.com/en-us/um/people/lamport/pubs/reaching.pdf">Reaching Agreement in the Presence of Faults</a> 提出一致性问题</li>
<li>一致性算法要求：<ul>
<li><strong>Termination</strong>: Every correct process eventually decides some value.</li>
<li><strong>Validity</strong>: If a process decides <em>v</em>, then <em>v</em> was proposed by some process.</li>
<li><strong>Integrity</strong>: No process decides twice.</li>
<li><strong>Agreement</strong>: No two correct processes decide differently.</li>
</ul>
</li>
</ul>
<h3 id="Quorums"><a href="#Quorums" class="headerlink" title="Quorums"></a>Quorums</h3><ul>
<li>法定人数：指能容错必须满足的最低副本个数</li>
<li>性能仍然是科学家研究的领域。如何达到consensus的同时，又能最大化提高性能</li>
</ul>
<hr>
<h3 id="一个监控系统介绍博客"><a href="#一个监控系统介绍博客" class="headerlink" title="一个监控系统介绍博客"></a>一个监控系统介绍博客</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/imyalost/p/14989371.html">https://www.cnblogs.com/imyalost/p/14989371.html</a></p>
<hr>
<h2 id="服务网格"><a href="#服务网格" class="headerlink" title="服务网格"></a>服务网格</h2><p>一种软件架构风格</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/61901608">发展历程</a></p>
<ol>
<li>TCP出现前：服务需要<strong>自己处理底层通信</strong></li>
<li>TCP出现后：服务<strong>不需要处理网络传输底层逻辑</strong></li>
<li>第一代微服务：分布式系统出现。出现了些新概念：熔断、LB、服务发现、鉴权、配额、trace、监控等等，这些<strong>新概念需要服务处理</strong></li>
<li>第二代微服务：<strong>微服务开发框架</strong>出现，如Spring Cloud。这些框架实现了上述需要的新概念的细节</li>
<li>第一代service mesh：边车(代理)模式出现，如Linkerd，Envoy，NginxMesh。微服务框架是把新概念都实现了，而这些<strong>边车则是把概念都实现的同时把他们作为一个和其他微服务对等的微服务</strong>。边车(代理)组成一个网格。</li>
<li>第二代Service mesh：出现了能集中控制边车的<strong>控制面板</strong>，如Istio。</li>
</ol>
<hr>
<h2 id="LLVM"><a href="#LLVM" class="headerlink" title="LLVM"></a>LLVM</h2><p>LLVM(Low Level Virtual machine)是一个编译器后端。可以基于LLVM提供的功能开发自己的模块，并集成在LLVM系统上，增加它的功能，或者就单纯自己开发软件工具，而利用LLVM来支撑底层实现。</p>
<h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><ul>
<li>前端：LLVM需要一个前端，一开始是gcc，后来Apple开发了Clang取代了gcc</li>
<li>LLVM IR：LLVM的中间表示<ul>
<li><a target="_blank" rel="noopener" href="https://llvm.org/docs/LangRef.html">doc</a></li>
</ul>
</li>
<li>LLVM的IR有三种表示：<ul>
<li>可读的IR(介于高级语言与汇编之间)，后缀为<code>.ll</code></li>
<li>不可读的二进制IR，后缀为<code>.bc</code></li>
<li>只保存在内存中的IR，不像gcc每个阶段都生成中间文件</li>
</ul>
</li>
<li>LLVM IR linker：IR的链接器</li>
<li>LLVM backend：LLVM的后端，是整个项目的核心，包括编译、汇编、链接，后端的输入是IR、输出是汇编文件或目标码。</li>
<li>Clang工具：命令行上调用的clang工具是一个驱动程序，该程序调用clang和LLVM的各种库，通过这个程序可以把整个编译器的功能串起来</li>
<li>LLVM工具<ul>
<li><code>opt</code>：一个IR级别做优化的工具，输入输出都是IR</li>
<li><code>llc</code>：微观意义上的LLVM编译器，输入是IR，输出是汇编(<code>-filetype=asm</code>)或目标文件(<code>-filetype=obj</code>)</li>
<li><code>llvm-mc</code>：微观意义上的LLVM汇编器，输入汇编文件，输出目标文件，同时可以反汇编(–disassemble)</li>
<li><code>lli</code>：LLVM IR的解释器，也是一个JIT编译器</li>
<li><code>llvm-link</code>：IR级别的链接器。</li>
<li><code>llvm-as</code>：LLVM IR的汇编器，输入<code>.ll</code>，输出<code>.bc</code></li>
<li><code>llvm-dis</code>：LLVM的反汇编器，输入<code>.bc</code>，输出<code>.ll</code></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>CSE(Common Subexpression Elimination)：公共子表达式消去</li>
</ul>
<h3 id="kaleidoscope教程"><a href="#kaleidoscope教程" class="headerlink" title="kaleidoscope教程"></a>kaleidoscope教程</h3><p><a target="_blank" rel="noopener" href="https://llvm.org/docs/tutorial/index.html">tutorial</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/plctlab/PLCT-Open-Reports">参考链接</a></p>
<p>每一章的代码可以通过diff来比较看看有什么改变</p>
<p>关于库API，可以查找官方<a target="_blank" rel="noopener" href="https://llvm.org/doxygen/">doxygen文档</a></p>
<ul>
<li><p>第二章</p>
<ul>
<li>词法分析(Lexer)：Token枚举、gettok获取token</li>
<li>定义AST(Abstract Syntax Tree)：ExprAst基类以及节点的定义</li>
<li>语法分析(Parser)：读取<code>CurTok</code>，通过parseExpression构建AST。(有一个ParsePrimary利用switch(CurTok)调用不同的parse函数。</li>
<li>Top-Level parsing：最开始调用的handle函数，用于最外层的表达式解析。</li>
<li>BinopPrecedence：运算符优先级表，取值为[1,100]，越大越高<ul>
<li>二元运算符优先级处理，</li>
</ul>
</li>
</ul>
</li>
<li><p>第三章</p>
<ul>
<li><p>语义分析&amp;代码生成(Code Generation)：</p>
<ul>
<li><p>数据结构全局变量</p>
<ul>
<li><p><code>TheContext</code>：LLVMContext针对每个线程记录了线程本地的变量</p>
</li>
<li><p><code>TheModule</code>：LLVM中存放代码段中所有函数以及全局变量的结构，可理解为IR的顶层容器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子</span></span><br><span class="line">TheMoudle.<span class="built_in">get</span>();<span class="comment">//获取当前Module</span></span><br><span class="line">TheModule-&gt;<span class="built_in">getFunction</span>(<span class="string">&quot;string&quot;</span>);<span class="comment">//获取函数string</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Builder</code>：为LLVM的IR生成提供API的对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子</span></span><br><span class="line">Builder-&gt;<span class="built_in">CreateFAdd</span>(L, R, <span class="string">&quot;addtmp&quot;</span>)</span><br><span class="line">Builder-&gt;<span class="built_in">CreateCall</span>(CalleeF, ArgsV, <span class="string">&quot;calltmp&quot;</span>);</span><br><span class="line">Builder-&gt;<span class="built_in">CreateCondBr</span>(CondV, ThenBB, ElseBB);</span><br><span class="line">Builder-&gt;<span class="built_in">GetInsertBlock</span>()-&gt;<span class="built_in">getParent</span>();</span><br><span class="line">BasicBlock *ThenBB = BasicBlock::<span class="built_in">Create</span>(*TheContext, <span class="string">&quot;then&quot;</span>, TheFunction);<span class="comment">//创建基本块</span></span><br><span class="line">Builder-&gt;<span class="built_in">SetInsertPoint</span>(ThenBB);<span class="comment">//把插入点指定到对应基本块</span></span><br><span class="line">Builder-&gt;<span class="built_in">CreateRet</span>(RetVal);</span><br><span class="line">Builder-&gt;<span class="built_in">CreatePHI</span>(Type::<span class="built_in">getDoubleTy</span>(*TheContext), <span class="number">2</span>, VarName);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>NamedValues</code>：符号表，是一个<code>std::map&lt;std::string, Value *&gt;</code></p>
</li>
</ul>
</li>
<li><p>每个AST中新增一个虚函数codegen()，对应表达式在这个函数中编写生成IR的逻辑</p>
</li>
</ul>
</li>
<li><p>Top-Level parsing and JIT Driver：</p>
<ul>
<li>顶层处理加入了代码生成的逻辑</li>
<li>这一章并没有涉及JIT，官方代码注释有问题</li>
</ul>
</li>
<li><p>@表示全局变量，%表示局部变量</p>
</li>
</ul>
</li>
<li><p>第四章——引入JIT以及优化器</p>
<ul>
<li>include中比较重要的几个文件<ul>
<li><code>KaleidoscopeJIT.h</code>：一个简单的JIT，另一篇教程有说这个</li>
<li><code>LegacyPassManager.h</code>：保存，维护，优化 Pass的执行</li>
<li><code>Verfier.h</code>：函数验证</li>
<li><code>TargerSelect.h</code>：用以确保特定类的目标被链接到主应用的执行程序</li>
</ul>
</li>
<li>新增数据结构全局变量：<ul>
<li>TheFPM：Pass管理<ul>
<li>Pass：趟。核心库提供一些Pass类去继承，通过实现它的一些方法，在多趟遍历中可以实现插桩等操作。而且LLVM的优化有很多个粒度。</li>
</ul>
</li>
<li>TheJIT：JIT</li>
<li>FunctionProtos：函数声明表，类型是<code>std::map&lt;std::string, std::unique_ptr&lt;PrototypeAST&gt;&gt;</code></li>
</ul>
</li>
<li>InitializeModuleAndPassManager负责创建一个新Module以及管理优化趟</li>
<li>定义了一个函数<code>f(a,b)</code>。如果要求在编写调用该函数(如<code>f(2,3)</code>)的代码就能做到JIT的话，则可以写一个JIT(这里是KaleidoscopeJIT)，然后在top-level-expression的代码生成(这里把函数调用视作top-level-expression)时添加module进去。这将使得调用函数的代码会经过JIT直接计算出结果(可以理解为常量折叠)并编译为简单的中间表示。编译后需要移除module，但这会使得同在一个module的函数头丢失，下次再使用JIT的时候module就缺少函数定义了。为此，Kaleidoscope的设计是每个函数都属于一个独立的module。<ul>
<li>具体的Kaleidoscope添加了一个全局函数头表FunctionProtos，该表保存最近一次函数头定义。有了这个表后，就可以在当前module中获取到之前定义过的函数头。</li>
<li>symbol resolution rule：First it searches all the modules that have already been added to the JIT, from the most recent to the oldest, to find the newest definition. If no definition is found inside the JIT, it falls back to calling “<code>dlsym(&quot;sin&quot;)</code>” on the Kaleidoscope process itself.</li>
</ul>
</li>
<li>extern调用库函数(“Library” functions)<ul>
<li>加上extern “C”后，会指示编译器这部分代码<strong>按C语言（而不是C++）的方式进行编译</strong>。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。</li>
</ul>
</li>
</ul>
</li>
<li><p>第五章——引入控制流语句</p>
<ul>
<li>提及了<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Static_single_assignment_form">SSA优化</a>，可以理解为每次为已有变量赋值(更新已声明过的变量)时，加一个下标。但是如果遇到分支，如分支1和分支2都对变量x赋值过，那么分支合并后，x的取值是不定的(x1或x2)，此时可引入一个新下标<code>x3=φ(x1, x2)</code>，然后为了确定这些φ函数要在哪里插入，并且最小化φ函数的个数，需要用到dominance frontier算法。</li>
<li>BasicBlock：控制流中的基本块<ul>
<li>LLVM IR <a target="_blank" rel="noopener" href="https://releases.llvm.org/5.0.0/docs/LangRef.html#functionstructure">requires all basic blocks to be “terminated”</a> with a <a target="_blank" rel="noopener" href="https://releases.llvm.org/5.0.0/docs/LangRef.html#terminators">control flow instruction</a> such as <strong>return</strong> or <strong>branch</strong></li>
<li><code>br</code>是分支指令，<code>br i1 &lt;cond&gt;, label &lt;iftrue&gt;, label &lt;iffalse&gt;</code>或<code>br label &lt;dest&gt;</code></li>
</ul>
</li>
<li>实现:<ul>
<li>词法分析：增加<code>if</code>、<code>then</code>、<code>else</code>和<code>for</code>、<code>in</code>关键字</li>
<li>AST<ul>
<li>IfExprAST包含Cond、Then、Else</li>
<li>ForExprAST则包含VarName,Start, End, Step, Body(对应<code>for(double VarName=Start; VarName!=End; VarName+=Step) Body</code>)</li>
</ul>
</li>
<li>语法分析以及代码生成详见代码</li>
</ul>
</li>
</ul>
</li>
<li><p>第六章——实现自定义运算符</p>
<ul>
<li>把自定义运算符视作定义一种特殊的函数<ul>
<li>例子：<code>def unary &lt;运算符&gt;(x) if x then 0 else 1;</code>以及<code>def binary &lt;运算符&gt; &lt;优先级&gt; (LHS RHS) RHS &lt; LHS</code></li>
</ul>
</li>
<li>实现：<ul>
<li>词法分析：增加<code>unary</code>和<code>binary</code>关键字</li>
<li>AST：<ul>
<li>UnaryExprAST包含Opcode，Oprand</li>
<li>BinaryExprAST包含Op，LHS，RHS</li>
<li>修改PrototypeAST(函数头)：增加<code>IsOperator</code>以及<code>Precedence</code>(优先级)相关代码</li>
</ul>
</li>
<li>语法分析：<ul>
<li>ParseUnary在ParsePrimary之上再套一层</li>
</ul>
</li>
<li>代码生成：<ul>
<li><code>UnaryExprAST::codegen()</code>是调用自定义一元运算符时产生代码的逻辑，首先会对括号内的入参<code>Oprand</code>进行代码生成，然后会根据<code>Opcode</code>在函数表中找函数，之后用IRBuilder创建一条call指令</li>
<li><code>BinaryExprAST</code>基本同上，先是对<code>LHS</code>和<code>RHS</code>进行代码生成，然后再判断是否是内置二元操作符，如果不是，则从函数表里面找函数再用IRBuilder创建一条call指令</li>
<li>此外，还需要修改<code>FunctionAST::codegen()</code>，为运算符在优先级表中添加优先级</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>第七章——实现可变变量(var关键字)</p>
<ul>
<li><p>效果：<code>var &lt;标识符&gt; [= 表达式1][, 标识符[= 表达式n]] in 表达式2</code>，表示在表达式2中前述标识符都是可变变量</p>
<p>例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Define &#x27;:&#x27; for sequencing: as a low-precedence operator that ignores operands and just returns the RHS.</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">binary</span> : <span class="number">1</span> (x y) y;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Recursive fib, we could do this before.</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">x</span>)</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">3</span>) then</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    fib(x-<span class="number">1</span>)+fib(x-<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># Iterative fib.</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fibi</span>(<span class="params">x</span>)</span><br><span class="line">  var a = <span class="number">1</span>, b = <span class="number">1</span>, c <span class="keyword">in</span></span><br><span class="line">  (<span class="keyword">for</span> i = <span class="number">3</span>, i &lt; x <span class="keyword">in</span></span><br><span class="line">     c = a + b :</span><br><span class="line">     a = b :</span><br><span class="line">     b = c) :</span><br><span class="line">  b;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Call it.</span></span><br><span class="line">fibi(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>词法分析：增加var关键字</p>
</li>
<li><p>AST：增加VarExprAST，包含</p>
<ul>
<li><code>varNames</code>：保存变量的列表，是一个结构数组<code>std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;ExprAST&gt;&gt;&gt;</code></li>
<li><code>Body</code>：可以理解为变量作用域？</li>
</ul>
</li>
<li><p>语法分析：参见ParseVarExpr，挺简单的，就是把&lt;变量名,初始值&gt;放到<code>varNames</code>中。此外还需要在ParsePrimary增加switch分支</p>
</li>
<li><p>代码生成：</p>
<ul>
<li>指令<code>alloca</code>会分配在当前函数栈帧上内存，函数结束时将自动释放</li>
<li>指令<code>store</code>会把值写入内存中的一个地址</li>
<li>指令<code>load</code>会把值从内存中的一个地址读出</li>
<li>修改<code>BinaryExprAST::codegen</code>，因为变量赋值会用到等号，所以需要针对此运算符写出具体逻辑。先获取LHS并static_cast为一个变量AST。然后利用AST获取名字再在符号表中查找变量。为了给变量赋值，需要用到<code>store</code>指令。</li>
<li>修改<code>ForExprAST::codegen()</code>，现在这个版本的for支持可变变量了，格式参见源码。首先需要在当前函数的栈上为变量获取一片内存Alloca(这玩意的类型是<code>AllocaInst *</code>，<code>AllocaInst</code>是<code>Value</code>的子类)。对变量的修改使用<code>store</code>指令，对变量的读取使用<code>load</code>指令。此外，由于语法支持覆盖外层变量，所以在操作前需要判断是否有覆盖外层变量并记录<code>OldVal</code></li>
<li>增加<code>VarExprAST::codegen()</code>，该函数处理var声明(或定义)。具体逻辑参见代码，总之就是把可变变量列表内的可变变量都用<code>store</code>指令存储到内存中并生成Body的代码。此外，由于语法支持覆盖外层变量，所以在生成body代码之前需要利用OldBindings记录旧值。函数返回body的值</li>
<li>修改<code>FunctionAST::codegen</code>：改进，实现把参数放到当前函数的栈上</li>
</ul>
</li>
<li><p>优化器：<code>InitializeModuleAndPassManager</code>增加一个Pass使得可以把alloca转为寄存器。(也就使得最终结果看不出来变量存是内存中，而是存在寄存器中)</p>
</li>
<li><p>由于引入了等号，需要在一开始增加等号优先级</p>
</li>
</ul>
</li>
<li><p>第八章——编译至目标代码</p>
<ul>
<li><p>交叉编译：在一个平台上生成另一个平台上的可执行代码</p>
</li>
<li><p>在main函数中先指明目标信息</p>
<ol>
<li><p>创建<code>TargetTriple</code>：<code>CPU-vendor-OS</code>标识交叉编译的目标系统类型，比如<code>x86_64-unknown-linux-gnu</code></p>
</li>
<li><p>调用一堆<code>Initialize</code>函数来初始化所有target</p>
</li>
<li><p>创建<code>Target</code>以及<code>TargetMachine</code>(包含了大量可以访问具体目标机器信息的接口)</p>
</li>
<li><p>设置<code>DataLayout</code></p>
</li>
<li><p>打开一个文件<code>output.o</code></p>
</li>
<li><p>发射代码<code>TheTargetMachine-&gt;addPassesToEmitFile(pass, dest, nullptr, FileType)</code></p>
</li>
<li><p>进行优化趟，ostream把数据flush到文件</p>
</li>
</ol>
</li>
<li><p>ps.演示代码用到ctrl+d，ctrl+d是输入一个EOF</p>
</li>
</ul>
</li>
</ul>
<p>第九章——增加debug信息</p>
<ul>
<li><p>概念以及说明</p>
<ul>
<li><p>源码debug：把二进制代码以及机器的状态通过格式化数据的形式呈现给程序员，教程采用的是<a target="_blank" rel="noopener" href="https://www.cnblogs.com/catch/p/3884271.html">DWARF</a>格式</p>
<p>调试信息被放在一个叫作 .debug_info 的段中，该段与 DWARF 中其它的段类似，可以看成是一个表格状的结构，表中每一条记录叫作一个 DIE(debugging information entry)</p>
</li>
<li><p>由于优化以及JIT使得问题变复杂，所以教程删除了JIT以及优化，ps：与JIT(just in time)相对的是AOT(ahead of time)</p>
</li>
<li><p>llvm中和debug有关的类命名为<code>DIxxx</code></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.few.vu.nl/~lsc300/LLVM/doxygen/classllvm_1_1DILocation.html"><code>llvm::DILocation</code></a>包括行、列、scope、filename、directory等信息</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.few.vu.nl/~lsc300/LLVM/doxygen/classllvm_1_1DIScope.html#details"><code>llvm::DIScope</code></a>对应作用域的概念,是一个比较大的基类</p>
<ul>
<li><code>llvm::DICompileUnit</code>对应DWARF的顶层section——CompileUnit的概念</li>
<li><code>llvm::DISubprogram</code>对应子程序概念，比如函数</li>
<li><code>llvm::DIType</code>：对应LLvm的类型概念</li>
</ul>
</li>
<li><p><code>llvm::DIBuilder</code>可以用来创建上述debug metadata</p>
</li>
</ul>
</li>
<li><p>具体实现</p>
<ul>
<li>新增类型为<code>DebugInfo</code>结构的<code>KSDbgInfo</code>：存放<code>llvm::DICompileUnit</code>、数据类型以及作用域栈<code>LexicalBlocks</code>的全局变量</li>
<li>新增类型为<code>SourceLocation</code>结构的两个变量<code>CurLoc</code>以及<code>LexLoc</code>用于记录当前行列</li>
<li>主要工作在main函数创建了一个DIBuilder，然后利用它创建<code>llvm::DICompileUnit</code>并绑定到<code>KSDbgInfo</code>。创建函数的两个参数分别是(源语言, DI文件)，这里源语言写的是C。此外最后记得调用DIBuilder-&gt;finalize()。</li>
<li>词法分析<ul>
<li>增加一个<code>getTokName()</code>函数，没什么用</li>
<li>增加一个<code>advance()</code>函数在读取每一个字符时都更新LexLoc</li>
</ul>
</li>
<li>AST<ul>
<li>为AST增加<code>SourceLocation</code>成员以及相应打印函数<code>dump</code>用以记录行列</li>
</ul>
</li>
<li>语法分析<ul>
<li>修改各个AST的parser：利用curLoc填充各个AST的<code>SourceLocation</code></li>
</ul>
</li>
<li>代码生成<ul>
<li>新增<code>getDoubleTy()</code></li>
<li>新增<code>emitLocation(AST)</code>：利用<code>IRBuilder-&gt;SetCurrentDebugLocation()</code>告诉IRBuilder所传入的AST的位置信息(scope，行，列)，其中scope是通过全局的Scope栈——<code>LexicalBlocks</code>来获取的，行列则通过AST的<code>SourceLocation</code>成员得到。</li>
<li>新增<code>CreateFunctionType</code>：处理函数返回值类型，返回<code>DISubroutineType</code>（<a target="_blank" rel="noopener" href="https://llvm.org/doxygen/classllvm_1_1Type.html">Type</a> array for a subprogram）</li>
<li>之后基本就是修改各个AST的<code>codegen()</code>：利用<code>emitLocation()</code>插入DI信息。需要注意的就是由于函数会改变作用域信息，所以需要利用一个全局的Scope栈——<code>LexicalBlocks</code>，在<code>emitLocation()</code>前创建一个包含函数metadata的<code>llvm::DISubprogram</code>入栈，之后再出栈。</li>
<li>对于作用域压栈，还有一个不理解的地方：在压栈后需要<code>emitLocation(nullptr)</code>，这个空位置在debug会跳过这个？</li>
<li>特别的，对于函数的局部变量，需要通过<code>DIBuilder-&gt;insertDeclare</code>()来为其创建一个debug描述符</li>
</ul>
</li>
<li>ps.上述只讨论了新增的东西，删去的东西并没有提到</li>
</ul>
</li>
</ul>
<hr>
<h3 id="buildingAJIT"><a href="#buildingAJIT" class="headerlink" title="buildingAJIT"></a>buildingAJIT</h3><p>版本对不上，放弃阅读</p>
<p>第一章</p>
<p>目标：使得代码需要时才编译</p>
<p>两个函数 </p>
<ul>
<li><code>Error addModule(std::unique_ptr&lt;Module&gt; M)</code>：添加一个IR Module到JIT中</li>
<li><code>Expected&lt;JITEvaluatedSymbol&gt; lookup()</code>：查找symbol得到指针(函数指针或变量指针)</li>
</ul>
<p>简单的原型</p>
<ul>
<li><p>ExecutionSession：为运行JIT代码提供一个context(包括字符串池、全局mutex，报错工具)</p>
</li>
<li><p>RTDyldObjectLinkingLayer：用于添加o文件到JIT</p>
</li>
<li><p>IRCompileLayer：添加LLVM模块到JIT中</p>
</li>
<li><p>DataLayout以及MangleAndInterner：用于symbol mangling(符号变形(修改符号的名字为编译器内部的名字))</p>
</li>
<li><p>ThreadSafeContext ：一个LLVMContext(先别管怎么用)</p>
</li>
<li><p>构造函数</p>
<ul>
<li>JITTargetMachineBuilder被IRCompile使用</li>
<li>ObjectLayer需要</li>
</ul>
</li>
</ul>
<hr>
<h3 id="clang源码结构"><a href="#clang源码结构" class="headerlink" title="clang源码结构"></a>clang源码结构</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tomsoft/article/details/78206637?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162822699516780366540460%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=162822699516780366540460&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-78206637.pc_v2_rank_blog_default&utm_term=clang&spm=1018.2226.3001.4450">参考链接</a></p>
<ul>
<li>ps.我写的源码注释都加了”soris”关键字，可以快速查找</li>
<li>Clang是由一系列的库构成</li>
<li>两种执行过程：以驱动程序的方式运行、作为cc1前端方式运行</li>
<li>Clang执行初期是作为driver执行的，因此，程序的入口是：<code>tools/driver/driver.cpp</code>，其<code>main</code>函数有一句判断是否有<code>&quot;-cc1&quot;</code>参数，有则直接执行并返回，否则handle一堆选项，执行命令解释，生成相容的命令行。(<code>BuildCompilation</code>并<code>ExecuteCompilation</code>)</li>
<li><code>clang::driver::Driver</code>：封装了&#x2F;从一组gcc-driver-like命令行参数构建出一个compilation过程&#x2F;的逻辑</li>
<li><code>clang::driver::Compilation</code>：为一个driver调用而生的一组task。</li>
<li>driver模式的五个阶段<ol>
<li>Parse：处理输入字符串(<code>Args</code>)解析出命令行参数(<code>clang::driver::options</code>，具体参数定义与<code>.td文件</code>(TableGen语言编写)有关?)</li>
<li>Pipeline：根据命令行参数构造编译动作序列。<code> clang::driver::Action</code>抽象了编译的每一步，可表示为编译图中的一条边，动作需要通过工具来执行，这个执行的概念就是job。具体的动作包括预处理、编译、汇编、链接等。可以通过<code>Compilation::MakeAction</code>创建一个属于某个Compilation的Action。</li>
<li>Bind：绑定Action与Tool。<code>clang::driver::Tool</code>描述了特定工具的信息，<code>clang::driver::ToolChain</code>用来获取具体某个平台的工具集合</li>
<li>Translate：调用具体工具时其参数需要适配，所以需要把driver知道的参数翻译为具体工具期望的格式</li>
<li>Execute：<code>Driver::ExecuteCompilation -&gt; Compilation::ExecuteJobs -&gt; Compilation::ExecuteCommand-&gt; Command::Execute -&gt; llvm::sys::ExecuteAndWait</code></li>
</ol>
</li>
</ul>
<hr>
<p>clang前端相关</p>
<p><a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/InternalsManual.html">官方InternalsManual</a></p>
<ul>
<li>词法分析相关(<code>clang/include/clang/Lex</code>、<code>clang/lib/Lex</code>)<ul>
<li>Preprocessor是lexer部分对外交互的主要接口，其中<code>Preprocessor::Lex</code>会返回预处理器流中的下一个<code>Token</code>。token来源有多种，lex函数通过switch调用对应种类的<code>xxxLexer-&gt;Lex()</code></li>
<li>Lexer直接处理文本</li>
<li><a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/InternalsManual.html#the-token-class">Token</a>有两类：与词法分析有关的normal token、与语法分析有关的annotation token。normal token可以经过parser解析后代替为annotation token注入到 preprocessor的token stream中，这样一来可以把c++的qualified type names(eg.<code>foo::bar::baz&lt;42&gt;::t</code>)看作一个token，二来当parser回溯时可以免除reparse(类似记忆化搜索)<ul>
<li>annotation token有三种TokenKind<ul>
<li><code>tok::annot_typename</code>表示类名</li>
<li><code>tok::annot_cxxscope</code>表示c++的域符(eg. <code>A::B::</code>)</li>
<li><code>tok::annot_template_id</code>表示一个c++ template-id</li>
</ul>
</li>
<li>具体的token定义在<code>include/clang/Basic/TokenKinds.def</code>中，遵照C&#x2F;C++标准，文件一开始是本文件用到的宏，然后是token定义：预处理器关键字、语言关键字。<ul>
<li><code>.def</code>文件是模块定义文件，它为链接器提供有关被链接程序的导出、特性及其他方面的信息。</li>
</ul>
</li>
</ul>
</li>
<li><code>clang::MultipleIncludeOpt</code>通过实现一个状态机来处理<code>#ifndef XX / #define XX”</code></li>
</ul>
</li>
<li>语法分析相关<ul>
<li>Parser库：包含一个递归下降parser，会从preprocessor中获取token并notifiy一个client进行解析。会与Sema库交互</li>
<li>AST库<ul>
<li><p>设计思想：由于ASTnode基本不可变，因此clang不会为AST状态提供setter。AST不会对源码进行一些语义优化，遵守源码的语义，一些AST node只代表语法(eg. <code>ParenExpr</code>)，一些AST node只代表语义(eg. <code>ImplicitCastExpr</code>)</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://clang.llvm.org/doxygen/classclang_1_1ASTContext.html">ASTContext</a>：AST上下文，拥有本上下文中的一堆AST节点，供语义分析使用。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">Stmt</a>：语句的基类。有很多子类分别代表各种语句，其中的<a target="_blank" rel="noopener" href="https://clang.llvm.org/doxygen/classclang_1_1Expr.html">Expr</a>是表达式基类。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://clang.llvm.org/doxygen/classclang_1_1Type.html">Type</a>：<code>类型</code>的基类，用来处理类型。Type有很多子类，它们都定义在<code>clang/AST/Type.h</code>中。Types(包括其子类)通过<code>ASTContext</code>获取。</p>
<ul>
<li>Type不管type qualifiers(类型修饰符，如const, ,volatile)，Type会获取typedef信息(就是说如果)，一但创建，types就是不可变的。</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://clang.llvm.org/doxygen/classclang_1_1TypedefType.html">TypedefType</a>：<code>Type</code>类的一个特殊子类，用以处理<code>typedef </code>。clang的设计希望能记住typedef的信息，即比如对于<code>typedef int foo</code>，clang会把foo看做一个 <code>TypedefType</code>对象以表明foo是一个由<code>typedef</code>定义的<code>类型</code>。这样设计能<strong>提供用户自定义类型故障诊断</strong>，即报错时可以给用户看到是foo错误而不是int错误。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/InternalsManual.html#id39">Canonical Types</a>：<code>Type</code>类的一个成员。由于故障诊断需要上面这种设计但语义检查并不需要，所以<strong>为了加快语义检查</strong>，clang又设计出Canonical Types这个概念。每个<code>Type</code>对象都有一个名为<code>CanonicalType</code>的<code>QualType</code>指针(定义在<code>Type</code>的父类<code>ExtQualsTypeCommonBase</code>中)。对于<code>typedef</code>无关的简单类型，其<code>CanonicalType</code>指向自己。否则指向其等价类型(如<code>typedef int foo</code>中foo的CanonicalType的指向int)。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/InternalsManual.html#the-qualtype-class">QualType</a>：存储类型修饰符的类，这个类很”快”，通过位操作。此外由于一些修饰符组合是固定的，所以可以像智能指针一样被引用。具体的，该类的唯一域成员是一个类型为<code>llvm::PointerIntPair</code>的<code>Value</code>，所有操作都是在操作这个成员。修饰符也封装了一个类<code>Qualifiers</code>，源码注释有说明<code>Mask</code>的格式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bits:     |0 1 2|3|4 .. 5|6  ..  8|9   ...   31|</span></span><br><span class="line"><span class="comment">//           |C R V|U|GCAttr|Lifetime|AddressSpace|</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><a target="_blank" rel="noopener" href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">Decl</a>：表示声明。有很多子类对应各种声明(eg. Block，Name, pragma, friend, variable(VarDecl), function, struct， <strong>class(<a target="_blank" rel="noopener" href="https://clang.llvm.org/doxygen/classclang_1_1RecordDecl.html#details">RecordDecl</a>)</strong>)。每个声明有两种Context(详见下面Declaration contexts)：<code>Decl::getLexicalDeclContext</code>以及<code>Decl::getDeclContext</code></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://clang.llvm.org/doxygen/classclang_1_1DeclarationName.html#acd9a26d165d023ad7ba00966b8f95e0f">DeclarationName</a>：表示声明的名字。用于处理C族语言的声明。有一个kind属性，是一个枚举：<br>Identifier<br>  ObjC的三种Selector<br>  CXXConstructorName<br>  CXXDestructorName<br>  CXXConversionFunctionName<br>  CXXOperatorName<br>  CXXLiteralOperatorName<br>  CXXUsingDirective<br>有一个指针<code>Ptr</code>，注释说是这个指针有很多种意思？</p>
<p><code>ASTContext</code>有一个<code>DeclarationNameTable</code>类的成员<code>DeclarationNames</code>，它有一系列<code>getXXXName()</code>函数可获取上述对应类别的<code>DeclarationName</code></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/InternalsManual.html#id42">Declaration contexts</a>：声明需要存在于上下文中(eg. translation unit, namespace, class, or function)。上下文需要对其内部声明负责，管理内存以及(反)序列化。具体的，<a target="_blank" rel="noopener" href="https://clang.llvm.org/doxygen/classclang_1_1DeclContext.html">DeclContext</a>是上下文基类。对于声明在某一上下文中的变量，可以利用<code>DeclContext::decls_begin/decls_end()</code>迭代遍历得到此上下文中的所有声明(这种设计以源码为中心，可以清楚的表示出源码的结构)；也可以利用<code>DeclContext::lookup</code>传入一个<code>DeclarationName</code>查找一个声明(这种设计以语义为中心)，并返回一个<code>DeclContext::lookup_result</code>，这个result有一个迭代器可以迭代同名声明的所有重载。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://clang.llvm.org/doxygen/classclang_1_1StoredDeclsMap.html">StoredDeclsMap</a>：存储声明的类。DeclContext有一个指针Ptr指向一个这个结构，lookup函数就是通过这个Map找声明的。这个Map不是用STL的而是LLVM自己实现的，在<code>llvm/ADT(高性能抽象类型)</code>中</p>
</li>
<li><p>transparent context：给定一个context A，如果在源码上有声明存在于A内，但是在A之外语义还是可见的，那么A是透明的。例如C++中的枚举enum内的声明、extern内的声明、匿名union或struct、inline namespace。</p>
</li>
<li><p>错误处理：AST遇到错误代码时有三种应对手段：更正、保留一个无效node、摒弃一个无效node</p>
</li>
<li><p>Recovery AST：略</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/InternalsManual.html#the-astimporter">ASTImporter</a></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="LVS"><a href="#LVS" class="headerlink" title="LVS"></a>LVS</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40470303/article/details/80541639">https://blog.csdn.net/weixin_40470303/article/details/80541639</a></p>
<p>LVS（Linux Virtual Server）：Linux虚拟服务器，是一个开源负载均衡项目</p>
<p>IP隧道：一种把包再次封装的技术</p>
<hr>
<h2 id="图神经网络"><a href="#图神经网络" class="headerlink" title="图神经网络"></a>图神经网络</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="中心性概念"><a href="#中心性概念" class="headerlink" title="中心性概念"></a>中心性概念</h4><p>度中心性(degree centrality)：$\frac{节点度数}{节点总个数-1}$</p>
<p>中介中心性(betweenness centrality)：$\frac{经过该点的最短路径}{其余两两节点的最短路径}$，如果一个成员位于其他成员的多条最短路径上，那么该成员就是核心成员，就具有较大的中介中心性</p>
<p>接近中心性(closeness centrality)：</p>
<p>特征向量中心性(eigenvector centrality)：连接的点越重要，该点也就越重要</p>
<h4 id="PageRank算法"><a href="#PageRank算法" class="headerlink" title="PageRank算法"></a>PageRank算法</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/rubinorth/article/details/52215036">参考链接</a></p>
<p>边的PR值：PR(edge)&#x3D;$\frac{edge的入口节点的PR值}{入口节点的出度}$</p>
<p>节点的PR值：PR(node)&#x3D;$\sum $PR(node的入边)​，</p>
<p>阻尼系数：相当于一个衰减值，能让整个系统在迭代中收敛</p>
<p>使用幂迭代法进行求解</p>
<h4 id="HITS算法"><a href="#HITS算法" class="headerlink" title="HITS算法"></a>HITS算法</h4><p>节点有两个值：hub和authority</p>
<p>节点的hub值：hub(node)&#x3D;$\sum$auth(node的所有子节点)</p>
<p>节点的auth值：auth(node)&#x3D;$\sum $hub(node的所有父节点)</p>
<p>计算是存在依赖的，概念很简单，但是计算很麻烦。可以初始化PR值，然后迭代更新来计算。</p>
<hr>
<h3 id="graph-embedding"><a href="#graph-embedding" class="headerlink" title="graph embedding"></a>graph embedding</h3><h4 id="deepwalk算法"><a href="#deepwalk算法" class="headerlink" title="deepwalk算法"></a>deepwalk算法</h4><p>random walk + word2vec</p>
<p>利用随机游走提取一些序列，然后把序列看做由单词组成的句子，所有序列组成语料库，然后用word2vec算每个顶点embedding</p>
<h4 id="LINE算法"><a href="#LINE算法" class="headerlink" title="LINE算法"></a>LINE算法</h4><p>节点$v_i$的embedding用$u_i$表示，</p>
<p>一阶相似性</p>
<ul>
<li>定义两个点$v_i$,$v_j$的联合概率：$\Large p(v_i, v_j)&#x3D;sigmoid(u_i\cdot u_j)&#x3D;\frac{1}{1+exp(u_i \cdot u_j)}$</li>
<li>经验概率：$\large \hat{p}(v_i, v_j)&#x3D;\frac{w_{i,j}}{W}$</li>
<li>然后最小化$KL(p||\hat{p})$</li>
</ul>
<p>二阶相似性（理解例子：合成装备时，小件相似的大件的效果相似）</p>
<ul>
<li>定义两个点$v_i$,$v_j$的条件概率：$\Large p(v_j|v_i)&#x3D;\frac{exp(uj \cdot u_i)}{\sum_{k&#x3D;1}^{|V|}wxp(u_k \cdot u_i)}$</li>
<li>同样最小化$KL(p||\hat{p})$</li>
<li>最后直接拼接两个相似性</li>
</ul>
<h4 id="Node2vec"><a href="#Node2vec" class="headerlink" title="Node2vec"></a>Node2vec</h4><ul>
<li>deepwalk的改进，随机游走的时候增加了两个参数p和q分别平衡BFS和DFS，v到x的游走概率是$\alpha(t,x) \cdot w_{vx}$，其中t是上一轮所在节点</li>
</ul>
<p>$$<br>\alpha(t,x)&#x3D;</p>
<p>\left{\begin{align}<br>\frac{1}{p},x是自身 \<br>1,x是1阶邻居 \<br>\frac{1}{q},x是二阶邻居<br>\end{align}<br>\right.<br>$$</p>
<h4 id="struct2vec"><a href="#struct2vec" class="headerlink" title="struct2vec"></a>struct2vec</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/56733145">参考链接</a></p>
<ul>
<li><p>认为即使相距很远，但是局部结构相似的节点的embedding应该是相似的。这种结构相似性<strong>不依赖节点或边的属性甚至是节点的标签信息</strong>。</p>
</li>
<li><p>节点u和节点v是k-hop邻居，他们的k跳相似性是通过一条递归公式定义$f_k(u,v)&#x3D;f_{k-1}(u,v)+g(s(R_k(u), s(R_k(v)))$，</p>
<p>其中$R_k(u)$是u的k跳邻居集合，$s(x)$对x根据度进行排序并变为一个序列，$g(D_1,D_2)$表示两个序列$D_1$和$D_2$的距离。其中g函数可以用动态时间规整(一种动态规划算法)求。</p>
</li>
<li><p>构建多层带权图，每一层都是一个完全图，第k层图的节点之间的权重$w_k(a,b)&#x3D;exp(-f_k(a,b))$，也即权重是k跳相似性。而层与层之间也有权重，同一节点v相邻层次之间的权重有两种情况</p>
<ul>
<li>$w(v_k,v_{k+1}&#x3D;log(\Gamma_k(v)+e)$，其中$\Gamma_k(v)$表示与节点v相连的所有边当中 权重大于第k层完全图的平均边权的边 的数目。</li>
<li>$w(u_k,u_{k-1})&#x3D;1$</li>
</ul>
</li>
<li><p>游走生成语料库，然后skip-gram</p>
</li>
</ul>
<h4 id="SDNE"><a href="#SDNE" class="headerlink" title="SDNE"></a>SDNE</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/113092065">参考链接</a></p>
<ul>
<li>用AE压缩<ul>
<li>原始输入$x$与重构输出$\hat{x}$之间的损失$L_{2nd}&#x3D;\sum_{i&#x3D;1}^n\Vert(x_i-\hat{x_i})\bigodot b_i\Vert_2^2$表现了二阶相似性</li>
<li>而相邻节点的压缩变量$y_i$与$y_j$之间的损失$L_{1st}&#x3D;\sum_{i,j&#x3D;1}^ns_{i,j} \Vert y_i-y_j\Vert_2^2$则表现了一阶相似性。</li>
<li>最终损失函数就由这两个损失结合，然后bp</li>
</ul>
</li>
<li>压缩变量就是embedding</li>
<li>小规模上表现不怎么好</li>
</ul>
<hr>
<h3 id="基础图神经网络"><a href="#基础图神经网络" class="headerlink" title="基础图神经网络"></a>基础图神经网络</h3><h4 id="GCN"><a href="#GCN" class="headerlink" title="GCN"></a>GCN</h4><p>用于节点分类或特征提取，应该是不能进行因果推理的。</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/54504471/answer/332657604">参考链接</a></p>
<p>关键公式</p>
<p>第三代GCN的卷积计算公式</p>
<p>可以这样理解：</p>
<ul>
<li><p>AHW的A表示空间关系，对应图像卷积的左上、上、下这些方位</p>
</li>
<li><p>AHW的H表示被卷积的对象，对应图像卷积中的被卷积的图像</p>
</li>
<li><p>AHW的W表示权重，对应图像卷积核的内部取值</p>
</li>
<li><p>$\large H^{(l+1)}&#x3D;\sigma(\widetilde{D}^{-\frac{1}{2}} \widetilde{A} \widetilde{D}^{-\frac{1}{2}} H^{(l)}W^{(l)})$</p>
</li>
<li><p>其中$\widetilde{A}&#x3D;邻接矩阵+单位矩阵$，$\widetilde{D}$是对角线为对应顶点度数+1的对角矩阵，$H^{(0)}&#x3D;X(顶点的特征向量组成的矩阵)$，$W^{(l)}$是神经网络第$l$层的权重矩阵</p>
</li>
<li><p>意义：前面$\widetilde{D}^{-\frac{1}{2}} \widetilde{A} \widetilde{D}^{-\frac{1}{2}}$是归一化操作，也可以通过$\widetilde{D}^{-1}\widetilde{A}$进行归一化，但后者得到的是非对称矩阵</p>
</li>
<li><p>最后一层输出$Z&#x3D;f(X,A)&#x3D;softmax(\hat{A}Relu(H^{(n-1)})W)$</p>
</li>
</ul>
<p>下面这些推导中比较重要的公式可以不用管</p>
<ul>
<li><p>拉普拉斯矩阵，三种</p>
<ul>
<li>$L&#x3D;D-A$，D是度矩阵，A是邻接矩阵</li>
<li>$L^{sys}&#x3D;D^{-\frac{1}{2}}LD^{-\frac{1}{2}}$</li>
<li>$L^{rw}&#x3D;D^{-1}L$</li>
</ul>
</li>
<li><p>拉普拉斯矩阵谱分解<br>$$<br>L&#x3D;U<br>  \begin{bmatrix}<br>   \lambda_1 &amp;   &amp;\<br>    &amp;   \ddots   &amp;\<br>    &amp;   &amp;    &amp;   \lambda_n<br>   \end{bmatrix}<br>  U^{-1}<br>  &#x3D;U<br>  \begin{bmatrix}<br>   \lambda_1 &amp;   &amp;\<br>    &amp;   \ddots   &amp;\<br>    &amp;   &amp;    &amp;   \lambda_n<br>   \end{bmatrix}<br>  U^T<br>$$<br>得到U，它是列向量为单位特征向量的矩阵</p>
</li>
<li><p>图的傅里叶变换：$f&#x3D;UU^{-1}f&#x3D;UU^Tf&#x3D;U\hat{f}$</p>
</li>
<li><p>图的卷积：$(f*h)_G&#x3D;\mathcal{F}^{-1}{\mathcal{F}{f}\cdot \mathcal{F}{h}}$</p>
</li>
</ul>
<h4 id="GraphSAGE"><a href="#GraphSAGE" class="headerlink" title="GraphSAGE"></a>GraphSAGE</h4><p>生成embedding时多了这两步</p>
<ul>
<li>聚合周边邻居信息(AGGREGATE)</li>
<li>拼接自身和邻居的信息(CONCATE)</li>
</ul>
<h4 id="GAT"><a href="#GAT" class="headerlink" title="GAT"></a>GAT</h4><ul>
<li>attention计算公式$\Large \alpha_{ij}&#x3D;\frac{exp(LeakyReLU(\vec{a}^T[Wh_i]\Vert Wh_j))}{\sum_{k\in N_i}exp(LeakyReLU(\vec{a}^T[Whi\Vert Wh_k]))}$</li>
<li>其中$\vec{a}$和$W$是可学习参数，而且每一层的a和W是共享的</li>
</ul>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><hr>
<h2 id="PyTorch"><a href="#PyTorch" class="headerlink" title="PyTorch"></a>PyTorch</h2><p><a target="_blank" rel="noopener" href="https://pytorch.org/docs/stable">docs</a></p>
<p>看了doc，发现下面有的已经deprecated了</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/36233589">pytorch入坑一 | Tensor及其基本操作 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://pytorch.org/tutorials/beginner/deep_learning_60min_blitz.html">官方的60分钟教程</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一、基本</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">x=torch.Tensor(<span class="number">5</span>,<span class="number">3</span>)<span class="comment">#构造一个[5,3]的矩阵</span></span><br><span class="line">y=torch.rand(<span class="number">5</span>,<span class="number">3</span>)<span class="comment">#构造一个[5,3]的随机矩阵</span></span><br><span class="line">x.size()<span class="comment">#获取矩阵大小,返回一个元组</span></span><br><span class="line"><span class="comment"># 数学操作有多种语法</span></span><br><span class="line"><span class="comment"># 操作详见https://pytorch.org/docs/stable/torch.html</span></span><br><span class="line">x+y</span><br><span class="line">torch.add(x, y)</span><br><span class="line">torch.add(x, y, out=result)</span><br><span class="line">y.add_(x) <span class="comment">#in-place操作，即y+=x的意思</span></span><br><span class="line"><span class="comment"># batch矩阵乘法，比如如果batch1.shape是[b,n,m]，batch2.shape是[b,m,p]，则结果是[b,n,p]</span></span><br><span class="line">torch.bmm(batch1, batch2)</span><br><span class="line"><span class="comment">#Tensor←→numpy</span></span><br><span class="line">b=a.numpy()</span><br><span class="line">a=torch.Tensor(a)</span><br><span class="line"><span class="comment">#重构tensor的维度</span></span><br><span class="line">result=t.view(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">#squeeze(dim)，如果tensor的第dim维是1，则删掉该维度，否则不变。</span></span><br><span class="line">x.shape为[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">x.squeeze(<span class="number">1</span>)之后</span><br><span class="line">x.shape变成[<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">#unsqueeze(dim)则相反，会增加一个维度</span></span><br><span class="line">x.shape为[<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">x.unsqueeze(<span class="number">1</span>)会在第<span class="number">1</span>维处增加一维</span><br><span class="line">x.shape变成[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment"># @符号：不管输入的两个矩阵到底是多少维，实际中都是只对最后两维做矩阵相乘的运算</span></span><br><span class="line">x = torch.randn(<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line">y = torch.randn(<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>)</span><br><span class="line">z = x@y</span><br><span class="line">z.shape是[<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>]</span><br><span class="line"><span class="comment"># 理解为一个字典,字典的大小为num_embeddings，词向量的维度为embedding_dim</span></span><br><span class="line">embedding = nn.Embedding(num_embeddings, embedding_dim).</span><br><span class="line">embed = embedding(x)</span><br><span class="line">如果x.shape是[<span class="number">2</span>,<span class="number">4</span>]，embedding_dim=<span class="number">5</span></span><br><span class="line">那么embed.shape是[<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>]，即[<span class="number">2</span>,<span class="number">3</span>]的x被映射为一个<span class="number">5</span>维向量</span><br><span class="line"></span><br><span class="line"><span class="comment">#二、autograd自动求导</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="comment"># requires_grad=True表明这个变量后面是需要求导的</span></span><br><span class="line"><span class="comment"># 计算图会忽略掉那些对非必须求导的变量(frozen parameters )的求导</span></span><br><span class="line">x=Variable(torch.ones(<span class="number">2</span>,<span class="number">2</span>), requires_grad=<span class="literal">True</span>)</span><br><span class="line">y=x+<span class="number">2</span></span><br><span class="line">z=<span class="number">3</span>*y*y <span class="comment"># z=3(x+2)^2</span></span><br><span class="line">out=z.mean() <span class="comment">#z是矩阵，只有输出是标量才能算梯度，这里转为一个标量</span></span><br><span class="line">out.backward() <span class="comment">#以out为根节点调用backward，autograd则会沿着计算图反向传播，计算各个叶子节点的梯度</span></span><br><span class="line"><span class="built_in">print</span>(x.grad) <span class="comment">#输出out对x的梯度</span></span><br><span class="line"><span class="comment">#非叶子节点启用“保存梯度”，也就是存储中间节点的梯度</span></span><br><span class="line">Tensor.retain_grad()</span><br><span class="line"><span class="comment">#保留bp过程中计算的梯度</span></span><br><span class="line">loss.backward(retain_graph=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#三、神经网络</span></span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable <span class="comment">#变量</span></span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F <span class="comment">#函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(nn.Module):<span class="comment">#网络定义只需继承nn.Module</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>() <span class="comment">#初始化参数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>() <span class="comment">#前馈逻辑</span></span><br><span class="line">    <span class="keyword">pass</span> <span class="comment">#不同种类的网络的代码详见网上例子</span></span><br><span class="line"><span class="built_in">list</span>(net.parameters())<span class="comment">#返回模型需要学习的参数</span></span><br><span class="line"><span class="built_in">input</span> = Variable(torch.rand(<span class="number">1</span>,<span class="number">1</span>,<span class="number">32</span>,<span class="number">32</span>)) <span class="comment">#输入变量定义</span></span><br><span class="line">out=net(<span class="built_in">input</span>) <span class="comment">#输入变量到网络中</span></span><br><span class="line">out = out.to(torch.float32) <span class="comment">#处理一下类型</span></span><br><span class="line">net.zero_grad() <span class="comment">#所有参数的梯度缓存清零</span></span><br><span class="line">target=Variable(torch.arange(<span class="number">1</span>, <span class="number">11</span>)) <span class="comment">#随便举个例子</span></span><br><span class="line">target=target.to(torch.float32)</span><br><span class="line">criterion=nn.MSELoss() <span class="comment">#损失函数https://pytorch.org/docs/stable/nn.html#loss-functions</span></span><br><span class="line">loss=criterion(out, target)</span><br><span class="line">loss.backward() <span class="comment">#反向传播误差</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如下回溯可以得到计算图，不过一般用不到</span></span><br><span class="line"><span class="built_in">print</span>(loss.grad_fn)</span><br><span class="line"><span class="built_in">print</span>(loss.grad_fn.next_functions[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(loss.grad_fn.next_functions[<span class="number">0</span>][<span class="number">0</span>].next_functions[<span class="number">0</span>][<span class="number">0</span>]) </span><br><span class="line"></span><br><span class="line"><span class="comment">#简单的参数更新例子</span></span><br><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> net.parameters():</span><br><span class="line">    f.data.sub_(f.grad.data * learning_rate)</span><br><span class="line"></span><br><span class="line"><span class="comment">#优化算法</span></span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=<span class="number">0.01</span>) <span class="comment">#初始化optimizer时绑定一个模型实例的参数</span></span><br><span class="line">optimizer.zero_grad()</span><br><span class="line">output=net(<span class="built_in">input</span>)</span><br><span class="line">loss=criterion(output, target)</span><br><span class="line">loss.backward()</span><br><span class="line">optimizer.step() <span class="comment">#步进更新参数</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注：<ul>
<li>只有输出是标量才能计算梯度</li>
<li>torch.nn只支持mini-batches而不支持单个样本</li>
<li>pytorch里面一般是没有层的概念，层也是当成一个model处理</li>
</ul>
</li>
<li></li>
</ul>
<hr>
<h2 id="PyTorch-Geometric"><a href="#PyTorch-Geometric" class="headerlink" title="PyTorch Geometric"></a>PyTorch Geometric</h2><p><a target="_blank" rel="noopener" href="https://towardsdatascience.com/hands-on-graph-neural-networks-with-pytorch-pytorch-geometric-359487e221a8">Hands-on Graph Neural Networks with PyTorch &amp; PyTorch Geometric</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/91229616">图神经网络库PyTorch geometric（PYG）零基础上手教程</a></p>
<p><a target="_blank" rel="noopener" href="https://pytorch-geometric.readthedocs.io/en/latest/">官方doc</a></p>
<p><code>torch_geometric.data</code>模块包含一个<code>Data</code>类来从数据创建图，Data的默认成员有</p>
<ul>
<li><code>data.x</code>: Node feature matrix with shape <code>[num_nodes, num_node_features]</code></li>
<li><code>data.edge_index</code>: Graph connectivity in COO format with shape <code>[2, num_edges]</code> and type <code>torch.long</code></li>
<li><code>data.edge_attr</code>: Edge feature matrix with shape <code>[num_edges, num_edge_features]</code></li>
<li><code>data.y</code>: Target to train against (may have arbitrary shape), <em>e.g.</em>, node-level targets of shape <code>[num_nodes, *]</code> or graph-level targets of shape <code>[1, *]</code></li>
<li><code>data.pos</code>: Node position matrix with shape <code>[num_nodes, num_dimensions]</code></li>
</ul>
<hr>
<h2 id="Scipy稀疏矩阵"><a href="#Scipy稀疏矩阵" class="headerlink" title="Scipy稀疏矩阵"></a>Scipy稀疏矩阵</h2><ul>
<li><p>例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br></pre></td></tr></table></figure></li>
<li><p>常用格式</p>
<ul>
<li>dok 字典<ul>
<li><code>&#123;(0,0):5, (1,1):8, (2,2):3, (3,1):3&#125;</code></li>
</ul>
</li>
<li>lil 列表的列表(每行不是0的位置，对应的数字)<ul>
<li><code>[[0],[1],[2],[1]], [[5],[8],[3],[6]]</code></li>
</ul>
</li>
<li>coo 坐标(不是0的数字，对应行坐标，对应列坐标)<ul>
<li><code>[5,8,3,6],[0,1,2,3],[0,1,2,1]</code></li>
</ul>
</li>
<li>csr 按行排序的coo<ul>
<li><code>[5,8,3,6],[0,1,2,3],[0,1,2,1]</code></li>
</ul>
</li>
<li>csc 按列排序的coo<ul>
<li><code>[5,8,3,6],[0,1,3,2],[0,1,1,2]</code></li>
</ul>
</li>
</ul>
</li>
<li><p>特殊格式</p>
<ul>
<li>dia 对角</li>
<li>bsr 分块稀疏</li>
</ul>
</li>
<li><p>使用方法</p>
<ul>
<li>用<code>dok</code>,<code>lil</code>,<code>coo</code>构造，运算时转成<code>csr</code>,<code>csc</code></li>
<li>转换使用<code>.tocsc()</code>或<code>.tocsr()</code>, 线性时间</li>
<li><code>csr</code>,<code>csc</code>乘法求逆快，<code>dok</code>,<code>lil</code>,<code>coo</code>索引简单，开发快</li>
</ul>
</li>
<li><p>使用例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[[4,0,9,0],</span></span><br><span class="line"><span class="string"> [0,7,0,0],</span></span><br><span class="line"><span class="string"> [0,0,0,0],</span></span><br><span class="line"><span class="string"> [0,0,0,5]]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">row = [<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>] <span class="comment"># 准备好行坐标</span></span><br><span class="line">col = [<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>] <span class="comment"># 准备好列坐标</span></span><br><span class="line">data= [<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>] <span class="comment"># 准备好对应数据</span></span><br><span class="line">D = coo_matrix((data, (row, col)), shape=(<span class="number">4</span>,<span class="number">4</span>))</span><br><span class="line">D = D.tocsr()</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h2><p><a target="_blank" rel="noopener" href="https://github.com/zhouyanasd/or-pandas/tree/master/articles">参考链接</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">group_1 = data_df.groupby(<span class="string">&#x27;size&#x27;</span>) <span class="comment">#按照某个index进行分组，得到几个(index, Dataframe)的元组，此外分组的索引可以是多个索引的组合</span></span><br><span class="line">dataframe.iteritems() <span class="comment">#把DataFrame迭代为(列名，Series)对，也即把每一列分开</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="networkx"><a href="#networkx" class="headerlink" title="networkx"></a>networkx</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 图相关</span></span><br><span class="line">创建图对象方式：</span><br><span class="line">G = nx.Graph() <span class="comment"># 创建无向图</span></span><br><span class="line">G = nx.DiGraph() <span class="comment"># 创建有向图</span></span><br><span class="line">G = nx.MultiGraph() <span class="comment"># 创建多重无向图</span></span><br><span class="line">G = nx.MultiDigraph() <span class="comment"># 创建多重有向图</span></span><br><span class="line">G.clear() <span class="comment"># 清除整个图</span></span><br><span class="line">G.in_edges() <span class="comment"># 得到一个边list，其中的元组(A,B)表示存在边A→B</span></span><br><span class="line">G.out_edges() <span class="comment"># 得到一个边list，其中的元组(A,B)表示存在边A←B</span></span><br><span class="line">G.out_edges(node=A, data=<span class="literal">True</span>) <span class="comment"># 获取节点A的所有入边（如A→B）且结果包含边的data</span></span><br><span class="line">G.in_edges(node=A, data=<span class="literal">True</span>) <span class="comment"># 获取节点A的所有入边（如B→A）</span></span><br><span class="line">G.reverse(copy=<span class="literal">True</span>) <span class="comment"># 返回原图逆转后的新图</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 节点相关</span></span><br><span class="line"><span class="number">1</span>、增加结点：</span><br><span class="line">g.add_node(<span class="number">1</span>)</span><br><span class="line">g.add_nodes_from([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">g.add_node(<span class="number">1</span>,name=<span class="string">&#x27;n1&#x27;</span>,weight=<span class="number">1</span>)<span class="comment">#增加结点，同时设置结点其他属性</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、删除结点：</span><br><span class="line"><span class="comment"># ID可以唯一标识一个结点，所以通过结点ID删除结点</span></span><br><span class="line">G.remove_node(node_ID)</span><br><span class="line">G.remove_nodes_from(nodes_list)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、查看结点属性</span><br><span class="line"><span class="built_in">print</span>(G._node)  <span class="comment">#通过_node查看结点属性</span></span><br><span class="line"><span class="built_in">print</span>(G.nodes()) <span class="comment">#显示所有结点，不显示属性</span></span><br><span class="line"><span class="built_in">print</span>(G.nodes(data=<span class="literal">True</span>),<span class="built_in">type</span>(G.nodes(data=<span class="literal">True</span>))) <span class="comment">#返回整体data参数设置为true，那么返回的是NodeDataView对象</span></span><br><span class="line"><span class="built_in">print</span>(G.node[<span class="number">1</span>][<span class="string">&quot;weight&quot;</span>]) <span class="comment">#根据结点ID，查看结点其他属性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(G.nodes(data=<span class="literal">True</span>))) <span class="comment">#以特定条件来查看结点属性（如列表格式）</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>更新结点：</span><br><span class="line">G.node[<span class="number">1</span>].update(&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;xx&quot;</span>&#125;)</span><br><span class="line">G.node[<span class="number">1</span>][<span class="string">&quot;name&quot;</span>]=<span class="string">&quot;hh&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>删除结点属性：</span><br><span class="line"><span class="keyword">del</span> G.node[<span class="number">1</span>][<span class="string">&quot;name&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>检查是否存在某个结点：</span><br><span class="line"><span class="built_in">print</span>(G.has_node(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 边相关</span></span><br><span class="line"><span class="number">1.</span>增加边</span><br><span class="line">g.add_edge(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">g.add_edges_from([(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">3</span>)])</span><br><span class="line">g.add_edge(<span class="number">1</span>, <span class="number">2</span>, weight=<span class="number">4.7</span>, relationship=<span class="string">&#x27;renew&#x27;</span>) <span class="comment">#向图中增加边，同时设置边的属性，下面的三元组(ID, ID, weight)</span></span><br><span class="line">g.add_weighted_edges_from([(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0.125</span>),(<span class="number">1</span>,<span class="number">3</span>,<span class="number">0.75</span>),(<span class="number">2</span>,<span class="number">4</span>,<span class="number">1.2</span>),(<span class="number">3</span>,<span class="number">4</span>,<span class="number">0.375</span>)])</span><br><span class="line">g.add_edges_from([(<span class="number">1</span>,<span class="number">2</span>,&#123;<span class="string">&#x27;color&#x27;</span>:<span class="string">&#x27;blue&#x27;</span>&#125;), (<span class="number">2</span>,<span class="number">3</span>,&#123;<span class="string">&#x27;weight&#x27;</span>:<span class="number">8</span>&#125;)])</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>删除边</span><br><span class="line">g.remove_edge(edge)</span><br><span class="line">g.remove_edges_from(edges_list)</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>查询边</span><br><span class="line">g.edges(data=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 查询边的属性</span></span><br><span class="line">g[<span class="number">1</span>][<span class="number">2</span>]</span><br><span class="line">g.get_edge_data(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>更新边属性：</span><br><span class="line"><span class="comment"># 通过边来更新边的属性，由两种方式，一种是使用update函数，一种是通过属性赋值来实现：</span></span><br><span class="line">g[<span class="number">1</span>][<span class="number">2</span>][<span class="string">&#x27;weight&#x27;</span>] = <span class="number">4.7</span></span><br><span class="line">g.edge[<span class="number">1</span>][<span class="number">2</span>][<span class="string">&#x27;weight&#x27;</span>] = <span class="number">4</span></span><br><span class="line">g[<span class="number">1</span>][<span class="number">2</span>].update(&#123;<span class="string">&quot;weight&quot;</span>: <span class="number">4.7</span>&#125;)</span><br><span class="line">g.edges[<span class="number">1</span>, <span class="number">2</span>].update(&#123;<span class="string">&quot;weight&quot;</span>: <span class="number">4.7</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、删除边属性：</span><br><span class="line"><span class="keyword">del</span> g[<span class="number">1</span>][<span class="number">2</span>][<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>查看边是否存在</span><br><span class="line">g.has_edge(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关系&amp;遍历&amp;绘制图</span></span><br><span class="line">G.adj[<span class="number">1</span>] <span class="comment"># 返回节点的相邻节点</span></span><br><span class="line">G.degree <span class="comment"># 返回图上所有节点的度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历</span></span><br><span class="line"><span class="keyword">for</span> n,nbrs <span class="keyword">in</span> G.adjacency():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;结点：&quot;</span>,n)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;相邻结点信息：&quot;</span>,nbrs)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;以列表形式返回（Key-Value）组成元组&quot;</span>,nbrs.items())</span><br><span class="line">    <span class="keyword">for</span> nbr,attr <span class="keyword">in</span> nbrs.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;相邻结点：&quot;</span>,nbr)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;对应相邻结点得属性：&quot;</span>,attr)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">nx.draw(g)</span><br><span class="line">nx.draw(G,with_labels=<span class="literal">True</span>,pos=nx.spectral_layout(G),node_color=<span class="string">&quot;r&quot;</span>,edge_color=<span class="string">&quot;g&quot;</span>) <span class="comment"># 设置一些选项</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="Pcalg"><a href="#Pcalg" class="headerlink" title="Pcalg"></a>Pcalg</h2><p><a target="_blank" rel="noopener" href="https://dango.rocks/blog/2019/09/24/Causality5-Drawing-Causal-Diagram/">PC算法实践</a></p>
<hr>
<h2 id="概率图模型"><a href="#概率图模型" class="headerlink" title="概率图模型"></a>概率图模型</h2><p>相关性不等于因果性</p>
<h3 id="Simpson’s-paradox"><a href="#Simpson’s-paradox" class="headerlink" title="Simpson’s paradox"></a>Simpson’s paradox</h3><p>当人们尝试探究两种变量（比如新生录取率与性别）是否具有相关性的时候，会分别对之进行分组研究。然而，在分组比较中都占优势的一方，在总评中有时反而是失势的一方。</p>
<h3 id="SCM与图"><a href="#SCM与图" class="headerlink" title="SCM与图"></a>SCM与图</h3><p>structural causal model</p>
<ul>
<li>外生变量(exogenous variable)对应 根节点</li>
<li>内生变量(endogenous variable)对应 根节点的后继</li>
<li>函数f 对应 边</li>
</ul>
<h3 id="v-结构"><a href="#v-结构" class="headerlink" title="v-结构"></a>v-结构</h3><ul>
<li>三类结构<ul>
<li>chain：x→y→z，x和z是统计相关的。但是给定y(conditional on y)时，x和z是统计独立的</li>
<li>fork：y←x→z，y和z是统计相关的。但是给定x(conditonal on x)时，y和z是统计独立的</li>
<li>collider：x→z←y，x和y是统计独立的。但是给定z(conditional on z)时，x和y是统计相关的。</li>
</ul>
</li>
<li>而是否要conditional，是要视实际而定的。因为有相关关系不代表一定就是因果关系。<strong>即，即使存在一条边，但是这条边不一定是“因果边”</strong>。而conditional就是把一条边切断的行为，切断某条边可能可以让因果边的影响展现出来，但是也有可能把因果边切掉。</li>
</ul>
<h3 id="D-separation"><a href="#D-separation" class="headerlink" title="D-separation"></a>D-separation</h3><p>d stands for direction</p>
<ul>
<li>x and y d-sepaprted $\Leftrightarrow$ x和y统计独立</li>
<li>x and y d-sepaprted  condition z $\Leftrightarrow$ x和y统计独立 | Z</li>
<li>x→z←y，x和y是d分离的</li>
<li>x←z→y，x和y是d联通(d-connected)的</li>
<li>x→z→y，x和y是d联通的</li>
<li>如果x和y直接每一条路径都是blocked或d分离的，x和y是d分离的</li>
</ul>
<h3 id="模型检验与等价类"><a href="#模型检验与等价类" class="headerlink" title="模型检验与等价类"></a>模型检验与等价类</h3><ul>
<li>模型检验：可以假设一个模型(因果图)，通过观测数据利用统计方法（比如回归）来估计统计相关性，如果估计与假设矛盾则可以推翻假设。</li>
<li>用数据的统计分析是不能区分fork和chain的，也即无法定向。无法区分的情况组成一个等价类。</li>
<li>因果图的等价：把无法区分的部分都变成无向边，如果最后两个图是一样的则是等价的。</li>
</ul>
<h3 id="乘积分解法则"><a href="#乘积分解法则" class="headerlink" title="乘积分解法则"></a>乘积分解法则</h3><ul>
<li>$P(x_1,x_2,…,x_n)&#x3D;\prod_{i-1}^nP(x_i|x_i的所有父节点)$</li>
</ul>
<h3 id="混淆变量"><a href="#混淆变量" class="headerlink" title="混淆变量"></a>混淆变量</h3><p>confounder，因为存在混杂因子使得不能弄清因果关系。</p>
<p>数据可分为observation(观测数据)和experiment(实验数据)，后者会人为干涉。观测数据因为有很多confounder，所以其因果推断很难。</p>
<hr>
<h2 id="VAE"><a href="#VAE" class="headerlink" title="VAE"></a>VAE</h2><h3 id="AE"><a href="#AE" class="headerlink" title="AE"></a>AE</h3><p>encoder把输入x通过一个神经网络编码为一个隐变量z</p>
<p>decoder把隐变量z通过一个神经网络解码为一个重构的$x’$</p>
<p>引入一个$Loss(x,x’)$训练整个AE</p>
<h3 id="VAE-1"><a href="#VAE-1" class="headerlink" title="VAE"></a>VAE</h3><p>AE相当于是将输入在隐变量空间进行编号，这种做法比较粗暴，在边界的泛化能力并不好，于是有人提出VAE。</p>
<ul>
<li><p>AE的隐变量就是一些参数，而VAE则是把分布作为隐变量(最初的VAE隐变量采用的是高斯分布)。</p>
</li>
<li><p>其实VAE和AE在encoder的阶段并没有什么不同，例如：把700维的输入编码为10维高斯分布，那么隐变量其实就是这个二维高斯分布的参数，若只取2个$\mu$，2个方差，1个协方差作为参数，那么encoder看来和学一个700到5的映射没区别。</p>
</li>
<li><p>关键是此后的阶段。因为得到的隐变量是分布，所以要进行中间输出或者decoder的输入时需要进行采样。</p>
<p>注：采样过程为了防止梯度断裂，通常会统一从标准正态分布采样再偏移到目标分布而不是直接构造所得到分布进行采样。这是实现时需要注意问题，可以不用管。</p>
</li>
<li><p>decoder阶段就是把采样所得的值再经过一个神经网络得到一个重构</p>
</li>
<li><p>需要训练的其实就是这encoder和decoder这两个神经网络，其实就是两个映射(x→z，z→x’)，为此</p>
</li>
<li><p>具体的符号表示：</p>
<ul>
<li><p>x是输入</p>
</li>
<li><p>z是隐变量</p>
</li>
<li><p>p(z)是隐变量的分布，未知</p>
</li>
<li><p>p(z|x)是x映射到z的分布，未知</p>
</li>
<li><p>q(z|x)用于近似上面的分布</p>
</li>
<li><p>$Loss&#x3D;KL(q(z|x), p(z|x))$：上面这个拟合的loss。此式经过一堆化简，省略之后变成<br>$$<br>\large Loss&#x3D;E_{q(z|x^{(i)})}(\frac{\Vert x^{(i)}-f(z)\Vert^2}{2c})+KL(q(z|x^{(i)}), p(z))<br>$$<br>其中$q(z|x^{(i)})$代表了encoder，$f(z)$代表了decoder，$p(z)$未知，c是一个控制用的常数。</p>
<p>这里直接猜$p(z)$是一个标准高斯（因为自然界好多东西都是高斯分布，所有拿这个作为先验）</p>
<p>结果右边变成了<br>$$<br>\large KL(q(z|x^{(i)}), p(z))&#x3D;-\frac{1}{2}[1+log(\sigma_q^2)-\sigma_q^2-\mu_q^2]<br>$$</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="Flow-based-Model"><a href="#Flow-based-Model" class="headerlink" title="Flow-based Model"></a>Flow-based Model</h2><p>生成模型的一种，其他生成模型有VAE、GAN</p>
<p>一下符号以及叙述参考李宏毅的讲义</p>
<ul>
<li><p>符号</p>
<ul>
<li>z：从normal distribution采样得到</li>
<li>G: 生成器</li>
<li>x：$x&#x3D;G(z)$</li>
<li>$p_G(x)$：g生成的分布</li>
<li>$p_{data}(x)$：data的分布</li>
</ul>
</li>
<li><p>目标：$p_G(x)$与$p_{data}(x)$越接近越好</p>
</li>
<li><p>等价目标：从$p_{data}(x)$中抽样出${x^1,x^2,…,x^m}$，然后最大化$argmax_G\sum_{i&#x3D;1}^m(logp_G(x^i))$，即从真正分布中抽样出的数据在生成的分布中也要有很高的概率</p>
</li>
<li><p>flow-based模型可以优化上面这个目标</p>
</li>
<li><p>前置知识</p>
<ul>
<li><p>Jacobian矩阵：偏导数矩阵，不同行是不同的输出，不同列是不同的输入</p>
</li>
<li><p>Jacobian矩阵的逆：这个逆其实就是原Jacobian矩阵对应的原函数的反函数对应的Jacobian矩阵</p>
</li>
<li><p>$\Large det(A) &#x3D; \frac{1}{det(A^{-1})}$</p>
</li>
<li><p>$|det(A)|$的物理意义是n行向量组成的超立方体的体积</p>
</li>
<li><p>change of variable：假设服从$\pi(z)$的$z$经过一个$x&#x3D;g(z)$后变成服从$p(x)$的$x$</p>
<p>问知道$g(z)$之后，是不是就能知道$p(x)$与$\pi(z)$的关系？</p>
<p>答：可以知道，利用微分的方法，微分的部分看做uniform distribution，那么$p(x)\Delta x&#x3D;\pi(z) \Delta z$，所以$\large p(x)&#x3D;\pi(z)|\frac{dz}{dx}|$，$\frac{dz}{dx}$也就是$g^{\prime}(z)$，推广到多维，则是$\large p(x)&#x3D;\pi(z)|\frac{1}{det(J_g)}|$, $J_g$是生成器的Jacobian</p>
</li>
<li><p>总结：上面这一大堆就是为了把等价目标里面的</p>
<p>$p_G(x^i)$(输入值在生成分布的概率)</p>
<p>转换为</p>
<p>$\pi(G^{-1}(z^i)$(输出值经过生成器反函数计算后在原始分布的概率)</p>
</li>
</ul>
</li>
<li><p>问题</p>
<ol>
<li>Jacobian是平方复杂度，算其det就更耗时了</li>
<li>G的反函数也难算</li>
</ol>
</li>
<li><p>限制：与GAN和VAE不同，这个G的输入输出的维度要一致，所以有人想到堆叠G，叠起来就像是一个flow</p>
</li>
<li><p>训练过程：以$G^{-1}$为主体</p>
</li>
<li><p>常见的生成器G:</p>
<ul>
<li>Coupling layer：被用于NICE和RNVP。输入x均分成两份$x_1, x_2$，$x_1$直接作为z的前半$z_1$，$x_2\odot F(x_2)+H(x_1)$作为z的后半$z_2$，其中的F和H可以是任何复杂的函数。这样设计容易求得$det(J_{G^{-1}})$以及$G^{-1}$。但是这样做的话，会有一半的原始输入直接作为输出，于是可以通过堆叠，先前半作为第一个layer的前半然后再作为第二个layer的后半。因此叫做coupling layer。</li>
<li>1x1 Convolution：被用于GLOW。1x1卷积可以用来shuffle多通道。</li>
</ul>
</li>
</ul>
<h2 id="PU-Learning"><a href="#PU-Learning" class="headerlink" title="PU Learning"></a>PU Learning</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011984148/article/details/106774435">参考</a></p>
<ul>
<li>可以理解为一种预处理过程</li>
<li>二分类问题的数据集<ul>
<li>只有少量单类标签T被标注了</li>
<li>任务：利用这少量标签数据为整个数据集打上可靠标签</li>
</ul>
</li>
<li>two step法<ul>
<li>正样本记为1，未标注样本记为-1，可靠负样本记为0</li>
<li>一开始没有可靠负样本</li>
</ul>
<ol>
<li>挑出正样本和未标注样本，训练一个区分正样本和未标注样本的分类器A(比如random forest)。</li>
<li>使用A对样本进行预测所有样本的概率，得到所有正样本最低到最高的得分范围<code>[l, r]</code></li>
<li>对于未标注样本，<code>分数&lt;l</code>则标注为可靠负样本, <code>r&lt;分数</code>则标注为正样本</li>
<li>迭代上述步骤直到没有新的未标注样本被标注或者是迭代了指定轮数</li>
</ol>
</li>
</ul>
<hr>
<h2 id="杂-1"><a href="#杂-1" class="headerlink" title="杂"></a>杂</h2><h3 id="ubuntu更改启动级别"><a href="#ubuntu更改启动级别" class="headerlink" title="ubuntu更改启动级别"></a>ubuntu更改启动级别</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">终端界面</span></span><br><span class="line">sudo systemctl set-default multi-user.target</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">图形界面（仅进入一次</span></span><br><span class="line">sudo systemctl start lightdm</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认图形界面</span></span><br><span class="line">sudo systemctl set-default graphical.target</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要重启</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>

<h3 id="vscode相关"><a href="#vscode相关" class="headerlink" title="vscode相关"></a>vscode相关</h3><p>批量注释 ctrl+k然后ctrl+c，批量取消注释ctrl+k然后ctrl+u。</p>
<p>remote ssh的使用需要用管理员权限打开vscode</p>
<hr>
<h3 id="高并发系统中的尾延迟效应"><a href="#高并发系统中的尾延迟效应" class="headerlink" title="高并发系统中的尾延迟效应"></a>高并发系统中的尾延迟效应</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/guo_jia_liang/article/details/53741775">https://blog.csdn.net/guo_jia_liang/article/details/53741775</a></p>
<p>谷歌通过引入多种隔离机制来降低tail latency对延迟敏感任务(latency-critical，LC)的影响</p>
<ul>
<li>cpu：cpuset、cgroup以及intel的CAT(Cache Allocation Technology)技术</li>
<li>内存：无硬件隔离机制，只能在软件层监控</li>
<li>网络：linux流控</li>
<li>功耗：主频监控</li>
</ul>
<hr>
<h3 id="侵入式数据结构"><a href="#侵入式数据结构" class="headerlink" title="侵入式数据结构"></a>侵入式数据结构</h3><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/5004162/what-does-it-mean-for-a-data-structure-to-be-intrusive">参考链接</a>：把元素添加到数据结构中需要知道元素的内部</p>
<hr>
<h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><p>IDEA开发maven项目的时候曾经试过不小心在pom.xml点了add as ant build file选项，导致pom.xml全部标红</p>
<p>一个商城项目的前端使用vue做的，但是这个项目的package.json以及package-lock.json所指明的包的依赖版本出问题了，上网搜索发现有同样的问题，optimize-css-assets-webpack-plugin版本过高，于是降低至2.0.0版本，可是又带来了另一个问题，cssnano没安装，网上解决方案到此只是说安装cssnano，但是没说是哪个版本。幸好项目是开源的，所以我在github上根据<a href="mailto:&#x6f;&#x70;&#116;&#105;&#x6d;&#105;&#122;&#x65;&#45;&#x63;&#115;&#x73;&#45;&#97;&#115;&#115;&#101;&#x74;&#115;&#45;&#119;&#x65;&#x62;&#112;&#x61;&#x63;&#107;&#45;&#x70;&#108;&#117;&#x67;&#x69;&#110;&#64;&#50;&#x2e;&#48;&#46;&#48;">&#x6f;&#x70;&#116;&#105;&#x6d;&#105;&#122;&#x65;&#45;&#x63;&#115;&#x73;&#45;&#97;&#115;&#115;&#101;&#x74;&#115;&#45;&#119;&#x65;&#x62;&#112;&#x61;&#x63;&#107;&#45;&#x70;&#108;&#117;&#x67;&#x69;&#110;&#64;&#50;&#x2e;&#48;&#46;&#48;</a>的发布日sites-期从前安装对应版本的cssnano才解决了问题。</p>
<p>nginx的配置文件<code>nginx.conf</code>里面有include语句，默认include了<code>conf.d</code>目录以及<code>sites-enabled</code>，曾经试过因为没有注释掉这个而导致静态资源配置失败</p>
<p>vscode安装go，因为被墙安装不了很多包，通过修改环境变量解决<code>set GOPROXY=https://goproxy.io</code></p>
<p>linux的文件系统在命名时是区分大小写的，而windows的文件系统在命名时并不区分大小写。不信的话，你可以做个实验，在windows上新建一个名为aa的文件夹，然后再新建一个名为AA的文件夹，系统会报错，告诉你命名重复。因此，linux下的文件夹直接拷在windows上极可能出现“文件名重命名”的问题</p>
<p>R安装问题：因为要用根因分析，python要装cdt库，然后这个库用的是R的根因分析算法，所以需要安装R，安装R需要一堆依赖，其中有的依赖没有在R的CRAN仓库里面，需要在github安装，但是要在github安装又需要安装devtools，于是安装devtools，结果devtools虽然只需要依赖cli&gt;&#x3D;2.4.0以及sessioninfo&gt;&#x3D;1.1.1，但是仓库要给我安装1.2.0的sessioninfo，这玩意又需要cli&gt;&#x3D;3.1.0，于是想要安装1.1.1版本的sessioninfo，可是安装指定版本又需要devtools。现打算通过文件安装，CRAN就是一个垃圾包管理器。源码安装还需要额外安装工具链Rtools，这个工具链安装路径是C:&#x2F;rtools40，可是在使用时路径名居然是C:&#x2F;Rtools，配了环境变量都不管用，nt软件</p>
<p>实验室机器的pycharm用的是conda管理，如果需要用pip为解释器安装库，需要去D:\anaconda\Scripts下打开命令行再使用pip install xxx</p>
<p>有个命令叫du，能统计某个目录的磁盘空间使用量，有时候du和df显示的结果会不一致，原因ctrl+f搜一下</p>
<p>部署k8s的dashboard时试过被log挤爆硬盘，位置在<code>var/lib/docker/containers/xxx/xxxxxx.log</code>，硬盘爆了会发生好多神奇的事，etcd宕了，sock也连不上。</p>
<p>cat输入配置文件时为了换行会输入<code>\\</code>还有<code>EOF</code>，用vi编辑时注意不要这样</p>
<p>idea导入项目之后发现好多与lombok相关的代码都报红，说明idea需要安装lombok插件,有可能搜不到插件，可以手动添加一个仓库<a target="_blank" rel="noopener" href="https://plugins.jetbrains.com/plugins/alpha/5047">https://plugins.jetbrains.com/plugins/alpha/5047</a></p>
<p>precision_recall_curve函数<br>1.是从预测结果的最高分作为阈值开始计算的precision和recall，当recall&#x3D;1，就停止了计算<br>2.并且在precision和recall对应的列表分别添加了“1”、“0”</p>
<hr>
<p>2010年</p>
<p>减少存储检查点的时间：只保存读写区的修改，用hadoop去存储checkpoint</p>
<p>I. Goiri, F. Julià, J. Guitart, and J. Torres, ‘‘Checkpoint-based fault- tolerant infrastructure for virtualized service providers,’’ in Proc. 12th IEEE&#x2F;IFIP Netw. Oper. Manage. Symp. (NOMS), Osaka, Japan, Apr. 2010, pp. 455–462.</p>
<hr>
<p>2014年</p>
<p>自适应算法，以固定速率增加或减少checkpoint间隔</p>
<p>S. Limam and G. Belalem, ‘‘A migration approach for fault tolerance in cloud computing,’’ Int. J. Grid High Perform. Comput., vol. 6, no. 2, pp. 24–37, Apr.&#x2F;Jun. 2014.</p>
<hr>
<p>2015</p>
<p>基于检查点的uniform FT方法，支持长作业已经有优先级的作业</p>
<p>J. Cao, M. Simonin, G. Cooperman, and C. Morin, ‘‘Checkpointing as a service in heterogeneous cloud environments,’’ in Proc. 15th IEEE&#x2F;ACM Int. Symp. Cluster, Cloud Grid Comput., Shenzhen, China, May 2015, pp. 61–70.</p>
<hr>
<h3 id="CGI-x2F-fastCGI-x2F-php-fpm"><a href="#CGI-x2F-fastCGI-x2F-php-fpm" class="headerlink" title="CGI&#x2F;fastCGI&#x2F;php-fpm"></a>CGI&#x2F;fastCGI&#x2F;php-fpm</h3><p>CGI 的英文全名是 Common Gateway Interface，即通用网关接口</p>
<p>利用 CGI 可以针对用户请求动态返回给客户端各种各样动态变化的信息。</p>
<p>CGI 针对每个 HTTP 请求都会 fork 一个新进程来进行处理（解析配置文件、初始化执行环境、处理请求），然后把这个进程处理完的结果通过 Web 服务器转发给用户，刚刚 fork 的新进程也随之退出。</p>
<p>FastCGI ，是 CGI 的升级版本，利用池思想。 FastCGI会先 fork 一个 master 进程，解析配置文件，初始化执行环境，然后再 fork 多个 worker 进程，请求来了之后会传递给worker进程处理。</p>
<p>PHP-FPM 是 PHP 版本的 FastCGI 协议实现。通过它可以实现 PHP 脚本与 Web 服务器（通常是 Nginx）之间的通信，同时它也是一个 PHP SAPI，从而构建起 PHP 解释器与 Web 服务器之间的桥梁。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">fallingleaflun</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/05/16/mame/">http://example.com/2023/05/16/mame/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Hexo</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/17/java_8gu/" title="无聊的八股"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">无聊的八股</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/16/linux_note/" title="linux_note"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">linux_note</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">fallingleaflun</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Markdown"><span class="toc-number">1.</span> <span class="toc-text">Markdown</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git"><span class="toc-number">2.</span> <span class="toc-text">Git</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hook"><span class="toc-number">3.</span> <span class="toc-text">Hook</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NAT"><span class="toc-number">4.</span> <span class="toc-text">NAT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ORM"><span class="toc-number">5.</span> <span class="toc-text">ORM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pecan"><span class="toc-number">6.</span> <span class="toc-text">Pecan</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WSME"><span class="toc-number">7.</span> <span class="toc-text">WSME</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RPC"><span class="toc-number">8.</span> <span class="toc-text">RPC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E9%9D%A2%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8Boslo-messaging%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">8.1.</span> <span class="toc-text">下面简述一下oslo.messaging的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rpc-call%E6%89%A7%E8%A1%8C%E7%9A%84%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-number">8.2.</span> <span class="toc-text">rpc.call执行的流程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#openstack%E6%9C%8D%E5%8A%A1%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0"><span class="toc-number">8.3.</span> <span class="toc-text">openstack服务流程简述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#oslo%E5%BA%93"><span class="toc-number">9.</span> <span class="toc-text">oslo库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#oslo-cache"><span class="toc-number">9.1.</span> <span class="toc-text">oslo.cache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#oslo-concurrency"><span class="toc-number">9.2.</span> <span class="toc-text">oslo.concurrency</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#oslo-config"><span class="toc-number">9.3.</span> <span class="toc-text">oslo.config</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#oslo-context"><span class="toc-number">9.4.</span> <span class="toc-text">oslo.context</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#oslo-db"><span class="toc-number">9.5.</span> <span class="toc-text">oslo.db</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#oslo-messaging"><span class="toc-number">9.6.</span> <span class="toc-text">oslo.messaging</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#oslo-middleware"><span class="toc-number">9.7.</span> <span class="toc-text">oslo.middleware</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#oslo-policy"><span class="toc-number">9.8.</span> <span class="toc-text">oslo.policy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#oslo-serialization"><span class="toc-number">9.9.</span> <span class="toc-text">oslo.serialization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#oslo-service"><span class="toc-number">9.10.</span> <span class="toc-text">oslo.service</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#oslo-utils"><span class="toc-number">9.11.</span> <span class="toc-text">oslo.utils</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pbr"><span class="toc-number">9.12.</span> <span class="toc-text">pbr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#taskflow"><span class="toc-number">9.13.</span> <span class="toc-text">taskflow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stevedore"><span class="toc-number">9.14.</span> <span class="toc-text">stevedore</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenStack-Swift%E7%BB%84%E4%BB%B6"><span class="toc-number">10.</span> <span class="toc-text">OpenStack Swift组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python%E7%9B%B8%E5%85%B3"><span class="toc-number">11.</span> <span class="toc-text">Python相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Python%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">11.1.</span> <span class="toc-text">Python的装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#all-%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">11.2.</span> <span class="toc-text">__all__的用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#name"><span class="toc-number">11.3.</span> <span class="toc-text">__name__</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#metaclass"><span class="toc-number">11.4.</span> <span class="toc-text">metaclass</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#eventlet%E5%BA%93"><span class="toc-number">11.5.</span> <span class="toc-text">eventlet库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQLAlchemy"><span class="toc-number">11.6.</span> <span class="toc-text">SQLAlchemy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#with%E8%AF%AD%E5%8F%A5"><span class="toc-number">11.7.</span> <span class="toc-text">with语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setuptools"><span class="toc-number">11.8.</span> <span class="toc-text">setuptools</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">11.9.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#virtualenv"><span class="toc-number">11.10.</span> <span class="toc-text">virtualenv</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E7%9B%B8%E5%85%B3"><span class="toc-number">12.</span> <span class="toc-text">Linux相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E4%BD%8D%E7%BD%AE"><span class="toc-number">12.1.</span> <span class="toc-text">常用位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%A7%E8%A1%8C%E5%A4%9A%E4%B8%AA%E5%91%BD%E4%BB%A4"><span class="toc-number">12.2.</span> <span class="toc-text">命令行执行多个命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dd%E5%91%BD%E4%BB%A4"><span class="toc-number">12.3.</span> <span class="toc-text">dd命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xxd%E5%91%BD%E4%BB%A4"><span class="toc-number">12.4.</span> <span class="toc-text">xxd命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sync%E5%91%BD%E4%BB%A4"><span class="toc-number">12.5.</span> <span class="toc-text">sync命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#du%E5%91%BD%E4%BB%A4"><span class="toc-number">12.6.</span> <span class="toc-text">du命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tar"><span class="toc-number">12.7.</span> <span class="toc-text">tar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%B8%AD%E6%96%AD%E5%92%8C%E8%BD%AF%E4%B8%AD%E6%96%AD"><span class="toc-number">12.8.</span> <span class="toc-text">硬中断和软中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">12.9.</span> <span class="toc-text">linux文件系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Makefile"><span class="toc-number">13.</span> <span class="toc-text">Makefile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E9%A2%98%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="toc-number">14.</span> <span class="toc-text">算法题小技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92Debug%E6%8A%80%E5%B7%A7"><span class="toc-number">14.1.</span> <span class="toc-text">递归Debug技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E8%A7%84%E6%A8%A1%EF%BC%9A"><span class="toc-number">14.2.</span> <span class="toc-text">问题规模：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8E%E7%BA%A7%E9%94%99%E8%AF%AF"><span class="toc-number">14.3.</span> <span class="toc-text">低级错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">14.4.</span> <span class="toc-text">多源最短路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VS-code%E8%B0%83%E8%AF%95"><span class="toc-number">14.5.</span> <span class="toc-text">VS code调试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E4%BB%A3%E7%A0%81"><span class="toc-number">15.</span> <span class="toc-text">读代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAP%E5%8E%9F%E5%88%99"><span class="toc-number">16.</span> <span class="toc-text">CAP原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Zookeeper"><span class="toc-number">17.</span> <span class="toc-text">Zookeeper</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4"><span class="toc-number">17.1.</span> <span class="toc-text">名称空间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kafka"><span class="toc-number">18.</span> <span class="toc-text">Kafka</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">18.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AF%E8%AF%AD"><span class="toc-number">18.2.</span> <span class="toc-text">术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">18.3.</span> <span class="toc-text">一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%8E%8B%E7%BC%A9"><span class="toc-number">18.4.</span> <span class="toc-text">日志压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC"><span class="toc-number">18.5.</span> <span class="toc-text">启动脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1"><span class="toc-number">18.6.</span> <span class="toc-text">设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">18.6.1.</span> <span class="toc-text">生产者</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E5%BC%8F%E5%A4%84%E7%90%86"><span class="toc-number">18.7.</span> <span class="toc-text">流式处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Maven"><span class="toc-number">19.</span> <span class="toc-text">Maven</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#maven%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">19.1.</span> <span class="toc-text">maven项目的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">19.2.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86"><span class="toc-number">19.3.</span> <span class="toc-text">依赖管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Maven%E5%BA%93"><span class="toc-number">19.4.</span> <span class="toc-text">Maven库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POM"><span class="toc-number">19.5.</span> <span class="toc-text">POM</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java"><span class="toc-number">20.</span> <span class="toc-text">Java</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3"><span class="toc-number">20.1.</span> <span class="toc-text">编译相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3"><span class="toc-number">20.2.</span> <span class="toc-text">代码相关</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VMWare%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">21.</span> <span class="toc-text">VMWare网络连接方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%A5%E6%8E%A5"><span class="toc-number">21.1.</span> <span class="toc-text">桥接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NAT-1"><span class="toc-number">21.2.</span> <span class="toc-text">NAT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Host-Only"><span class="toc-number">21.3.</span> <span class="toc-text">Host-Only</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">22.</span> <span class="toc-text">一个简单的操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#32%E4%BD%8D%E3%80%8164%E4%BD%8D"><span class="toc-number">22.1.</span> <span class="toc-text">32位、64位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E8%AE%A1%E7%AE%97%E6%9C%BA"><span class="toc-number">22.2.</span> <span class="toc-text">启动计算机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">22.3.</span> <span class="toc-text">保护模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E4%B8%8Ec%E4%BB%A3%E7%A0%81%E7%9A%84%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8%EF%BC%8C"><span class="toc-number">22.4.</span> <span class="toc-text">汇编代码与c代码的相互调用，</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ELF%E6%96%87%E4%BB%B6"><span class="toc-number">22.5.</span> <span class="toc-text">ELF文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#asm%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%AE%80%E8%BF%B0"><span class="toc-number">22.6.</span> <span class="toc-text">asm汇编指令简述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">22.7.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A0%88"><span class="toc-number">22.8.</span> <span class="toc-text">进程的栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">22.9.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-x2F-O"><span class="toc-number">22.10.</span> <span class="toc-text">I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IPC"><span class="toc-number">22.11.</span> <span class="toc-text">IPC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">22.12.</span> <span class="toc-text">文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-fork"><span class="toc-number">22.13.</span> <span class="toc-text">内存管理?(fork)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-x2F-C"><span class="toc-number">23.</span> <span class="toc-text">C&#x2F;C++</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#likely-x2F-unlikely"><span class="toc-number">23.1.</span> <span class="toc-text">likely&#x2F;unlikely</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-number">23.2.</span> <span class="toc-text">静态库和动态库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring"><span class="toc-number">24.</span> <span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96IOC%E5%AE%B9%E5%99%A8"><span class="toc-number">24.1.</span> <span class="toc-text">获取IOC容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%AF%B9%E8%B1%A1"><span class="toc-number">24.2.</span> <span class="toc-text">配置对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E4%B8%80%E8%A7%88"><span class="toc-number">24.3.</span> <span class="toc-text">注解一览</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-MVC"><span class="toc-number">25.</span> <span class="toc-text">Spring MVC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-number">25.1.</span> <span class="toc-text">常用注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%82"><span class="toc-number">25.2.</span> <span class="toc-text">杂</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Boot"><span class="toc-number">26.</span> <span class="toc-text">Spring Boot</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#spring-boot%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">26.1.</span> <span class="toc-text">spring boot运作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebSocket"><span class="toc-number">26.2.</span> <span class="toc-text">WebSocket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE"><span class="toc-number">26.3.</span> <span class="toc-text">数据访问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dubbo"><span class="toc-number">27.</span> <span class="toc-text">Dubbo</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-number">27.1.</span> <span class="toc-text">结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90"><span class="toc-number">27.2.</span> <span class="toc-text">交互原理浅析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue"><span class="toc-number">28.</span> <span class="toc-text">Vue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4"><span class="toc-number">28.1.</span> <span class="toc-text">指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6"><span class="toc-number">28.2.</span> <span class="toc-text">组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E5%AE%9E%E4%BE%8B"><span class="toc-number">28.3.</span> <span class="toc-text">Vue实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95"><span class="toc-number">28.4.</span> <span class="toc-text">模板语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7"><span class="toc-number">28.5.</span> <span class="toc-text">计算属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%A6%E5%90%AC%E5%99%A8watch"><span class="toc-number">28.6.</span> <span class="toc-text">侦听器watch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6-amp-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83"><span class="toc-number">28.7.</span> <span class="toc-text">单文件组件&amp;生产环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="toc-number">28.8.</span> <span class="toc-text">Vue项目结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-CLI"><span class="toc-number">29.</span> <span class="toc-text">Vue CLI</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E6%88%90"><span class="toc-number">29.1.</span> <span class="toc-text">组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91"><span class="toc-number">29.2.</span> <span class="toc-text">快速开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F"><span class="toc-number">29.3.</span> <span class="toc-text">模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker"><span class="toc-number">30.</span> <span class="toc-text">Docker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">30.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8"><span class="toc-number">30.2.</span> <span class="toc-text">命令大全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dockerfile"><span class="toc-number">30.3.</span> <span class="toc-text">dockerfile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">30.4.</span> <span class="toc-text">网络模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86"><span class="toc-number">30.5.</span> <span class="toc-text">架构原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%87%E4%BB%BD%E8%BF%98%E5%8E%9F"><span class="toc-number">30.6.</span> <span class="toc-text">备份还原</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#etcd"><span class="toc-number">31.</span> <span class="toc-text">etcd</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#etcd%E9%83%A8%E7%BD%B2%E7%9A%84%E5%9D%91"><span class="toc-number">31.1.</span> <span class="toc-text">etcd部署的坑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C"><span class="toc-number">31.2.</span> <span class="toc-text">数据库操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#k8s"><span class="toc-number">32.</span> <span class="toc-text">k8s</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BE%E5%8C%BA%E6%8C%87%E5%8D%97"><span class="toc-number">32.1.</span> <span class="toc-text">社区指南</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="toc-number">32.2.</span> <span class="toc-text">服务发现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E4%BB%A5%E5%8F%8A%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91"><span class="toc-number">32.3.</span> <span class="toc-text">部署以及遇到的坑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ubuntu%E4%B8%8A%E9%83%A8%E7%BD%B2"><span class="toc-number">32.4.</span> <span class="toc-text">ubuntu上部署</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">32.5.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%B7%A5%E5%85%B7-kubectl"><span class="toc-number">32.6.</span> <span class="toc-text">操作工具 kubectl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84-1"><span class="toc-number">32.7.</span> <span class="toc-text">结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#k8s%E7%BD%91%E7%BB%9C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B7%A8%E4%B8%BB%E6%9C%BA"><span class="toc-number">32.8.</span> <span class="toc-text">k8s网络如何实现跨主机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Istio"><span class="toc-number">33.</span> <span class="toc-text">Istio</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#elastic-search"><span class="toc-number">34.</span> <span class="toc-text">elastic search</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">34.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#REST-API"><span class="toc-number">34.2.</span> <span class="toc-text">REST API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#flink"><span class="toc-number">35.</span> <span class="toc-text">flink</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Opentelemetry"><span class="toc-number">36.</span> <span class="toc-text">Opentelemetry</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Delta%E5%8E%8B%E7%BC%A9"><span class="toc-number">37.</span> <span class="toc-text">Delta压缩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E7%B1%BB"><span class="toc-number">38.</span> <span class="toc-text">数据库分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS-x2F-SSL-x2F-TLS"><span class="toc-number">39.</span> <span class="toc-text">HTTPS&#x2F;SSL&#x2F;TLS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E4%BF%A1%E7%9A%84%E8%BF%87%E8%BD%BD%E6%8E%A7%E5%88%B6"><span class="toc-number">40.</span> <span class="toc-text">微信的过载控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%9A%E5%AE%A2"><span class="toc-number">41.</span> <span class="toc-text">一个分布式博客</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#timing-model"><span class="toc-number">41.1.</span> <span class="toc-text">timing model</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ipc"><span class="toc-number">41.2.</span> <span class="toc-text">ipc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#failure-mode"><span class="toc-number">41.3.</span> <span class="toc-text">failure mode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#failure-detectors"><span class="toc-number">41.4.</span> <span class="toc-text">failure detectors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#leader-election"><span class="toc-number">41.5.</span> <span class="toc-text">leader election</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#consensus"><span class="toc-number">41.6.</span> <span class="toc-text">consensus</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Quorums"><span class="toc-number">41.7.</span> <span class="toc-text">Quorums</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D%E5%8D%9A%E5%AE%A2"><span class="toc-number">41.8.</span> <span class="toc-text">一个监控系统介绍博客</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC"><span class="toc-number">42.</span> <span class="toc-text">服务网格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LLVM"><span class="toc-number">43.</span> <span class="toc-text">LLVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="toc-number">43.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kaleidoscope%E6%95%99%E7%A8%8B"><span class="toc-number">43.2.</span> <span class="toc-text">kaleidoscope教程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#buildingAJIT"><span class="toc-number">43.3.</span> <span class="toc-text">buildingAJIT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clang%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84"><span class="toc-number">43.4.</span> <span class="toc-text">clang源码结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LVS"><span class="toc-number">44.</span> <span class="toc-text">LVS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="toc-number">45.</span> <span class="toc-text">图神经网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">45.1.</span> <span class="toc-text">基础概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BF%83%E6%80%A7%E6%A6%82%E5%BF%B5"><span class="toc-number">45.1.1.</span> <span class="toc-text">中心性概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PageRank%E7%AE%97%E6%B3%95"><span class="toc-number">45.1.2.</span> <span class="toc-text">PageRank算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HITS%E7%AE%97%E6%B3%95"><span class="toc-number">45.1.3.</span> <span class="toc-text">HITS算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#graph-embedding"><span class="toc-number">45.2.</span> <span class="toc-text">graph embedding</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#deepwalk%E7%AE%97%E6%B3%95"><span class="toc-number">45.2.1.</span> <span class="toc-text">deepwalk算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LINE%E7%AE%97%E6%B3%95"><span class="toc-number">45.2.2.</span> <span class="toc-text">LINE算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node2vec"><span class="toc-number">45.2.3.</span> <span class="toc-text">Node2vec</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct2vec"><span class="toc-number">45.2.4.</span> <span class="toc-text">struct2vec</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SDNE"><span class="toc-number">45.2.5.</span> <span class="toc-text">SDNE</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="toc-number">45.3.</span> <span class="toc-text">基础图神经网络</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GCN"><span class="toc-number">45.3.1.</span> <span class="toc-text">GCN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GraphSAGE"><span class="toc-number">45.3.2.</span> <span class="toc-text">GraphSAGE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GAT"><span class="toc-number">45.3.3.</span> <span class="toc-text">GAT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">45.3.4.</span> <span class="toc-text"></span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PyTorch"><span class="toc-number">46.</span> <span class="toc-text">PyTorch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PyTorch-Geometric"><span class="toc-number">47.</span> <span class="toc-text">PyTorch Geometric</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Scipy%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5"><span class="toc-number">48.</span> <span class="toc-text">Scipy稀疏矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pandas"><span class="toc-number">49.</span> <span class="toc-text">Pandas</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#networkx"><span class="toc-number">50.</span> <span class="toc-text">networkx</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pcalg"><span class="toc-number">51.</span> <span class="toc-text">Pcalg</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">52.</span> <span class="toc-text">概率图模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Simpson%E2%80%99s-paradox"><span class="toc-number">52.1.</span> <span class="toc-text">Simpson’s paradox</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SCM%E4%B8%8E%E5%9B%BE"><span class="toc-number">52.2.</span> <span class="toc-text">SCM与图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-%E7%BB%93%E6%9E%84"><span class="toc-number">52.3.</span> <span class="toc-text">v-结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-separation"><span class="toc-number">52.4.</span> <span class="toc-text">D-separation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E6%A3%80%E9%AA%8C%E4%B8%8E%E7%AD%89%E4%BB%B7%E7%B1%BB"><span class="toc-number">52.5.</span> <span class="toc-text">模型检验与等价类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%98%E7%A7%AF%E5%88%86%E8%A7%A3%E6%B3%95%E5%88%99"><span class="toc-number">52.6.</span> <span class="toc-text">乘积分解法则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E6%B7%86%E5%8F%98%E9%87%8F"><span class="toc-number">52.7.</span> <span class="toc-text">混淆变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VAE"><span class="toc-number">53.</span> <span class="toc-text">VAE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AE"><span class="toc-number">53.1.</span> <span class="toc-text">AE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VAE-1"><span class="toc-number">53.2.</span> <span class="toc-text">VAE</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flow-based-Model"><span class="toc-number">54.</span> <span class="toc-text">Flow-based Model</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PU-Learning"><span class="toc-number">55.</span> <span class="toc-text">PU Learning</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%82-1"><span class="toc-number">56.</span> <span class="toc-text">杂</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ubuntu%E6%9B%B4%E6%94%B9%E5%90%AF%E5%8A%A8%E7%BA%A7%E5%88%AB"><span class="toc-number">56.1.</span> <span class="toc-text">ubuntu更改启动级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vscode%E7%9B%B8%E5%85%B3"><span class="toc-number">56.2.</span> <span class="toc-text">vscode相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%B0%BE%E5%BB%B6%E8%BF%9F%E6%95%88%E5%BA%94"><span class="toc-number">56.3.</span> <span class="toc-text">高并发系统中的尾延迟效应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%B5%E5%85%A5%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">56.4.</span> <span class="toc-text">侵入式数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%91"><span class="toc-number">56.5.</span> <span class="toc-text">坑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CGI-x2F-fastCGI-x2F-php-fpm"><span class="toc-number">56.6.</span> <span class="toc-text">CGI&#x2F;fastCGI&#x2F;php-fpm</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/28/jdk_note/" title="JDK Note">JDK Note</a><time datetime="2023-05-27T18:34:52.956Z" title="发表于 2023-05-28 02:34:52">2023-05-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/23/osu_note/" title="osu!droid note">osu!droid note</a><time datetime="2023-05-23T13:07:21.141Z" title="发表于 2023-05-23 21:07:21">2023-05-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/19/note/" title="无题">无题</a><time datetime="2023-05-19T02:30:59.383Z" title="发表于 2023-05-19 10:30:59">2023-05-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/17/java_8gu/" title="无聊的八股">无聊的八股</a><time datetime="2023-05-17T02:33:15.928Z" title="发表于 2023-05-17 10:33:15">2023-05-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/16/mame/" title="misc">misc</a><time datetime="2023-05-16T14:52:16.784Z" title="发表于 2023-05-16 22:52:16">2023-05-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By fallingleaflun</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>